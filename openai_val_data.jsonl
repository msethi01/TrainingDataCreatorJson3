{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Using Incomplete UPF Information"}, {"role": "assistant", "content": "To load the power intent and apply it to a multivoltage design, 1. Read the UPF file by using the load_upf command. fc_shell> load_upf block.upf 2. If you are using the golden UPF flow and have a name-mapping file, read the file by using the read_name_map command. fc_shell> read_name_map block.nmf 3. (Optional) Verify the UPF consistency and identify any PG conflicts among the netlist, floorplan, and power intent. To verify the UPF consistency and identify PG conflicts, use the resolve_pg_nets -check_only command. This command identifies any issues and reports the changes that are made to resolve these issues when you commit the power intent. If you prefer to resolve the issues differently, you can use manual editing commands to resolve the issues before running the commit_upf command. 4. Commit the power intent by using the commit_upf command. fc_shell> commit_upf The commit_upf command performs global checks for UPF consistency; resolves PG conflicts among the netlist, floorplan, and UPF specification; and associates power strategies with existing multivoltage cells. For more information about associating power strategies with existing multivoltage cells, see Associating Power Strategies With Existing Multivoltage Cells 5. Report the associations made for the multivoltage cells by using the report_mv_path command. If the tool failed to associate any multivoltage cells, the command reports the causes for these failures. You must successfully commit the power intent before you continue with the design flow. Note: After successfully running the commit_upf command, the tool issues an error message if you try to use additional UPF commands, except for the set_related_supply_net connect_supply_net set_design_attributes set_port_attributes find_objects, and set_scope commands. To modify the power intent after running the commit_upf command, you must remove the existing UPF specification by using the reset_upf command and then reload the power intent."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Deriving Routing Guides"}, {"role": "assistant", "content": "To remove routing guides from the current block, use the remove_routing_guides command. To remove specific routing guides, specify the routing rules, either as a list or collection, such as that returned by the get_routing_guides command. To remove all routing guides, specify the -all option. For example, to remove the new_width_rule routing rule, use the following command: fc_shell> remove_routing_rules new_width_rule"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Mapping of Synchronous Reset or Preset Registers"}, {"role": "assistant", "content": "During test-ready compile, the tool replaces regular flip-flops with flip-flops that contain logic for testability. The following figure shows an example of how a D flip-flop is replaced with a scan register during test-ready compile. This type of architecture, a multiplexed flip- flop, incorporates a 2-input MUX at the input of the D flip-flop. The select line of the MUX enables two modes\u2014functional mode (normal data input) and test mode (scanned data input). In this example, the scan-in pin is si, the scan-enable pin is se, and the scan-out pin, so, is shared with the functional output pin, Q. si Clk se Q/so When you run the compile_fusion command, The tool maps all sequential cells directly to scan registers in your library The scan pins, such as scan enable and scan out, are unconnected The scan output pin of a scan register is used for scan connections Use the seqmap.bind_scan_pins application option to hold the scan enable pin inactive If the library contains no scan registers, the tool uses nonscan cells for mapping and issues a warning. Set the dont_use attribute on all scan registers in the library to map to nonscan cells"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Enabling Enhanced Delay Optimization to Improve Total Negative"}, {"role": "assistant", "content": "In most cases, you can achieve better timing QoR by enabling high-effort timing mode for compile. To enable this mode, set the compile.flow.high_effort_timing application option to Running high-effort timing mode during compile can increase runtime because the tool performs multiple passes of placement and optimization to obtain optimal timing results."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Up Libraries"}, {"role": "assistant", "content": "The Fusion Compiler tool uses a search path to look for files that are specified with a relative path or with no path. To specify the search path, use the set_app_var command to set the search_path application variable to the list of directories, in order, in which to look for files. When the tool looks for a file, it starts searching in the leftmost directory specified in the search_path variable and uses the first matching file it finds. You can also use the Tcl lappend command to add your directories to the default search path, which is the directory from which you invoked the tool. For example, fc_shell> lappend search_path./mylibdir"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Updating Supply Nets for ECO Cells"}, {"role": "assistant", "content": "When the tool maps an ECO cell, it looks for a spare cell with the same library cell name. If it is unable to find such a spare cell, the ECO cells remains unmapped. To identify and map such ECO cells to logically equivalent (LEQ) spare cells, use the following steps: 1. Identify the ECO cells that do not have matching spare cells by using the check_freeze_silicon command. 2. Find logically equivalent spare cells for these ECO cells by using the create_freeze_silicon_leq_change_list command. Specify The names of the unmapped ECO cells by using the -cells option A name for the output file by using the -output option This output file is a Tcl script with netlist editing commands. The commands replace each ECO cell with logically equivalent spare cells, which can be a Single spare cell with the same logical functionality, but a different library cell name Combination of up to two spare cells that give the same logical functionality 3. View the output Tcl file to ensure that the ECO mapping is satisfactory, and it if necessary. 4. Source the Tcl file in the tool to replace the ECO cells with their logical equivalents."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting the Rerouting Mode"}, {"role": "assistant", "content": "If a pin has a via ladder, by default, Zroute connects to the topmost layer of a via ladder and not directly to the existing pin geometry. To modify the connection constraints, set the following application options: route.detail.via_ladder_upper_layer_via_connection_mode To allow vias to connect to the top level of a via ladder from below, set this application option to any route.detail.allow_default_rule_nets_via_ladder_lower_layer_connection To allow nets with default routing rules to connect directly to the pin or to any layer of the via ladder, set this application option to true"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Querying Placement Blockages"}, {"role": "assistant", "content": "To define a partial blockage that allows buffers only, specify the boundary, type ( -type allow_buffer_only option), blockage percentage ( -blocked_percentage option), and optionally the name for the placement blockage. For example, to define a partial blockage that allows only the placement of buffers and inverters, with a cell density of 30 percent, use the following commands: create_placement_blockage -boundary {{10 20} {100 200}} \\ -type allow_buffer_only -blocked_percentage 70 Note: Buffer-only blockages are honored during placement, but not during legalization, optimization, or clock tree synthesis."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Saving UPF Information"}, {"role": "assistant", "content": "The UPF constraints for physical-only cells can cause issues when the UPF file is read into other tools that do not support physical-only cells, such as verification tools. Therefore, surround the UPF constraints for physical-only cells with the syntax shown in the following example: if {[info exists snps_handle_physical_only] && \\ $snps_handle_physical_only} { /* Supply net connections for filler cells */ connect_supply_net VDDS -ports [get_pins FILLER*/VDD] By default, the snps_handle_physical_only variable is set to true in the Fusion Compiler tool. Therefore, when you load and commit the UPF file, the constraints are applied to the physical-only cells. When you save a UPF file with the save_upf command, the tool uses the same syntax for the user-specified and tool-derived UPF constraints for physical-only cells. Therefore, these UPF constraints are ignored by any tool that does not have the snps_handle_physical_only variable set to true To create a UPF file that contains commands only for specific types of cells, use the -include or -exclude option with the save_upf command. These options accept arguments such as diode_cells pad_cells, and physical_only_cells. See the save_upf command man page for the complete list of arguments. Command filtering for specified cell types applies to the connect_supply_net set_related_supply_net create_power_domain, and set_isolation commands. You can apply command filtering to both block-level and full-chip UPF files."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Multivoltage Cells"}, {"role": "assistant", "content": "To remove voltage areas from a block, use the remove_placement_blockage comandcomandsremove_placement_blockage remove_voltage_areas command. To remove all voltage areas from a block, use the -all option. To remove specific voltage areas from a block, specify the voltage area names."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Adding Cells Within a Predefined Relative Placement Area"}, {"role": "assistant", "content": "To add a blockage within relative placement groups, use the -blockage option with the add_to_rp_group command. When you add a blockage using this command, you can specify The column and row position within the relative placement group by using the -column and -row options. If you do not specify a position, the tool adds the blockage to position (0,0). The size of the blockage by using the -height and -width options. If you do not specify the -height or -width option, the tool determines the size based on the tiling type of the relative placement group as follows: For a tiling type setting of bit_slice, the height default to the height of site row and the width to width of the column. For a tiling type setting of compression, the height default to the height of site row and the width to the width of one site. That the blockages can overlap with other relative placement blockages or other objects that are not relative placement cells by using the -allow_overlap option. The following example adds a blockage named gap1 to the rp1 relative placement group at position (0,2) that is one site row high and five site rows wide: fc_shell> add_to_rp_group rp1-blockage gap1 \\ -column 0 -row 2 -width 5 -height 1"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Removing Routing Blockages"}, {"role": "assistant", "content": "To find routing blockages, use the get_routing_blockages command. For example, to get all the routing blockages in a block, use the following command: fc_shell> get_routing_blockages * To find the routing blockages for specific nets, use the -of_objects option to specify the nets of interest. For example, to find the routing blockages for the n1 net, use the following command: fc_shell> get_routing_blockages -of_objects [get_nets n1] To find the routing blockages in a specific location, use the get_objects_by_location -classes routing_blockage command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Enabling Leakage Power Optimization for the compile_fusion"}, {"role": "assistant", "content": "The leakage power of a block is scaled based on the switching probability of its supply nets, which represents the fraction of time a supply net is in the on state. You can specify the switching probability for one or more supply nets by using the set_supply_net_probability -static_probability command. By default, the switching probability is applied to the current scenario and the corresponding mode and corner. To specify modes, corners, or scenarios in which to apply the setting, use the -modes -corners, or -scenarios option. To get the switching probability of a supply net, use the get_supply_net_probability command, and to reset the value, use the reset_supply_net_probability command. By default, the tool propagates supply net activity through power switches and determines the static probability of the switched supply net based on the UPF power switch constraint. For example, consider the following UPF power switch constraint: create_power_switch my_switch \\ -output_supply_port {vout VDDS} \\ -input_supply_port {vin VDD} \\ -control_port {ms_sel ctrl1} \\ -control_port {ms_ctrl ctrl2} \\ -on_state {on vin {ms_ctrl &&!ms_sel}} The tool derives the static probability of the supply net named VDDS, which is connected to the output of the power switch, based on the probability of the power switch being on This is derived based on the following: The Boolean function specified with the -on_state option, which is ms_ctrl &&! ms_sel, and the switching activity (static probability) of the nets connected to the corresponding control ports, which are nets named ctrl1 and ctrl2. The switching probability of the supply net connected to the input supply port specified with the -on_state option, which is the supply net named VDD. The following application options control whether dynamic and leakage power are scaled based on the supply switching activity: The power.scale_dynamic_power_at_power_off option controls whether dynamic power is scaled. The default is false (no scaling). The power.scale_leakage_power_at_power_off option controls whether leakage power is scaled. The default is true (scaling is performed)."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Defining Custom Vias"}, {"role": "assistant", "content": "To define a simple via or via array, use the following create_via_def syntax: create_via_def -cut_layer layer -cut_size { width height -upper_enclosure { width height -lower_enclosure { width height [-min_rows number_of_rows [-min_columns number_of_columns [-min_cut_spacing distance [-cut_pattern cut_pattern [-is_default] [-force] via_def_name You do not need to specify the enclosure layers; the tool determines them from the technology file by getting the metal layers adjacent to the specified via layer. By default, when you define a simple via, it is a single-cut via. To define a via array, specify the minimum number of rows and columns for the array ( -min_rows and -min_columns options), as well as the minimum cut spacing ( -min_cut_spacing option). By default, the cut pattern is a full array of cuts. To modify the cut pattern, use the -cut_pattern option. To overwrite an existing via definition, use the -force option; otherwise, the command fails if the specified via definition already exists. For example, to create a single-cut via definition named design_via1_HV for the VIA12 via layer, use the following command: fc_shell> create_via_def design_via1_HV \\ -cut_layer VIA12 -cut_size {0.05 0.05} \\ -lower_enclosure {0.02 0.0} -upper_enclosure {0.0 0.2} \\ To create a via definition with an alternating 2x2 cut pattern in which the lower-left cut is omitted, use the following command: fc_shell> create_via_def design_via12 -cut_pattern \"01 10\" To report information about the user-defined via definitions, use the report_via_defs command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Settings for Clock Latency Adjustments"}, {"role": "assistant", "content": "The timing of a design can be improved by reducing signal integrity issues on clock nets. To do so, the tool can derive nondefault routing rules with larger spacing requirements and assign them to the clock nets in regions without routing congestion. To enable this feature, use the following application option setting: fc_shell> set_app_options \\ -name cts.optimize.enable_congestion_aware_ndr_promotion -value true When the tool derives a new nondefault routing rule for a clock net, the new spacing requirement is dependent on the spacing requirement of the existing routing rule of that net. If the existing routing rule is A nondefault routing rule with a spacing requirement of less than or equal to two times the default spacing, the spacing requirement is doubled The name of this new nondefault rule is the original name with an _ext_spacing postfix. A nondefault routing rule with a spacing requirement of more than two times the default spacing, the spacing requirement is increased by one default spacing The name of this new nondefault rule is the original name with an _ext_spacing postfix. The default routing rule, the spacing requirement is doubled The name of this new nondefault rule is default_rule_equivalent_ndr_double_spacing."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Constraint-Based Via Ladder Insertion"}, {"role": "assistant", "content": "The command generates a script file that defines the association between the library cell pins and the via ladder rules. This script file contains set_via_ladder_candidate commands for the library cell pins. By default, the generated script file is named auto_perf_via_ladder_association.tcl. To specify a different file name, use the -association_file option."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Mapping ECO Cells to Logically Equivalent Spare Cells"}, {"role": "assistant", "content": "To map an ECO cell to a specific spare cell, use the map_freeze_silicon command. Specify the ECO cell name and the corresponding spare cell name by using the -eco_cell and -spare_cell options. The following example maps the ECO cell named ECO1 to the spare cell named spare_1: fc_shell> map_freeze_silicon -eco_cell ECO1 -spare_cell spare_1 You can specify the ECO cell to spare cell mapping by using a map file and specifying this map file name by using the -map_file option with the map_freeze_silicon command. The map file has the following format: ECO_cell_1 spare_cell_1 ECO_cell_2 spare_cell_2......"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Threshold-Voltage-Based Filler Cell Insertion"}, {"role": "assistant", "content": "If your technology requires specific filler cells on the left or right sides of certain standard cells, use the create_left_right_filler_cells command to insert these filler cells. After you run the create_left_right_filler_cells command, perform standard filler cell insertion to fill the remaining gaps in the design. You must use the -lib_cells option to specify the rules for filler cell insertion. Each rule uses the following format: standard_cells } { left_filler_cells } { right_filler_cells For the standard_cells argument, You must specify a list of one or more standard cells You can use wildcards to specify the cell names If you specify multiple rules for the same standard cell, the command uses only the last rule specified for that cell. For the left_filler_cells and right_filler_cells arguments, At least one of these arguments must contain one or more filler library cells If only one of the arguments contains filler library cells, the tool inserts filler cells only on that side of the standard cells. The specified filler cells must meet the following requirements: They must have a design_type attribute of lib_cell or filler They must use the same site definition as the standard cells. The height of the standard cells must be an integer multiple of the filler cell heights. The command tries to insert the filler cells in the order that you specify; for the best results, specify them from the largest to the smallest. You can use wildcards for the filler cell names. When you use wildcards, the order of the cells is the same as that returned by the get_lib_cells command. The following example inserts filler cells on the left and right sides of the SC1 standard cells and only on the left side of the SC2 standard cells. The left and right filler cells are specified in decreasing size order, so that the command inserts the largest possible filler cell. fc_shell> create_left_right_filler_cells \\ -lib_cells { { {mylib/SC1} {mylib/LF4X mylib/LF2X} {mylib/RF2X mylib/RF1X} } { {mylib/SC2} {mylib/LF2X mylib/LF1X} {} } } When the create_left_right_filler_cells command inserts the filler cells, It checks for legal locations for the filler cells, but does not check advanced rules such as minimum threshold voltage, oxide-diffusion (OD), or trimpoly (TPO) rules. It inserts the filler cells immediately next to the standard cells; it does not consider the intercell spacing rules. See Also Standard Filler Cell Insertion Controlling Cell-Based Filler Cell Insertion You can control the following aspects of the filler cell insertion with the create_left_right_filler_cells command: The region in which to insert the filler cells By default, the command inserts filler cells next to the specified standard cells in the entire block. Use the -boundaries option to restrict filler cell insertion to the specified regions. You can specify one or more rectangular or rectilinear regions. Use the -voltage_areas option to restrict filler cell insertion to the specified voltage areas. The orientation of the filler cells By default, the command uses the allowable orientations of the row to place the filler cells. To use the same orientation as the standard cell, use the -follow_stdcell_orientation option. When you use this option, the tool swaps the right and left filler cells when the cell is flipped. The handling of one-unit-tile gaps By default, the command does not consider the one-unit-tile rule. To prevent the tool from inserting filler cells that would leave a one-unit-tile gap, use the -rules no_1x option. When you enable this rule, do not include filler library cells with a width of one- unit tile in the -lib_cells option; otherwise, the tool ignores this rule. The naming convention used to identify the inserted filler cell instances By default, the command uses the following naming convention for inserted filler cells: xofiller! filler_library_cell_name number To identify the filler cells inserted in a specific run, use the -prefix option to specify a prefix string. When you use this option, the command uses the following naming convention: xofiller! prefix filler_library_cell_name number"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Routing Secondary Power and Ground Pins"}, {"role": "assistant", "content": "To route a group of critical nets before routing the rest of the nets in the block, use the route_group command. To specify the nets to route, use one of the following options: -nets Use this option to specify the nets on the command line: fc_shell> route_group -nets collection_of_critical_nets -from_file Use this option to specify the nets in a file: fc_shell> route_group -from_file file_name If the specified nets are associated with a routing corridor, the nets are routed within the defined region. Note that global routing considers routing corridors as a hard constraint, while track assignment and detail routing consider routing corridors as a soft constraint and might route nets slightly outside of the routing corridor to fix DRC violations. By default, the route_group command ignores existing global routes, reuses dangling wires and existing detail routes on the specified nets, and runs global routing, track assignment, and detail routing on the specified nets. To perform incremental global routing, set the -reuse_existing_global_route option to true Note: You cannot use the -reuse_existing_global_route true option when routing the nets in a routing corridor. If you use this option, the global router ignores the routing corridors. To disable the reuse of dangling wires, set the -utilize_dangling_wires option to false To stop after global routing, set the -stop_after_global_route option to true By default, the detail router performs a maximum of 40 iterations search and repair iterations. If Zroute determines before then that all violations have been fixed or that it cannot fix the remaining violations, it stops. To change the maximum number of detail routing iterations, use the -max_detail_route_iterations option. By default, the route_group command does not fix soft DRC violations, such as bridge rule violations. To enable the fixing of soft DRC violations after the final detail routing iteration, set the route.common.post_group_route_fix_soft_violations application option to true fc_shell> set_app_options \\ -name route.common.post_group_route_fix_soft_violations \\ -value true"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Up Multivoltage Designs"}, {"role": "assistant", "content": "Use the commands and application options described in this topic to create constraints for auto floorplanning. Commands Use the following two commands to set and report auto floorplanning constraints. These two commands do not affect explicit floorplanning. set_auto_floorplan_constraints The command sets constraints, such as utilization of the floorplan to be created during compile. For example, fc_shell> set_auto_floorplan_constraints -core_utilization 0.8 report_auto_floorplan_constraints The command reports the constraints set by the set_auto_floorplan_constraints command. To specify macro placement, pin placement, and voltage area shaping constraints, use the following commands: Macro placement constraints set_macro_constraints create_macro_array create_keepout_margin Pin placement constraints set_block_pin_constraints set_individual_pin_constraints Voltage area shaping constraints set_shaping_options Application Options Use these application options to set up auto floorplanning. compile.auto_floorplan.initialize (default: auto auto : Creates missing floorplan information. The tool exits with an error when inconsistent information is provided. true : Always creates the core and boundary. false : Never creates the core and boundary; uses only existing information. The tool exits with an error when encountering missing or inconsistent information. By default, the following objects are preserved: Existing placement of fixed macros Existing placement of pins and pads Existing shaping of voltage areas compile.auto_floorplan.place_pins (default: unplaced compile.auto_floorplan.place_ios (default: unplaced compile.auto_floorplan.place_hard_macros (default: unplaced compile.auto_floorplan.shape_voltage_areas (default: unshaped all : Always places and shapes objects even if they are fixed. Unplaced and unshaped objects will always be placed and shaped. unfixed : Places and shapes objects that are not fixed. Use the fixed information from DEF files or a Tcl floorplan, and use the set_fixed_objects command to modify. Unplaced and unshaped objects will always be placed and shaped. unplaced, unshaped : Never places or shapes objects when they are already placed. Unplaced and unshaped objects will always be placed and shaped. none : Never places or shapes objects even if they are not already placed. This table summarizes how the tool handles fixed, placed, and unplaced objects for each setting of these four application options during auto floorplanning. Application option setting Fixed objects Placed objects Unplaced objects all unfixed unplaced, unshaped none compile.auto_floorplan.keep_bounds (default: auto auto : Removes existing bounds if either of the following two application options is set to all compile.auto_floorplan.place_hard_macros compile.auto_floorplan.shape_voltage_areas true : Keeps existing bounds. false : Removes existing bounds. compile.auto_floorplan.keep_placement_blockages (default: auto auto : Removes existing placement blockages if either of the following two application options is set to all compile.auto_floorplan.place_hard_macros compile.auto_floorplan.shape_voltage_areas true : Keeps existing placement blockages. false : Removes existing placement blockages. Automatic Floorplanning Example The following example specifies constraints for automatic floorplanning: # Application options with default settings # set_app_options -name compile.auto_floorplan.initialize -value auto # set_app_options -name compile.auto_floorplan.place_pins -value unplaced # set_app_options -name compile.auto_floorplan.place_ios -value unplaced # set_app_options -name compile.auto_floorplan.place_hard_macros \\ # -value unplaced # set_app_options -name compile.auto_floorplan.shape_voltage_areas \\ # -value unshaped # Constraint settings for automatic floorplanning set_auto_floorplan_constraints -core_utilization 0.75 -side_ratio {1 2} set_macro_constraints -preferred_location {0 0} RAM0 set_block_pin_constraints -self -sides {1 3} set_individual_pin_constraints -ports [get_ports reset] -side 1 set_shaping_options -guard_band_size 2"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling Sequential Mapping"}, {"role": "assistant", "content": "You need to have multiplexer cells in the logic library and also require to use multiplexing logic from the cell library. The following section describes library requirements to implement multiplexer cells for multiplexer optimization or to implement multiplexing logic from the cell library to control MUX mapping: Understanding Library Cell Requirements for Multiplexer Optimization Implementing Multiplexing Logic From Cell Library Understanding Library Cell Requirements for Multiplexer Optimization The multiplexer optimization requires the presence of at least a 2:1 multiplexer cell in the logic library. The inputs or outputs of this cell can be inverted. If a 2:1 multiplexer primitive cell does not exist in the library, you see the following warning message: Warning: Target library does not contain any 2-1 multiplexer. (OPT-853) An implementation of the MUX_OP cell from the target library is created, but it might not be the best implementation possible. All multiplexer cells in the target library can be used to construct the implementation of the MUX_OP cell except Enabled multiplexer cells Bused output multiplexer Multiplexers larger than 32 : 1 For Fusion Compiler to make the best use of the multiplexer cells available in your logic library, recompile the library or obtain a library compiled with version V3.4a or later from your ASIC vendor. Implementing Multiplexing Logic From Cell Library During logic synthesis, the tool implements multiplexing logic from the cell library using one of the following methods: AND, OR, and INV gates MUX gates The tool evaluates the area effect of both methods and selects the solution with the smallest area. You can specify that the tool uses MUX gates to implement specific multiplexing logic by applying the map_to_mux attribute on the corresponding SELECT_OP WVGTECH cells in the block, as shown in Example 16 Example 16 Using map_to_mux attribute to implement specific multiplexing logic # Apply the map_to_mux attribute on the SELECT_OP cell named C10 set_attribute -objects [get_cells C10] -name map_to_mux -value true # Query if the attribute is set as required on C10 get_attribute -objects [get_cells C10] -name map_to_mux #Run the compile step compile_fusion #Identify the cell created using the map_to_mux attribute get_cells -hier -filter \"map_to_mux==true &&!infer_mux_override\""}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Checking Options"}, {"role": "assistant", "content": "Note: Missing via and unconnected pin checking is supported in both RedHawk Fusion and RedHawk-SC Fusion analysis flows. Before you check for missing vias and unconnected pins, make sure you have the required input files as described in Preparing Design and Input Data for Rail Analysis Check for missing vias or unconnected pins in the block during voltage drop analysis or in a separate run. For example, you can perform the checking after completing the power structure and before running the place_opt command. This allows you to find power network errors in the design before rail analysis. By default, RedHawk/RedHawk-SC Fusion detects the following types of power network errors: Unconnected pin shapes: Pin shapes that are not contiguously and physically connected to an ideal voltage source. Missing vias: If two overlapping metal shapes do not contain a via within their overlapping area, it is considered a potential missing via error. To check for and fix missing vias or unconnected pins, 1. Define configuration options by using the set_missing_via_check_options command, as described in Setting Checking Options 2. Save the block by using the save_block command. 3. Perform the checking by using the analyze_rail -check_missing_via command, as described in Checking Missing Vias and Unconnected Pins. In the RedHawk-SC Fusion flow, you must specify the -check_missing_via option together with the -voltage_drop option. 4. Examine the checking results by opening the generated error files in the error browser or writing the checking results to an output file, as described in Viewing Error Data and Writing Analysis and Checking Reports 5. Insert PG vias to fix the reported missing vias, as described in Fixing Missing Vias"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling Threshold-Voltage-Based Filler Cell Insertion"}, {"role": "assistant", "content": "In the threshold-voltage-based flow, the tool selects the filler cells by using user-defined insertion rules, which are based the threshold-voltage types of the cells that border the gap. This flow is typically used only for established foundry nodes. To perform threshold-voltage-based filler cell insertion, 1. Ensure that the block is legalized by using the check_legality command. 2. Annotate the threshold-voltage types on the reference cells by using the set_cell_vt_type command. For example, to specify that all cells whose names end with _vtA have a threshold voltage type of vtA and the invx1 cell has a threshold voltage type of default, use the following commands: fc_shell> set_cell_vt_type -lib_cells \"*/*_vtA\" -vt_type vtA fc_shell> set_cell_vt_type -lib_cells \"mylib/invx1\" -vt_type default 3. Define the rules for inserting the filler cells by using the set_vt_filler_rule command. You define the rules by specifying the filler cells to insert based on the threshold- voltage types of the cells on the left and right of the gap being filled. For example, to specify that filler2x or filler1x cells can be inserted in a gap that has default threshold-voltage cells on the left and right sides and fillerA2x and fillerA1x cells can be inserted in a gap that has vtA threshold-voltage cells on the left and right sides, use the following commands: fc_shell> set_vt_filler_rule -vt_type {default default} \\ -filler_cells {myLib/filler2x myLib/filler1x} fc_shell> set_vt_filler_rule -vt_type {vtA vtA} \\ -filler_cells {myLib/fillerA2x myLib/fillerA1x} 4. Insert the filler cells by using the create_vtcell_fillers command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying a Keepout Margin"}, {"role": "assistant", "content": "The Fusion Compiler tool supports the following orientations for relative placement groups: R0 The column position of the relative placement group is from left to right, and the row position is from bottom to top. R180 The column position of the relative placement group is from right to left, and the row position is from top to bottom. MY The column position of the relative placement group is from right to left, and the row position is from bottom to top; that is, the orientation of the group is flipped with respect to the R0 orientation. MX The column position of the relative placement group is from left to right, and the row position is from top to bottom; that is, the group is flipped with respect to the R180 orientation. shows how the column and row positions in a relative placement group are placed for the four orientations. Orientation of Relative Placement Groups Col 0 Col 1 Col 2 Col 2 Col 1 Col 0 R0 MY U3 U1 U23 U24 U21 U22 U1 U3 U4 U5 U6 U7 U8 U9 U7 U8 U9 U4 U5 U6 U24 U22 U23 U21 Row 2 Row 2 Row 1 Row 1 Row 0 Row 0 Col 0 Col 1 Col 2 Col 2 Col 1 Col 0 R180 MX U3 U1 U23 U24 U21 U22 U1 U3 U4 U5 U6 U7 U8 U9 U7 U9 U4 U6 U24 U22 U23 U21 U5 U8 Row 0 Row 0 Row 1 Row 1 Row 2 Row 2 The orientation of relative placement groups is automatically set by the tool to minimize wire length. You can also choose to set the orientation of relative placement groups by using the set_rp_group_options command. For example, the following command sets the relative placement group orientation to MY. fc_shell> set_rp_group_options [get_rp_groups design::rp] \\ -group_orientation MY For designs with hierarchical relative placement groups, the orientation settings are propagated down to the lowest level in hierarchy. Note: When the orientation of a relative placement group is changed, the constraints on the relative placement group, such as alignment and utilization, are preserved according to the specifications that you provide."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Exterior Tap Walls"}, {"role": "assistant", "content": "ad_tap_cel_aray comandcomandsad_tap_cel_aray To add a tap cell array with specific placement, use the create_cell_array command. You must specify the name of the library cell to use for tap cell insertion ( -lib_cell option), and the x- and y-pitches. For example, fc_shell> create_cell_array -lib_cell myreflib/mytapcell \\ -x_pitch 10 -y_pitch 10 By default, the create_cell_array command inserts a tap cell in each location in the specified grid for the entire block. The tool starts inserting the tap cells at the bottom-left of the core area and uses the specified x- and y-pitches to determine the location of the subsequent tap cells. The inserted tap cells are snapped to the site rows and placed in the default orientation for the site row. If a location is occupied by a fixed cell, hard macro, soft macro, or power-switch cell, the command does not insert a tap cell at that location. You can modify the following aspects of the default behavior: The region in which to insert tap cells Use the -voltage area option to restrict the tap cell insertion to the specified voltage areas. Use the -boundary option to restrict the tap cell insertion to the specified region. If you use both options, the command inserts tap cells only in the overlapping region. The offset from the insertion region boundary Use the -x_offset option to shift the pattern startpoint to the right by the specified distance in microns. Use the -y_offset option to shift the pattern startpoint up by the specified distance in microns. The insertion pattern Use the -checkerboard option to insert a tap cell in every other location in the specified grid. To place a tap cell in the lower-left corner, use the -checkerboard even option. To keep the lower-left corner empty, use the -checkerboard odd option. In some design methodologies, you must insert a tap cell in empty spaces in the checkerboard pattern that are above or below specific cells, such as critical area breaker cells or boundary cells. To enable the insertion of these extra tap cells, use the -preserve_boundary_row_lib_cells option to specify the affected library cells. The snapping behavior To disable snapping of the inserted tap cells to the site rows, set the -snap_to_site_row false option. When you set this option to false, the tool uses R0 as the default orientation for the inserted cells. The orientation of the inserted tap cell instances To specify the orientation of the inserted tap cells, use the -orient option to specify one of the following orientation values: R0 R90 R180 R270 MX MY MXR90, or MYR90 The naming convention used to identify the inserted tap cell instances By default, the tool uses the following naming convention for inserted tap cells: headerfooter__ library_cell_name _R _C number To identify the tap cells inserted in a specific run, use the -prefix option to specify a prefix string. When you use this option, the tool uses the following naming convention: prefix __ library_cell_name _R _C number"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Changing the Structures of Relative Placement Groups"}, {"role": "assistant", "content": "During coarse placement, to avoid the overlap of relative placement groups with the tap cell columns, use the place.coarse.no_split_rp_width_threshold application option. The overlap can be removed for only those relative placement groups whose width is less than the distance between tap columns. This application option helps the relative placement engine know about the distance between the tap columns. This helps in better placement and structures of relative placement groups in the design. You must use this application option for n5 and older technical nodes. For n3 and beyond designs, the distance between tap columns is calculated automatically. place.coarse.no_split_rp_width_threshold <value> For example, place.coarse.no_split_rp_width_threshold 46"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Configuring Distributed Processing"}, {"role": "assistant", "content": "Multithreading performs tasks in parallel by using multiple cores on the same machine, using a single process memory image. When using multithreading, each parallel task is called a thread. For the best performance during multithreading, you should limit the number of threads to the number of available cores, which is the number of CPUs in the machine times the number of cores per CPU. The following commands support multithreading configured by the set_host_options command: place_opt clock_opt check_legality, when advanced legalization is enabled by setting the place.legalize.enable_advanced_legalizer application option to true insert_via_ladders route_auto route_global route_track route_detail, and route_eco Note: When you run routing with a single thread, the result is deterministic; if you start with the same block, you always get the same result. However, if you use multiple threads, the routing results are not deterministic; the final routing is slightly different between runs due to the varying division of tasks between threads. Global routing supports a deterministic mode for multicore routing. To enable this mode, set the route.global.deterministic application option to on route_opt signoff_check_drc signoff_fix_drc signoff_create_metal_fill signoff_fix_isolated_via write_def By default, all commands use a single thread. To enable multithreading for those commands that support it, set the -max_cores option of the set_host_options command to a value greater than one and less than or equal to the number of cores available on your machine, which is the number of CPUs in the machine times the number of cores per CPU. The number of cores specified by the -max_cores option applies to all commands that support multithreading. When you enable multithreading, multithreaded commands create and use the specified number of threads, even if the number is more than the number of available cores. You must set an appropriate number of threads, so that the command does not try to use more resources than it has. Overthreading can reduce performance because the extra threads compete for resources. For best performance, do not run more than one thread per available core. For example, if your machine has two CPUs and each CPU has three cores, specify six as the maximum number of threads: fc_shell> set_host_options -max_cores 6"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Skew and Latency Targets"}, {"role": "assistant", "content": "You can restrict the libraries used during clock tree synthesis for the top level or a lower level of the logical hierarchy of a design by using the set_target_library_subset -clock command. To enable the use of the target library subset, you must set the opt.common.enable_target_library_subset_opt application option to The following example specifies the buf1 and buf2 cells from the HVT_lib and LVT_lib libraries as clock tree references. However, it restricts the lower-level block named TSK_BLK to use only the cells from the LVT_lib library for its clock nets. Therefore, only buf1 and buf2 cells from the LVT_lib library are used as clock references for that block. fc_shell> set_lib_cell_purpose -include cts \\ {HVT_lib/buf1 HVT_lib/buf2 LVT_lib/buf1 LVT_lib/buf2} fc_shell> set_target_library_subset -clock {LVT_lib} \\ -objects [TOP/TSK_BLK] fc_shell> set_app_options \\ -name opt.common.enable_target_library_subset_opt -value 1"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Clock Tree Synthesis"}, {"role": "assistant", "content": "DFT wrapper clock gates refer to those clock gates that drive only DFT wrapper cells. The clock gating engine prefixes dft_wrapper_ to the names of all DFT wrapper clock gates clock gates irrespective of their origin. This helps to identify specific clock gates driving wrapper cells during automatic test pattern generation (ATPG). Table 24 Commands and their expected return values Command Expected Return Value get_clock_gates -gating_wrapper_cells_only dft_wrapper_ICG dft_wrapper_clock_gate_reg get_clock_gates -gating_wrapper_cells_only -origin tool_inserted dft_wrapper_clock_gate_reg get_clock_gates -gating_wrapper_cells_only -origin pre_existing dft_wrapper_ICG get_clock_gates {ICG clock_gate_reg} -gating_wrapper_cells_only get_clock_gates {ICG dft_wrapper_clock_gate_reg} -gating_wrapper_cells_only dft_wrapper_clock_gate_reg get_clock_gates {*clock_gate_reg} -gating_wrapper_cells_only dft_wrapper_clock_gate_reg This feature works only when you enable clock gate support for DFT wrapper cells. To enable clock gate support for DFT wrapper cells, set the following variable to true compile.clockgate.enable_dft_wrapper_cell_support The following figures show how a clock gate can be split so that different clock gates can gate internal cells and wrapper cells separately: Splitting a Clock Gate to Internal Cells and Wrapper Cells Gating Internal Cells and Wrapper Cells Separately Note: The clock gates cloned to gate wrapper cells alone, inherit their names from parent clock gates and have dft_wrapper_ appended to their names. This is not applicable to the names of self-gates that drive wrapper cells only. Table 25 shows how different types of clock gates are renamed. Table 25 How different clock gate types are renamed Clock Gate Type Name New Name clock_gate_reg dft_wrapper_clock_gate_reg icg_0 dft_wrapper_icg_0 Use the -gating_wrapper_cells_only option with the get_clock_gates command to return all clock gates (except self-gates) that drive wrapper cells only. This option can be used in conjunction with the already existing options. Use the compile.clockgate.substring_list_for_dft_wrapper_dont_rename_icgs application option to restrict the renaming of pre-existing clock gates (driving wrapper cells only). This option accepts a list of strings as values. The clock gates matching any of the substrings provided in the application option are not renamed. Note: The compile.clockgate.substring_list_for_dft_wrapper_dont_rename_icgs application option does not have any effect on the -gating_wrapper_cells_only querying option. Consider the following example: set_app_options -name compile.clockgate.substring_list_for_dft_wrapper_dont_rename_icgs -value {clk_gate_ctl clk_gate_snps} This prevents the renaming of any pre-existing clock gates that have the clk_gate_ctl or clk_gate_snps pattern in their name but can still be queried using the get_clock_gates -gating_wrapper_cells_only command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Dense Tap Arrays"}, {"role": "assistant", "content": "tap mesh is a two-dimensional array of tap cells with a tap cell in each mesh window. A tap mesh is typically inserted outside of a place and route block, but you can insert one in any area that is either completely inside or completely outside the core area. To insert a tap mesh, use the create_tap_meshes command. You must specify the following information: The tap cell used in the tap mesh (the -lib_cell option) By default, the command inserts the tap cells with R0 orientation. To place the cells with a different orientation, use the -orientation option. By default, the tool uses the following naming convention for inserted tap cells: headerfooter__ library_cell_name _R _C number To identify the tap cells inserted in a specific run, use the -prefix option to specify a prefix string. When you use this option, the tool uses the following naming convention: prefix __ library_cell_name _R _C number The tap insertion region (the -bbox option) You specify the tap insertion region by specifying the lower-left and upper-right corners of its bounding box: -bbox {{ llx lly } { urx ury }} The mesh window (the -mesh_window option) You specify the size of the mesh window by specifying an integer value for the pitch in the x- and y-directions. -mesh_window { x_pitch y_pitch The mesh window is aligned with the lower-left corner of the tap insertion region. When inserting the tap mesh, the command does not honor the standard cell rows or sites. It places a tap cell in the lower-left corner of each mesh window. If that location is blocked, the command uses the closest available location, which is measured as the Manhattan distance to the lower-left corner of the mesh window. If there is no available location, the command issues a warning and does not place a tap cell in that mesh window. After insertion, the command fixes the placement of the inserted tap cells."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Highlighting Violations From the Error Browser Onto an ICV Heat"}, {"role": "assistant", "content": "You can select or unselect violation types from the heat map, as shown in figure and Violation Type Violation Type in ICV Heat Map To control the opacity of the heat map squares, adjust the Alpha percentage value. Set this percentage to 100% to create a completely filled block. The lower you set the percentage, the more transparent the block becomes, as shown in and Completely Filled Block You can adjust the range of colored squares by modifying the Bins value, as shown in and Bins Value Set to 5 Bins Value Set to 8 You can select or unselect layers from the heat map, as shown in and Selecting Layers Selecting Layers in the ICV Heatmap You can modify the squares of the heat map by right-clicking the colored squares and selecting Set Style. See and Set Style Select Style"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Detail Routing"}, {"role": "assistant", "content": "Before you run track assignment, Define the common routing application options For information about the common routing application options, see the route.common_options man page. Define the global routing application options For information about the track assignment application options, see the route.track_options man page. Complete global routing To perform standalone track assignment, run the route_track command. The main task of track assignment is to assign routing tracks for each global route. During track assignment, Zroute performs the following tasks: Assigns tracks in horizontal partitions. Assigns tracks in vertical partitions. Reroutes overlapping wires. After track assignment finishes, all nets are routed but not very carefully. There are many violations, particularly where the routing connects to pins. Detail routing works to correct those violations. Note: Because track assignment replaces the global routes with actual metal shapes, the block no longer contains global routes after track assignment completes. By default, the route_track command is not timing-driven or crosstalk-driven. To enable timing-driven mode, set the route.track.timing_driven application option. To enable crosstalk-driven mode, set the route.track.crosstalk_driven and time.si_enable_analysis application options to true At the end of track assignment, Zroute reports a summary of the wire length and via count. Example 20 shows a track assignment report. Example 20 Track Assignment Report Wire length and via report: Number of M1 wires: 215327 : 0 Number of M2 wires: 1124740 VIA12SQ_C: 1067462... Total number of wires: 2508734 vias: 2769482 Total M1 wire length: 924480.9 Total M2 wire length: 4147032.0... Total wire length: 21281278.0 Longest M1 wire length: 1541.7 Longest M2 wire length: 926.0..."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Generating Interclock Delay Balancing Constraints Automatically"}, {"role": "assistant", "content": "To define interclock delay balancing constraints, use the create_clock_balance_group command. At a minimum, you must specify a name for the clock balance group and the clocks in the group. To specify a name for the clock balance group, use the -name option. To specify the clock trees in the group, use the -objects option with the get_clocks command. By default, the clock balance group is defined for the clocks in the current mode. To define a clock balance group for the clocks of a specific mode, use the -objects option with the get_clocks -mode command. For example, to define a clock balance group named group1 that contains the clocks named clk1 and clk2 in the current mode, use the following command: fc_shell> create_clock_balance_group -name group1 \\ -objects [get_clocks {clk1 clk2}] To define a clock balance group named group2 that contains all the clocks in the mode named m2, use the following command: fc_shell> create_clock_balance_group -name group2 \\ -objects [get_clocks -mode m2] By default, the tool has a goal of zero delay offset between clocks. All clocks are balanced with the same insertion delay which usually is the longest insertion delay among the clocks. To specify a delay offset between clocks in the group, use the -offset_latencies option. By default, the delay offset applies to the current corner. To apply the delay offset to a specific corner, use the -corner option. For example, assume the design has three clocks named clk1, clk2, and clk3. If you want the insertion delay of clk1 and clk2 to be the same and the insertion delay of clk3 to be 100 less than that of clk1 and clk2, use the following command: fc_shell> create_clock_balance_group -name group3 \\ -objects [get_clocks {clk1 clk2 clk3}] \\ -offset_latencies {0 0 -100} Reporting Clock Balance Groups To report clock balance groups, use the report_clock_balance_groups command. The report lists the clock balance groups for all modes in all active scenarios. Removing Clock Balance Groups To remove clock balance groups, use the remove_clock_balance_groups command. You can either remove specific clock balance groups by specifying the clock balance groups or all clock balance groups by using the -all option. If you specify the clock balance groups to remove, they are removed from the current mode. However, if a specified group does not exist in the current mode, but does exist in another mode, it is removed from that mode. If you use the -all option, the clock balance groups are removed from all modes. For example, to remove a previously defined clock balance group named group1 from the current mode, use the following command: fc_shell> remove_clock_balance_groups group1 To remove all clock balance groups from all modes, use the following command: fc_shell> remove_clock_balance_groups -all"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying the Tapering Method"}, {"role": "assistant", "content": "Pin tapering is the method used to connect wires with nondefault routing rules to pins. Zroute supports pin tapering for both hard and soft nondefault routing rules; the tapering implementation is the same for both types of nondefault routing rules. Note: By default, if a net has both a nondefault routing rule defined by the create_routing_rule command and voltage-based spacing rules defined in the technology file, Zroute performs pin tapering on that net based on the nondefault routing rule. To disable pin tapering on these nets, set the route.detail.enable_ndr_tapering_on_voltage_rule application option to false You can specify the method used for pin tapering and control the tapering width, as described in the following topics: Specifying the Tapering Method Controlling the Tapering Width"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Optimizing Datapaths"}, {"role": "assistant", "content": "All the extracted datapath elements and the synthetic operators are implemented by the DesignWare datapath generator in Fusion Compiler. The DesignWare datapath generator uses the smart generation technology to perform the following tasks: Implement datapath blocks using context-driven optimizations Revisit high-level optimization decisions for a given timing context Consider logic library characteristics Use these commands and application option for datapath implementation: set_datapath_architecture_options This command controls the strategies used to generate the datapath cells for arithmetic and shift operators. The following example specifies to use Booth-encoded architectures to generate multiplexers: fc_shell> set_datapath_architecture_options -booth_encoding true set_implementation This command specifies the implementation to use for dividers and synthetic library cell instances with a specified name. The following example specifies to use the cla3 implementation for the instantiated DesignWare cell U1. fc_shell> set_implementation cla3 U1 set_synlib_dont_use This command prevents using specific implementation. The following example specifies not to use the rpl implementation. fc_shell> set_synlib_dont_use \\ {dw_foundation/DW_div/cla standard/DW_div/rpl} compile.datapath.ungroup By default, all DesignWare cells and datapath blocks are ungrouped during timing optimization. To disable the ungrouping, set the compile.datapath.ungroup application option to false, changing from its default of true. For example, fc_shell> set_app_options \\ -name compile.datapath.ungroup -value false"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Guided Power Grid Augmentation"}, {"role": "assistant", "content": "Timing-driven power grid augmentation inserts PG augmentation shapes in the specified regions of the block, except around timing-critical nets. By default, the tool does not perform timing-driven PG augmentation. To perform timing-driven power grid augmentation, 1. Ensure that the block is fully routed with very few or no DRC violations. 2. Run voltage drop analysis using RedHawk Fusion, as described in Performing Voltage Drop Analysis The IC Validator tool uses the results of this voltage drop analysis to drive the power grid augmentation. 3. Set up the IC Validator environment as described in Setting Up the IC Validator Environment 4. (Optional) Enable distributed processing by using the set_host_options command, as described in Enabling IC Validator Multicore Processing 5. Set the application options for performing power grid augmentation, as described in Setting Options for Power Grid Augmentation At a minimum, you must define the power and ground nets on which to perform PG augmentation. To specify the power net, set the signoff.create_pg_augmentation.power_net_name application option. To specify the ground net, set the signoff.create_pg_augmentation.ground_net_name application option. If your design contains more than one power net, you must perform PG augmentation once for each power net. 6. Save the block to disk. When you run the signoff_create_pg_augmentation command, the IC Validator tool uses the on-disk information for the block, not the information in memory. To ensure accurate information, use the save_block command to save the current state of the block before running the signoff_create_pg_augmentation command. 7. Perform timing-driven power grid augmentation by using the signoff_create_pg_augmentation command with one or both of the following options: -nets This option explicitly specifies the critical nets. -timing_preserve_setup_slack_threshold This option enables the tool to automatically determine the critical nets based on a setup slack threshold. The unit for the slack threshold setting is the library time unit. You must also specify the technology node for which to perform the augmentation by using the -node option. If you must perform incremental PG augmentation because your design contains more than one power net, use the -mode add command on subsequent runs to append the PG augmentation shapes to the existing shapes. 8. Run voltage drop analysis using RedHawk Fusion, as described in Performing Voltage Drop Analysis This second voltage drop analysis run measures the voltage drop after power grid augmentation. During timing-driven PG augmentation, the signoff_create_pg_augmentation command 1. Performs timing analysis, including multicorner-multimode analysis, to minimize timing impact 2. Identifies timing-critical nets based on the options you specify 3. Removes existing PG augmentation shapes By default, the command removes the PG augmentation shapes from the entire block. To keep the existing PG augmentation shapes, use the -mode add option. 4. Inserts PG augmentation shapes for the specified regions, except in the areas around the critical nets 5. Saves the updated block to disk 6. Generates a summary report See Also Standard Power Grid Augmentation Guided Power Grid Augmentation Removing PG Augmentation Shapes"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Associating Checkpoints and Checkpoint Behaviors"}, {"role": "assistant", "content": "You can define two types of checkpoint behaviors: reports and actions. Define a checkpoint report to generate one or more reports supported by the tool or custom reports you create yourself. Define a checkpoint action to execute any kind of flow change before, after, or in place of the code block enwrapped by a checkpoint. For example, you might set an application option to a specific value before a particular checkpoint. Define these behaviors in your checkpoint.config.tcl file, which is automatically sourced by the checkpoint system. Defining Checkpoint Reports To define a checkpoint report, use the create_checkpoint_report command in your checkpoint.config.tcl file. Specify a unique name for the report and define the Tcl commands to generate the report. The following example defines a checkpoint report named timing, which writes the output of the report_qor and report_timing commands to disk: create_checkpoint_report timing { set name [get_current_checkpoint -name] set pos [get_current_checkpoint -position] report_qor -nosplit >./checkpoint/$name.$pos.qor.rpt report_qor -summary -nosplit >>./checkpoint/$name.$pos.qor.rpt report_timing -nosplit -max_paths 10 \\ >./checkpoint/$name.$pos.path.rpt Notice the use of the get_current_checkpoint command with the -name and -position options to give the generated reports a meaningful name. When these reports are generated, their names reflect the checkpoint that triggered them get_current_checkpoint -name ), as well as whether they were generated before or after the checkpoint ( get_current_checkpoint -position ). For example, if this checkpoint report is executed after a checkpoint named checkpoint_A, the generated reports are saved to the checkpoint directory, and the name of the QoR report is checkpoint_A.after.qor.rpt. The next example defines a checkpoint report named app_options, which writes all your non-default application options to disk: create_checkpoint_report app_options { set name [get_current_checkpoint -name] set pos [get_current_checkpoint -position] report_app_options -non_default \\ >./checkpoint/$name.$pos.app_options.rpt Defining Checkpoint Actions To define a checkpoint action, use the create_checkpoint_action command in your checkpoint.config.tcl file. Specify a unique name for the action and define the Tcl commands that constitute the action. The following example defines a checkpoint action named gropto, which enables global- route based buffering: create_checkpoint_action gropto { set_app_options -name place_opt.initial_drc.global_route_based \\ -value true The next example defines a checkpoint action named placer_high_effort_cong, which runs high-effort congestion reduction: create_checkpoint_action placer_high_effort_cong { set placer_command [get_current_checkpoint -script] set cong_option \"-congestion_effort high\" eval $placer_command $cong_option Notice the use of the get_current_checkpoint -script command and option, which retrieves the command originally enwrapped by the checkpoint and sets its congestion effort to high ( -congestion_effort high ). The -script option is typically used to define actions that replace the contents of a command. In this example, the action modifies the -congestion_effort option of the command that is enwrapped by the checkpoint associated with this action."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Using Custom Router in the Fusion Compiler"}, {"role": "assistant", "content": "Custom Router is a shape-based router that supports gridded or gridless routing for custom digital, mixed signal, and analog routing needs. In the Fusion Compiler environment, you can use Custom Router to create interconnects (or routes) for critical signals between blocks and continue with the Fusion Compiler tool to complete the physical implementation. You can also preroute critical signals or clock nets by using a set of custom routing constraints. In the Fusion Compiler environment, Custom Router provides the following features: Prerouting in the batch mode Tcl-based routing constraint management Automatic routing with custom routing constraints Hybrid flow for prerouting Double Data Rate (DDR) net routing flow Custom Router is fully integrated with the Fusion Compiler tool, and supports advanced design rules for 20 nm and below technologies. To learn about using Custom Router in the Fusion Compiler environment, see the following topics: Using Custom Router in the Fusion Compiler Tool Before Using Custom Router Defining Routing Constraints Managing Constraint Groups Using Custom Routing Application Options Routing With the Custom Router Shielding the Nets Checking the Routing Results Using a Hybrid Routing Flow Using a DDR Routing Flow These topics describe how to use Custom Router to create custom routes in the Fusion Compiler environment. For detailed information about Custom Router, see the Custom Compiler Custom Router User Guide"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Via Ladders"}, {"role": "assistant", "content": "To define instance-specific via ladder constraints, use the set_via_ladder_constraints command. You must specify the instance pins and the via ladder templates that can be used for those pins. For example, to enable the use of the VL1, VL2, and VL3 via ladder templates for the u1/i1 and u2/i2 pins, use the following command: fc_shell> set_via_ladder_constraints -pins {u1/i1 u2/i2} \\ {VL1 VL2 VL3} To report the via ladder constraints, use the report_via_ladder_constraints command. To remove via ladder constraints, use the remove_via_ladder_constraints command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Selecting and Multiplexing Logic"}, {"role": "assistant", "content": "The Fusion Compiler tool can map combinational logic representing multiplexers in the HDL code directly to a single multiplexer (MUX) or a tree of multiplexer cells from the target logic library. Multiplexers are commonly modeled with if and case statements. To implement the mutliplexer logic, the HDL Compiler uses SELECT_OP cells, which the Fusion Compiler tool map to combinational logic or multiplexers in the logic library. User-specified Tool evaluated Implemented using MUX gates Implemented using MUX or non MUX gates based on area costing analyze elaborate Infers Select_OP cells compile_fusion"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Validating DEF Files"}, {"role": "assistant", "content": "If the site names used in the DEF file do not match the site names defined in the technology file, use the -convert_sites option to specify the site name mapping. For example, if the DEF file uses a site named CORE, but the technology file defines only a site named unit, use the following command to convert the site names when reading the DEF file: fc_shell> read_def -convert_sites { {CORE unit} } block.def"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Querying Metal Fill"}, {"role": "assistant", "content": "The signoff_create_metal_fill command stores the output files in the run directory specified by the signoff.create_metal_fill.run_dir application option (or the signoff_fill_run directory if you do not use this option). For each fill run, the command creates a subdirectory named icv_run_# that contains the files generated for that run. When you perform metal fill insertion, the tool writes the following files to the output directory: block.LAYOUT_ERRORS, which contains details about the detected errors block.RESULTS, which contains a summary of the run results signoff_create_metal_fill.log, which contains a summary of the run environment icv_config_out, which contains the paths to the top-level block and the cell libraries layer.map, which contains the generated layer mapping file metal_fill_params.rh, which contains the metal fill parameters and options that you specified metal_fill_compress_params.rh, which contains the storage commands and indicates whether the compression mode was flat (NONE) or hierarchical (AUTO)./run_details directory, which contains all the data generated by the IC Validator tool for the metal fill insertion run"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Using Hierarchical Relative Placement for Straddling"}, {"role": "assistant", "content": "To create a hierarchical relative placement group by adding a group to another group, use the -rp_group option with the add_to_rp_group command. Specify the column and row position within the relative placement group by using the -column and -row options. The group you specify with the -rp_group option must be in the same design as the hierarchical group in which you are including it. When you include a relative placement group in a hierarchical group, it is as if the included group is directly embedded within its parent group. An included group can be used only in a group of the same design and only one time. However, a group that contains an included group can be further included in another group in the same design or can be instantiated in a group of a different design. The script in Example 43 creates a hierarchical group (rp4) that contains three included groups (rp1, rp2, and rp3). Groups rp1, rp2, rp3, and rp4 are all in the design top. The contents of groups rp1, rp2, and rp3 are treated as leaf cells when they are included in group rp4. You can further include group rp4 in another group in the design top, or you can instantiate group rp4 in a group of a different design. The resulting hierarchical relative placement group is shown in Example 43 Including Groups in a Hierarchical Group create_rp_group -name rp1 -columns 2 -rows 1 add_to_rp_group rp1 -cells U1 -column 0 -row 0 add_to_rp_group rp1 -cells U4 -column 1 -row 0 create_rp_group -name rp2 -columns 2 -rows 1 add_to_rp_group rp2 -cells U2 -column 0 -row 0 add_to_rp_group rp2 -cells U5 -column 1 -row 0 create_rp_group -name rp3 -columns 2 -rows 1 add_to_rp_group rp3 -cells U3 -column 0 -row 0 add_to_rp_group rp3 -cells U6 -column 1 -row 0 create_rp_group -name rp4 -columns 1 -rows 3 add_to_rp_group rp4 -rp_group rp1 -column 0 -row 0 add_to_rp_group rp4 -rp_group rp2 -column 0 -row 1 add_to_rp_group rp4 -rp_group rp3 -column 0 -row 2 Including Groups in a Hierarchical Group rp3 rp2 rp1 U3 U2 U4 U5 U6 U1 rp4 rp1 U4 U1 U3 U6 rp2 U2 U5 rp3 col 0 col 1 col 0 col 1 col 0 col 1 row 0 row 0 row 0 row 2 row 0 row 1 col 0"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Creating and Specifying Rail Scenarios for Rail Analysis"}, {"role": "assistant", "content": "By default, RedHawk or RedHawk-SC Fusion analyzes only the current design scenario for a multicorner-multimode design. To specify a different design scenario for rail analysis, use the rail.scenario_name application option. The tool honors the specified design scenario for the IR-driven features in power integrity flow, such as IR-driven placement, IR- driven concurrent clock and data optimization, and IR-driven optimization.\u200b Here is a script example: open_lib open_block set_app_option -name rail.technology -value 7 set_app_options -name rail.tech_file -value./Apache.tech set_app_options -name rail.lib_files -value {\\ A.lib \\ B.lib } set_app_options -name rail.switch_model_files -value {./switch_cells.txt } source./test_taps.tcl current_scenario func_max set_app_options -name rail.scenario_name -value func_typ analyze_rail -voltage_drop"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Making Changes to a Block After Creating an Abstract"}, {"role": "assistant", "content": "In the Fusion Compiler tool, the create_abstract command includes netlist objects such as the cells, nets, and pins in the abstract view at both the top-level and block-level. This command reports the reasons for the inclusion of netlist objects. To report the reasons for including specific netlist objects in the abstract view, you can use the report_abstract_inclusion_reason command for objects across all hierarchies in the abstract. For each reason reported, a reason code is displayed. These reason codes correspond to the valid reasons for inclusion in the abstract. There can be multiple reasons for the same netlist object. Note: The report_abstract_inclusion_reason command does not report reasons for the hierarchical cells or pins on hierarchical cells. You can perform reason reporting from the top-level design, where the abstract is instantiated, without having the abstract as the current block. The following example reports the reasons for abstract inclusion for the pins in abstract view: fc_shell> report_abstract_inclusion_reason [get_pins -of_object [get_cells -filter \"is_hierarchical==false\" -hierarchical *]] Legend mv - MV Logic comp - Compact interface logic cell - Cell inclusion Pin name Reason(s) for inclusion AINV_P_260/I comp, cell AINV_P_260/VDD cell AINV_P_260/VSS cell AINV_P_260/ZN comp, cell AINV_P_262/I comp, cell AINV_P_262/VDD cell AINV_P_262/VSS cell AINV_P_262/ZN comp, cell AINV_P_263/I mv, comp, cell A legend is displayed at the beginning of the report for the queried objects, specifying the detailed reason for each reason code."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Querying Group Repeater"}, {"role": "assistant", "content": "To remove a group of repeaters, use the remove_eco_repeater command. The nets are restored to their original names and routes shapes."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Clock Gating Transformations"}, {"role": "assistant", "content": "By merging clock gates, the tool attempts to minimize the number of clock gates while maximizing clock-gating coverage. The tool looks for clock-gating cells that share a common clock and enable signal. This feature is on by default. The fanout of clock-gating cells in different hierarchies can be moved to a clock-gating cell in a common ancestor if there is no restriction preventing port punching. Note that the the tool also checks clock-gating style and multivoltage constraints. Clock-gating cells with the dont_touch or size_only constraints are not optimized. To disable this feature, use the set_clock_gate_transformations command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Performing IR-Drop-Aware Placement During the clock_opt"}, {"role": "assistant", "content": "If you enable concurrent clock and data optimization for the clock_opt command, the tool performs clock power recovery on clock cells and registers during the final_opt stage. If you do not enable concurrent clock and data optimization, you can enable clock power recovery by using the following application option setting: fc_shell> set_app_options \\ -name clock_opt.flow.enable_clock_power_recovery \\ -value power Before you perform power recovery using this technique, you must 1. Enable scenarios for dynamic, leakage, or total power optimization by using the -dynamic_power and - leakage_power options of the set_scenario_status command 2. (Optional) Provide a switching activity by using the read_saif command If you do not provide switching activity, the tool uses default switching activity for dynamic power recovery. Instead of power recovery, you can enable area recovery on the clock cells and registers during the final_opt stage clock_opt command by using the following application option setting: fc_shell> set_app_options \\ -name clock_opt.flow.enable_clock_power_recovery \\ -value area"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Enabling Local Skew Optimization"}, {"role": "assistant", "content": "By default, clock tree synthesis tries to achieve the best skew and latency for all clocks. However, this can lead to area, power, and runtime overhead for low frequency clocks, which have relaxed skew and latency targets. To specify a skew target, use the -target_skew option with the set_clock_tree_options command. To specify a latency target, use the -target_latency option with the set_clock_tree_options command. By default, when you define skew and latency targets, they apply to all clocks in all corners. To define targets for specific clocks, use the -clocks option. To define targets for specific corners, use the -corners option. To report the user-defined skew and latency targets, use the report_clock_tree_options command. To remove user-defined skew or latency targets, use the remove_clock_tree_options command. To remove all skew and latency targets, use the -all option; otherwise, use the appropriate -target_skew -target_latency -clocks, and -corners options to remove the specific targets."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Exploring the Detailed Comparison Data"}, {"role": "assistant", "content": "You can sort and filter the run data to reveal patterns in the results and determine the parameters you want to explore further. To sort and filter the data, see the following topics: Sorting the Data Filtering Metrics Filtering Runs Example Analysis See Also Exploring the Detailed Comparison Data Sorting the Data Click any column header to sort the data using that metric. The first click performs an ascending sort, while the second click performs a descending sort. For example, to show the worst TNS numbers at the top of the table and the best TNS numbers at the bottom, click the TNS column header: Click the TNS column header again to show the best TNS numbers at the top and the worst at the bottom: Filtering Metrics To control which metrics are displayed in the table, click the Metrics button and select or deselect the metrics from the Metrics dialog box accordingly. For example, to show only the setup timing, netlist area, and cell counts, select the metrics as shown in Metrics Dialog Box Filtering Runs To control which runs are displayed in the table, click the Runs button and select or deselect the exploration runs accordingly from the Visible Runs (Summary) column. For example, to display only the first four runs in a table, select the runs as shown in Choose Baseline and Visible Runs Dialog Box Example Analysis The following example demonstrates how you might sort and filter your data to narrow down the runs you would like to explore further. Suppose you open the comparison report shown in and set the util60_aspect1%1_layerM9 run as the base run. Comparison Report You could look at your TNS numbers first and sort the data from best TNS to worst TNS, as shown in the following figure: Notice that the best TNS runs have the M9 top layer, and the worst have the M7 top layer. This suggests that restricting the metal layers significantly impacts timing. You could then restrict your analysis to your M9 runs by turning off the visibility of your M7 runs, as shown in the following figure: Now that you have your best TNS runs, you could compare their congestion by sorting the GRCOverflow column to show the worst overflow at the top, as shown in the following figure: Notice that your higher-utilization runs have more congestion than your lower-utilization runs. You could restrict your analysis to your lower-utilization runs by turning off the visibility of your higher-utilization runs as shown in, leaving you with a manageable subset of exploration runs that better meet your timing and congestion goals. Displaying Lower-Utilization Runs"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Abutting Standard Cells With Specific Filler Cells"}, {"role": "assistant", "content": "Some mask design rules are not handled during filler cell insertion because they have a low probability of occurrence and they require extensive computation time if handled during insertion. After filler cell insertion, use the replace_fillers_by_rules command to fix these design rule violations. You must specify the rule to fix by using the -replacement_rule option. Table 41 lists the design rules supported by this command and the keywords used to specify these rules. Table 41 Design Rules Supported by the replace_fillers_by_rules Command Design rule Description -replacement_rule keyword end_orientation half_row_adjacency Table 41 Design Rules Supported by the replace_fillers_by_rules Command (Continued) Design rule Description -replacement_rule keyword illegal_abutment od_horiztonal_distance horizontal_edges_distance small_filler_stacking max_vertical_constraint od_tap_distance random End Orientation Rule The end orientation rule searches for a continuous horizontal sequence of cells and modifies the orientation of the leftmost or rightmost filler cells if they are in the specified list of target filler cells. To select this rule, use the -replacement_rule end_orientation option with the replace_fillers_by_rules command. When you select this rule, you must specify The target filler cells To specify the target filler cells, use the -target_fillers option. The orientation modification To change the orientation for the leftmost filler cells, use the -left_end option. To change the orientation for the rightmost filler cells, use the -right_end option. To change the orientation for both the leftmost and rightmost filler cells, use both options. The valid values for these options are inverse, which flips the cell from its existing orientation R0_or_MX, which changes an MY orientation to R0 or an R180 orientation to MX MY_or_R180, which changes an R0 orientation to MY or an MX orientation to R180 To report the cells whose orientation would be changed, without actually changing the orientations, use the -check_only option. This option is valid only for the end orientation rule. Half Row Adjacency Rule The half row adjacency rule searches for half-height filler cells and replaces them based on the types of their neighboring standard cells. The standard cells are classified as one of the following types: Inbound The top or bottom boundary of an inbound standard cell is at the half-height location of the cell rows. When a half-height filler cell abuts an inbound cell, the abutting side of the half-height filler cell must have inbound-cell interaction polygons (ICIP). Regular The top and bottom boundaries of a regular standard cell are at the full-height location of the cell rows. When a half-height filler cell abuts a regular cell, the abutting side of the half-height filler cell must not have inbound-cell interaction polygons (ICIP). The replacement filler cells have the same height, width, and threshold voltage as the original filler cells. The cell libraries include both p-type and n-type replacement filler cells with inbound-cell interaction polygons (ICIP). For p-type half-height filler cells, the inbound- cell interaction polygons (ICIP) are at the bottom corners. For n-type half-height filler cells, the inbound-cell interaction polygons (ICIP) are at the top corners. shows the replacement of the half-height filler cells using the half row adjacency rule. Half-Height Filler Cell Replacement With Half Row Adjacency Rule Regular height Inbound height Inbound height FILL2_P FILL4_N Regular height Inbound height Inbound height FILL2_PR FILL4_NR Inbound-cell interaction polygons To select this rule, use the -replacement_rule half_row_adjacency option with the replace_fillers_by_rules command. The following table lists the options used to specify the replacement half-height filler cells. Each list can contain only one cell of each size. Table 42 Half-Height Replacement Filler Cells Abutting inbound standard cells Option to specify replacement filler cells -p_none -n_none -p_left -n_left -p_right -n_right -p_left_right -n_left_right -p_left_center_right -n_left_center_right Illegal Abutment Rule The illegal abutment rule restricts the filler cells that can abut certain other filler cells. To select this rule, use the -replacement_rule illegal_abutment option with the replace_fillers_by_rules command. When you select this rule, you must specify The filler cells considered for the check and their replacements The filler cells considered for the check are called target cells. To specify the target filler cells and their replacements, use the following syntax with the -replace_abutment option: { { target_cell refill_cell }... } To ignore filler cells that have a physical_status attribute of fixed or locked, use the -skip_fixed_cells option with the replace_fillers_by_rules command. The filler cells that cannot abut the target filler cells These filler cells are called illegal cells. To specify the illegal cells, use the -illegal_abutment option. Note that the target filler cells specified in the -replace_abutment option are also considered illegal cells. For example, the following command fixes illegal abutment violations where the FILL1a and FILL1b filler cells cannot abut the FILLx and FILLy cells: fc_shell> replace_fillers_by_rules -replacement_rule illegal_abutment \\ -replace_abutment { {FILL1a CFILL1a} {FILL1b CFILL1b} } \\ -illegal_abutment {FILLx FILLy} shows the original row, which violates this rule, and the resulting row, which uses the replacement filler cells to fix the violations. The target filler cells are shown in red, while the replacement filler cells are shown in green. Fixing an Illegal Abutment Violation Maximum Horizontal Edge Length Rule The maximum horizontal edge length rule restricts the horizontal length of a sequence of abutted objects on a specific layer. To select this rule, use the -replacement_rule horizontal_edges_distance option with the replace_fillers_by_rules command. When you select this rule, you must specify The maximum horizontal length To specify the maximum length, use the -max_constraint_length option. The layer to check To specify the layer, use the -layer option. The cells considered for the check and the filler cells that can be used to replace the violating filler cells The filler cells considered for the check are called constrained cells. The filler cells considered to replace violating cells are called unconstrained cells To specify multiple constrained cell groups and their replacement cells, use the following syntax with the -refill_table option: { {{ refill_cell constrained_cells }}... } You can use this syntax to fix violations for threshold-voltage-based filler cells. To specify a single constrained cell group, use the -constraint_fillers option. To specify the replacement cells, use the -non_constraint_fillers option. Note: If you use both methods, the command uses only the information specified in the -refill_table option. For example, the following command identifies and fixes maximum horizontal edge length violations where the horizontal length on the M2 layer exceeds 30 um: fc_shell> replace_fillers_by_rules \\ -replacement_rule horizontal_edges_distance \\ -max_constraint_length 30 -layer M2 \\ -refill_table { {{VT1_FILL1} {VT1_DECAP4 VT1_DECAP2}} {{VT2_FILL1} {VT2_DECAP4 VT2_DECAP2}} } Maximum Horizontal Length Rule The maximum horizontal length rule restricts the horizontal length of a sequence of abutted filler cells. To select this rule, use the -replacement_rule od_horiztonal_distance option with the replace_fillers_by_rules command. When you select this rule, you must specify The maximum horizontal length To specify the maximum length, use the -max_constraint_length option. The cells considered for the check and the filler cells that can be used to replace the violating filler cells The filler cells considered for the check are called constrained cells. The filler cells considered to replace violating cells are called unconstrained cells To specify multiple constrained cell groups and their replacement cells, use the following syntax with the -refill_table option: { {{ refill_cell constrained_cells }}... } You can use this syntax to fix violations for threshold-voltage-based filler cells. To specify a single constrained cell group, use the -constraint_fillers option. To specify the replacement cells, use the -non_constraint_fillers option. Note: If you use both methods, the command uses only the information specified in the -refill_table option. For example, the following command identifies and fixes maximum horizontal length violations where the horizontal length exceeds 70 um: fc_shell> replace_fillers_by_rules \\ -replacement_rule od_horiztonal_distance -max_constraint_length 70 \\ -refill_table { {{VT1_FILL1} {VT1_DECAP4 VT1_DECAP2}} {{VT2_FILL1} {VT2_DECAP4 VT2_DECAP"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Synthesizing, Optimizing, and Routing Clock Trees With the"}, {"role": "assistant", "content": "To perform standalone clock tree synthesis, use the synthesize_clock_trees command, as shown in the following example: fc_shell> synthesize_clock_trees When you use this command, the tool performs the following tasks: 1. Clock tree synthesis Before clock tree synthesis, the tool performs virtual routing of the clock nets and uses RC estimation to determine the clock net timing. 2. Clock tree optimization Before clock tree optimization, the tool performs global routing on the clock nets and uses RC extraction to determine the clock net timing. During clock tree optimization, the tool performs incremental global routing on clock nets modified during optimization. Note: This command does not detail route the clock trees. By default, this command works on all clocks in all active scenarios that are enabled for setup or hold analysis. You can specify the clocks to be built by using the -clock option. For example, to build only the CLK clock tree, use the following command: fc_shell> synthesize_clock_trees -clocks [get_clocks CLK] After clock tree synthesis, the tool sets the clocks in all modes of all active scenarios as propagated."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Boundary Cell Placement Rules"}, {"role": "assistant", "content": "Boundary cells include both end-cap cells placed on the left, right, top, and bottom boundaries, and inside and outside corner cells. You can specify different library cells for each boundary cell type. To specify the library cells, use the following options with the set_boundary_cell_rules command: -left_boundary_cell and -right_boundary_cell These options specify a single library cell that is used for the end-cap cells for the left and right boundaries, respectively. -top_boundary_cells and -bottom_boundary_cells These options specify a list of library cells that are used for the end-cap cells for the top and bottom boundaries, respectively. The command inserts the cells in the specified order. If the remaining space is smaller than the current cell, the command inserts the next cell in order that fits in the remaining space. For a vertical-row block, rows start at the bottom and end at the top, so the top boundary is along the left side of the block and the bottom boundary is along the right side of the block. For the flipped rows in a double-back block, the top boundary cells are used on the bottom boundaries and the bottom boundary cells are used on the top boundaries. -top_tap_cell and -bottom_tap_cell These options specify a single library cell that is used for the tap cells on the top and bottom boundary rows, respectively. The tool inserts the tap cells to ensure that the end-cap cells inserted on the top and bottom boundary rows comply with the maximum diffusion-to-tap distance limit. -top_left_outside_corner_cell -top_right_outside_corner_cell -bottom_left_outside_corner_cell, and -bottom_right_outside_corner_cell These options specify a single library cell that is used for each outside corner location. -top_left_inside_corner_cells -top_right_inside_corner_cells -bottom_left_inside_corner_cells, and -bottom_right_inside_corner_cells These options specify a list of library cells for each inside corner location. The tool inserts the first corner cell that matches the size of the inside corner. If none matches exactly, it inserts the first cell that can be placed without violating any rules. shows the boundary and corner cell locations for a horizontal-row block with two hard macros or blockages. Note that the cell locations are flipped when the row is flipped. Boundary Cell Locations"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Improving the Banking Ratio"}, {"role": "assistant", "content": "To report a summary of the multibit banking ratio, a list of reasons for not banking or debanking cells, and the number of cells for each reason, use the report_multibit command, as shown in the following example: fc_shell> report_multibit **************************************** Report : report_multibit...... **************************************** Total number of sequential cells: 4020 Number of single-bit flip-flops: 3149 Number of single-bit latches: 29 Number of multi-bit flip-flops: 842 Number of multi-bit latches: 0 Total number of single-bit equivalent cells: 853 (A) Single-bit flip-flops: 3149 (B) Single-bit latches: 29 (C) Multi-bit flip-flops: 5352 (D) Multi-bit latches: 0 Sequential cells banking ratio ((C+D)/(A+B+C+D)): 62.74% Flip-flop cells banking ratio ((C)/(A+C)): 62.96% BitsPerflop: 2.13 Reasons for sequential cells not mapping to multibit during RTL Banking: Explanations: r12: Cell is single bit because its parent multibit cell was debanked due to improve timing (Number of cells: 91) r31: Cell cannot be banked to multibit because it is assigned to use single-bit lib cell (Number of cells: 63) Reasons for multibit sequential cells not debanking to single bit cells during RTL Debanking: Explanations:: r45: Multibit cell cannot be debanked because it is not critical enough (Number of cells: 478) To report all the cells that are ignored during banking and debanking, use the -ignored_cells option with the report_multibit command. To report the compatible multibit and single-bit library cells that can be used for banking and debanking, use the check_multibit_library command. The following example generates a compatible library cell report for RTL banking and debanking: fc_shell> check_multibit_library -stage RTL \\ -banking -debanking **************************************** Report : check_multibit_library Flow : RTL BANKING **************************************** Single bit Lib cell Compatibility Multi bit Lib cell SB_reg1 PIN ORDER MISMATCH MB_reg1 SB_reg2 COMPATIBLE MB_reg2 Singlebit with NO Multibit Equivalents SB_reg3 **************************************** Report : check_multibit_library Flow : RTL DEBANKING **************************************** Multi bit Lib cell Compatibility Single bit Lib cell MB_reg2 COMPATIBLE SB_reg2 MB_reg1 PIN ORDER MISMATCH SB_reg1 Multibit with NO Singlebit Equivalents MB_reg3"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Tracing Minimum Path Resistance Using the Mouse Tool"}, {"role": "assistant", "content": "When the analysis is complete, run the report_rail_result -type minimum_path_resistance command to display a minimum path resistance map, write the results to an output file, or query the attributes on the cell instances or pins. The following example writes the calculated minimum path resistances for the VDD net to an output file called minres.rpt. fc_shell> open_rail_result fc_shell> report_rail_result -type minimum_path_resistance \\ -supply_nets { vdd } minres.rpt fc_shell> sh cat minres.rpt FEED0_14/vbp 518.668 INV61/vdd 158.268 ARCR0_1/vbp 145.582 FEED0_5/vdd 156.228 INV11/vbp 518.669 The output minres.rpt report includes the entire resistance information. fc_shell> sh cat minres.rpt FEED0_14/vbp 518.668 INV61/vdd 158.268 ARCR0_1/vbp 145.582 FEED0_5/vdd 156.228 INV11/vbp 518.669 To write out a detailed minimum resistance path report for a cell instance, run the report_rail_minimum_path command and specify the net and the cell to report. To see the segment-by-segment resistance of that minimum resistance path shown in the GUI, use the -error_cell option of the report_rail_minimum_path command to save the geometries on the path of the minimum path resistance to an error cell. You can then open the error cell in an error browser and check the minimum resistance path from the pin of the cell to the nearest tap and trace each go-through geometries. In the following example, all geometries on the minimum resistance path are traced and written to the error cell named test.err. fc_shell> open_rail_result fc_shell> report_rail_minimum_path -cell U19 -net VDD -error_cell Shown in, each geometry is classified by layer in the error browser. Click a geometry to check for detailed information, such as IR drop, resistance, bounding box, and so on. In the GUI, the traced path is highlighted in yellow in the design layout (see ). Displaying Error Cells in the Error Browser Traced Segment is Highlighted in the Design Layout See Also Displaying Maps in the GUI Writing Analysis and Checking Reports Querying Attributes"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling IR-Drop-Aware Placement"}, {"role": "assistant", "content": "During placement, the tool can use the voltage (IR) drop values of cells to identify areas of high power density and spread the cells with high voltage drop values, which reduces the power density of such areas. To perform IR-drop-aware placement, use the following steps: 1. Place and legalize the block. 2. Set up for RedHawk Fusion and perform static or dynamic voltage drop analysis by using the analyze_rail -voltage_drop command as shown in the following example: fc_shell> source redhawk_setup.tcl fc_shell> analyze_rail -voltage_drop static -nets {VDD VSS} For more information, see Performing Voltage Drop Analysis 3. Enable IR-drop-aware placement by setting the place.coarse.ir_drop_aware application option to true 4. (Optional) Specify additional settings for IR-drop-aware placement, as described in Controlling IR-Drop-Aware Placement 5. Rerun placement. Note: To perform IR-drop-aware placement, you must have Digital-AF and SNPS_INDESIGN_RH_RAIL license keys."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Up the Executables"}, {"role": "assistant", "content": "By default, when you execute the analyze_rail command to perform rail analysis, the RedHawk or RedHawk-SC tool is invoked to perform the specified analysis types with the input data and then load the analysis results back to the rail database when rail analysis is finished. You cannot run any Fusion Compiler commands unless the RedHawk Fusion or RedHawk-SC Fusion process is finished. To perform layout editing tasks while the tool is running in the background, run the analyze_rail -bg command. When analysis is completed, run the open_rail_result -back_annotate command to upload the analysis results to the rail database. By default, RedHawk or RedHawk-SC loads the analysis results back to the rail database when analysis is completed. However, when you specify the -bg option with the analyze_rail command, you need to run the open_rail_result -back_annotate command to reconstruct rail database and create the new RAIL_DATABASE file from the latest analysis results. Note: When back-annotating the analysis results from the previous run after moving nets in the design, the instance-based map reflects the updated instance location change, but the parasitic map does not. When opening rail results, the tool does not detect if the result is generated with or without the -bg option. The command might not work correctly if you run the open_rail_result -back_annotate command to open the rail result that is generated without the -bg option, or vice versa. Reporting and Checking the Status of the Background Process When the RedHawk or RedHawk-SC Fusion process is finished, the tool issues the following message: Info: Running REDHAWK_BINARY in background with log file: LOG_FILE The LOG_FILE file is saved in the PWD directory. To check if the background analyze_rail process is active, use the report_background_jobs command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Creating Skew Groups"}, {"role": "assistant", "content": "To define clock cell spacing rules, use the set_clock_cell_spacing command. At a minimum, you must specify the minimum spacing in the x-direction or the y-direction; typically you would specify the minimum spacing in both directions. To specify the minimum spacing in microns in the X-direction, set the -x_spacing option to a nonzero value This value is usually dependent on the library cell's drive strength and clock frequency. Y-direction, set the -y_spacing option to a nonzero value This value is usually less than half a row height. Note: Using a large spacing value increases the skew because the cells are spaced further away from the intended clusters of sinks. By default, the specified cell spacing requirements apply to all clock cells. To restrict the clock cell spacing rules to specific Library cells, use the -lib_cells option Clocks, use the -clocks option If adjoining clock cells both have cell spacing rules for a given direction, the sum of the spacing values applies. For example, if two adjoining clock cells both have a minimum cell spacing of 5 microns in the x-direction, they are placed at least 10 microns apart in the x-direction. You can relax the adjoining cell spacing rule by setting the cts.placement.cell_spacing_rule_style application option to maximum, in which case the tool uses the larger of the spacing settings between two adjoining cells instead of the sum of the spacing settings. For example, the clock cells in the previous example are placed at least 5 microns apart in the x-direction, instead of 10 microns. The clock cell spacing rules defined by the set_clock_cell_spacing command are honored by the synthesize_clock_trees balance_clock_groups, and clock_opt commands. To report clock cell spacing rules, use the report_clock_cell_spacings command. To remove clock cell spacing rules, use the remove_clock_cell_spacings command. By default, this command removes all clock cell spacing rules. To remove specific clock cell spacing rules, use the -lib_cells option."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Self-Gating Options"}, {"role": "assistant", "content": "To set up the block for self-gating, perform the following steps before you run the compile_fusion command: 1. Enable self-gating by setting the compile.clockgate.self_gating application option to true fc_shell> set_app_options -name compile.clockgate.self_gating \\ -value true 2. Apply switching activity by using the read_saif or set_switching_activity command. 3. (Optional) Specify self-gating settings using the set_self_gating_options command. For more information, see Setting Self-Gating Options 4. (Optional) Override the tool's default behavior of selecting self-gating objects by using the set_self_gating_objects command. For more information, see Controlling the Selection of Self-Gating Objects"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Synthesizing the Top-Level"}, {"role": "assistant", "content": "To synthesize a subblock and generate the block-level information required for top-level synthesis, perform the following steps: 1. Read in a subblock design library generated after the rebuild step as described in Partitioning and Planning the Full Chip Design 2. Apply any block-specific constraints and settings required for synthesizing the block. 3. Apply DFT settings by using commands such as set_dft_signal set_scan_configuration, and so on, and create a test protocol by using the create_test_protocol command. 4. Insert DFT logic and synthesize the block by using the following commands: fc_shell> compile_fusion -to logic_opto fc_shell> insert_dft fc_shell> compile_fusion -from initial_place 5. Create a read-only abstract view, frame view, and a test protocol, and save the block by using the following commands: fc_shell> create_abstract -read_only fc_shell> create_frame fc_shell> write_test_model BLOCK1.ctl fc_shell> save_block -as BLOCK1/PostSynthesis"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Restricting the Target Libraries Used"}, {"role": "assistant", "content": "By default, the Fusion Compiler tool can use all of the library cells available in the cell libraries when performing optimization or clock tree synthesis on the block. To restrict the cell usage, use the set_lib_cell_purpose command after the block is in memory. The command has a block scope and is persistent across tool sessions. The specified settings are restored when the block is reopened. To specify how the tool can or cannot use library cells, use the -include and -exclude options with the set_lib_cell_purpose command. Both of these options accept one or more of the following values: all cts hold optimization none The -include option sets the included_purposes attribute on the specified library cells. The -exclude option sets the excluded_purposes attribute on the specified library cells. Note: If a library cell has a dont_use attribute, it is excluded from all uses, which is the same as if you specified set_lib_cell_purpose -include none for that cell. When the tool performs optimization, which includes setup, hold, and logical DRC fixing, it can use library cells that have an included purpose of optimization hold, or both. When the tool performs clock tree synthesis, it can use library cells that have an included purpose of cts For example, to disallow the use of a set of library cells for all uses, use the following command: fc_shell> set_lib_cell_purpose -include none lib_cells To allow a set of library cells to be used only for clock tree synthesis, use the following commands: fc_shell> set_lib_cell_purpose -include none lib_cells fc_shell> set_lib_cell_purpose -include cts lib_cells To allow a set of library cells to be used for all uses except clock tree synthesis, use the following command: fc_shell> set_lib_cell_purpose -exclude cts lib_cells To use the asterisk wildcard character (*) to query a collection of cells, you must use the get_lib_cells command. However, the set_lib_cell_purpose command excludes synthetic modules by default. Therefore, you should use the set_synlib_dont_use command to exclude synthetic modules. For example, fc_shell> set_lib_cell_purpose \\ -include none [get_lib_cells */*01_*_AB] Warning: The'set_lib_cell_purpose' command cannot be used on synthetic library cell'standard:*OPMOD.DW01_ADD_AB.timing'. (NDMUI-511)"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Analyzing Clock Trees in the GUI"}, {"role": "assistant", "content": "The timing characteristics of the clock network are important in any high-performance design. To obtain detailed information about the clock networks in the current block, use the report_clock_timing comandcomandsreport_clock_timing report_clock_timing command. You must use the -type option to specify the type of report to generate. The report_clock_timing command can generate the following types of reports: Single-clock local skew To generate a single-clock local skew report, use the -type skew option. Interclock skew To generate an interclock skew report, use the -type interclock_skew option. Latency To generate a latency report, use the -type latency option. Transition To generate a transition time report, use the -type transition option."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Transferring to Back End"}, {"role": "assistant", "content": "When performing concurrent clock and data optimization using the compile_fusion command, you can give a higher priority to the WNS optimization of Certain path groups by specifying them by using the ccd.targeted_ccd_path_groups application option, as shown in the following example: fc_shell> set_app_options -name ccd.targeted_ccd_path_groups \\ -value {PG1 PG2} If a path group you specify with this application option is also specified as a path group to skip with the ccd.skip_path_groups application option, the path group is skipped during concurrent clock and data optimization. Certain endpoints by specifying a file containing the endpoints by using the ccd.targeted_ccd_end_points_file application option, as shown in the following example: fc_shell> set_app_options \\ -name ccd.targeted_ccd_end_points_file \\ -value endpoint_targets.tcl If you specify both path groups and endpoints, the tool optimizes only the specified endpoints that are in the specified path groups. The worst 300 timing paths by setting the ccd.enable_top_wns_optimization application option to true"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Prerequisites for Routing"}, {"role": "assistant", "content": "shows the basic Zroute flow, which includes clock routing, signal routing, DFM optimizations, and route verification. Basic Zroute Flow"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Running the signoff_fix_drc Command"}, {"role": "assistant", "content": "Before you run the signoff_fix_drc command, configure the run by setting the application options shown in Table 44. To set the application options, use the set_app_options command. To see the current settings, use the report_app_options command. Table 44 Application Options for Signoff DRC Fixing Application option Default Description signoff.fix_drc. advanced_guidance_for_rules all signoff_fix_drc all off signoff.fix_drc.check_drc local local global signoff.fix_drc. custom_guidance dpt Table 44 Application Options for Signoff DRC Fixing (Continued) Application option Default Description signoff.fix_drc. fix_detail_route_drc global signoff_fix_drc global local signoff.fix_drc. init_drc_error_db signoff_fix_drc signoff_check_drc signoff.fix_drc. last_run_full_chip false false true signoff.fix_drc. max_detail_route_iterations signoff.fix_drc. max_errors_per_rule signoff.fix_drc.run_dir signoff_fix_drc signoff.fix_drc. target_clock_nets false false true signoff.fix_drc. user_defined_options"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Clock Gates in an RTL Design"}, {"role": "assistant", "content": "In a multivoltage design, the different hierarchies of the design might have different operating conditions and use different target library subsets. When inserting clock-gating cells in a multivoltage design, the tool chooses the appropriate library cells based on the specified clock-gating style as well as the operating conditions that match the operating conditions of the hierarchical cell of the design. If you do not specify a clock-gating style, the tool uses a default style where the test point is before and the observation output is false If the tool does not find a library cell that suits the clock-gating style and the operating conditions, the tool issues a warning message and does not insert a clock-gating cell. To check whether there are integrated clock-gate cells available for clock-gate insertion, use the check_clock_gate_library_cell_availability command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Enabling Advanced PG Net Checks"}, {"role": "assistant", "content": "For advanced technology nodes, to improve the routability of areas with high pin densities by redistributing the cells, enable pin optimization during legalization by setting the place.legalize.optimize_pin_access_using_cell_spacing application option to true"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Ideal Voltage Sources as Taps"}, {"role": "assistant", "content": "RedHawk-SC Fusion provides application options and commands to read in user- customized python script files. The tool generates all design collaterals (including DEF, LEF, SPEF, TWF and PLOC) from the design library and adds them to the user-customized python script to run voltage drop analysis in a single iteration of analyze_rail. The user-customized python script file is supported in rail analysis with multiple rail scenarios, as well as other IR-driven features, such as IR-driven placement or IR-driven concurrent clock and data optimization. To use a customized python script file for RedHawk-SC Fusion rail analysis, 1. Set the type of script file to python fc_shell> set_app_options -name rail.generate_file_type -value python 2. Set the rail.generate_file_variables application option to specify the variables for generating the input files (including DEF, LEF, SPEF, TWF and PLOC files) to add to the user-customized python script file. You do not need to set this application option if the customized python script file uses the same values as in RedHawk-SC Fusion. DEF File LEF File SPEF File TWF File PLOC File DEF LEF SPEF TWF PLOC def_files lef_files spef_files tw_files ploc For example, if you specify a test_def_file for the DEF variable to match with the DEF file specified in the customized python script file, set the following: fc_shell> set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files} 3. Create and specify rail scenarios for generating the necessary input files to add to the customized python script. Run the create_rail_scenario command to create a rail scenario and associate it with a design scenario in the current design. You can create multiple rail scenarios and associate them with the same scenario in the current design. Then run the set_rail_scenario -generate_file {LEF | TWF | DEF | SPEF | PLOC} command to specify the rail scenario and the type of input files to generate from the design library. Note: When running rail analysis using multicorner-multimode technology, you must create rail scenarios using the create_rail_scenario command before the set_rail_scenario command. The following example creates the T_low and T_high rail scenarios and generates input files for them: fc_shell> create_rail_scenario -name T_low -scenario func_cbest fc_shell> set_rail_scenario -name T_low -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py fc_shell> create_rail_scenario -name T_high -scenario func_cbest fc_shell> set_rail_scenario -name T_high -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py You can then use the customized.py file for multi-rail-scenario rail analysis or other IR- driven features, such as IR-driven placement or IR-driven concurrent clock and data optimization. Examples The following example uses a customized python script for multi-rail-scenario rail analysis on a grid system. #Required. Specify the below options to enable multi-rail-scenario rail analysis. set_app_options -list { rail.enable_new_rail_scenario true rail.enable_parallel_run_rail_scenario true #Required. Set the type of the script file to python. set_app_options -name rail.generate_file_type -value python #Use user-defined test_def_files for DEF variable to match #with customized python. set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files } create_rail_scenario -name func.ss_125c -scenario func.ss_125c set_rail_scenario -name func.ss_125c -voltage_drop dynamic create_rail_scenario -name func.ff_125c_ -scenario func.ff_125c set_rail_scenario -name func.ff_125c \\ -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py set_host_options -submit_protocol sge \\ -submit_command {qsub -V -notify -b y \\ -cwd -j y -P bnormal -l mfree=16G} analyze_rail -rail_scenario {func.ss_125c func.ff_125c} \\ -submit_to_other_machine The following example uses a customized python script for multi-rail-scenario rail analysis on a local machine. #Required. Specify the below options to enable multi-rail-scenario rail analysis. set_app_options -list { rail.enable_new_rail_scenario true rail.enable_parallel_run_rail_scenario true #Required. Set the type of the script file to python. set_app_options -name rail.generate_file_type -value python #Use user-defined test_def_files for DEF variable to match #with customized python. set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files } create_rail_scenario -name func.ss_125c -scenario func.ss_125c set_rail_scenario -name func.ss_125c -voltage_drop dynamic create_rail_scenario -name func.ff_125c_ -scenario func.ff_125c set_rail_scenario -name func.ff_125c \\ -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py set_host_options -submit_command {local} analyze_rail -rail_scenario {func.ss_125c func.ff_125c} The following example uses a customized python script for single-scenario rail analysis on a grid system. Required. Specify the below options to enable multi-rail-scenario rail analysis. set_app_options -list { rail.enable_new_rail_scenario true rail.enable_parallel_run_rail_scenario true #Required. Set the type of the script file to python. set_app_options -name rail.generate_file_type -value python #Use user-defined test_def_files for DEF variable to match #with customized python. set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files } create_rail_scenario -name func.ff_125c_ -scenario func.ff_125c set_rail_scenario -name func.ff_125c \\ -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py set_host_options -submit_protocol sge \\ -submit_command {qsub -V -notify -b y \\ -cwd -j y -P bnormal -l mfree=16G} analyze_rail -rail_scenario {func.ff_125c} \\ -submit_to_other_machine The following example uses a customized python script for IR-driven placement on a grid system. Required. Specify the below options to enable multi-rail-scenario rail analysis. set_app_options -list { rail.enable_new_rail_scenario true rail.enable_parallel_run_rail_scenario true #Required. Set the type of the script file to python. set_app_options -name rail.generate_file_type -value python #Use user-defined test_def_files for DEF variable to match #with customized python. set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files } create_rail_scenario -name func.ss_125c -scenario func.ss_125c set_rail_scenario -name func.ss_125c -voltage_drop dynamic create_rail_scenario -name func.ff_125c_ -scenario func.ff_125c set_rail_scenario -name func.ff_125c \\ -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py set_host_options -submit_protocol sge \\ -submit_command {qsub -V -notify -b y \\ -cwd -j y -P bnormal -l mfree=16G} # Enable IR-driven placement before running clock_opt -from final_opto set_app_options -name opt.common.power_integrity -value true clock_opt -from final_opto The following example uses a customized python script for concurrent clock and data optimization on a multicorner and multimode design on a grid system. #Required. Specify the below options to enable MCMM-based optimization. set_app_options -list { rail.enable_new_rail_scenario true rail.enable_parallel_run_rail"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Creating Hierarchical Relative Placement Groups"}, {"role": "assistant", "content": "Hierarchical relative placement allows relative placement groups to be embedded within other relative placement groups. The embedded groups then are handled similarly to leaf cells. You can use hierarchical relative placement to simplify the expression of relative placement constraints. With hierarchical relative placement, you do not need to provide relative placement information multiple times for a recurring pattern. Using hierarchical relative placement provides these benefits: Allows you to organize your relative placement in a manner that is easier to maintain and understand. For example, you can create the relative placement group to parallel your Verilog or VHDL organization. Allows reuse of a repeating placement pattern, such as an adder. Can reduce the number of lines of relative placement information you need to write. Allows integrating blocks. Provides flexibility for the configuration you want."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Clock-Gate Multilevel Expansion"}, {"role": "assistant", "content": "The number of clock-gate levels is the count of clock gates between a clock source and a register. Standard clock-gate insertion provides one level of clock-gate insertion. However, designs often contain preexisting clock gates, in which case the design might contain multiple levels of clock gates. You can modify the default clock-gate insertion operation by allowing additional levels of clock gating, by limiting the number of clock-gate levels, or both."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling the Selection of Self-Gating Objects"}, {"role": "assistant", "content": "To specify self-gating settings, use the set_self_gating_options command with the following options: -min_bitwidth bitwidth Controls the minimum size for self-gating banks. The default is 4. -max_bitwidth bitwidth Controls the maximum size for self-gating banks. The default is 8. -interaction_with_clock_gating interaction_type Registers gated by user-instantiated clock-gating cells are candidates for self-gating. Valid arguments are none (skip registers gated by tool-inserted clock gates), insert (the default; insert self-gates on gated registers), and collapse (collapse tool-inserted clock gates if they are in the same hierarchy). -objects object_list Specifies that the options should be applied to the listed objects. Supported objects are hierarchical instances, power domains, and designs. By default, the settings apply to the entire design. -tree_type combinational_logic_type Uses the specified logic type to build the gated enable tree. Valid arguments are xor nand or, and auto (the default). To report self-gating options, use the report_self_gating_options command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling Standard Filler Cell Insertion"}, {"role": "assistant", "content": "The standard filler cell insertion flow uses the create_stdcell_fillers command to insert filler cells in the block and the remove_stdcell_fillers_with_violation command to perform design rule checking on the filler cells and remove filler cells with violations. During filler cell insertion, the create_stdcell_fillers command uses the placement legalizer to ensure that the inserted filler cells honor advanced node placement rules and physical constraints such as placement blockages and keepout margins. When the place.legalize.enable_advanced_legalizer application option is set to true the command uses the advanced legalization algorithms for 2D rule checking and cell interaction, which can reduce filler cell insertion runtime. To insert filler cells in your block, 1. Ensure that the block is legalized by using the check_legality command. When verifying that a block is fillable, the check_legality command assumes that all standard cells that have a design_type attribute of filler can be used as filler cells. However, the create_stdcell_fillers command inserts only the cells specified in the -lib_cells option. This difference might result in unfillable gaps after filler cell insertion even though the check_legality command did not report any issues. 2. (Optional) Insert required filler cells to abut specific standard cells by using the create_left_right_filler_cells command, as described in Abutting Standard Cells With Specific Filler Cells 3. (Optional) Enable multithreaded filler cell insertion by using the set_host_options command to specify the multicore configuration. fc_shell> set_host_options -max_cores The create_stdcell_fillers command uses the multicore configuration only when the technology file contains minimum threshold voltage, oxide-diffusion (OD), or trimpoly (TPO) rules. Note: The multicore configuration specified with the set_host_options command applies to all Fusion Compiler commands that support multicore processing. 4. Insert metal filler cells by using the create_stdcell_fillers command. Use the -lib_cells option to specify the metal filler library cells to insert. The command tries to insert the filler cells in the order that you specify; for the best results, specify them from the largest to the smallest. To determine the filler cells available in a cell library, use the following command: fc_shell> get_lib_cells ref_lib /* -filter \"design_type==filler\" To sort the filler cells by decreasing size, use the sort_collection command, as shown in the following example: fc_shell> set FILLER_CELLS \\ [get_object_name [sort_collection -descending \\ [get_lib_cells ref_lib /* -filter \"design_type==filler\"] area]] For more information, see Controlling Standard Filler Cell Insertion 5. Connect the inserted filler cells to the power and ground (PG) network by using the connect_pg_net -automatic command. 6. Remove the metal filler cells with DRC violations by using the remove_stdcell_fillers_with_violation command. Removing the filler cells can expose new violations; therefore, you must sometimes run this command multiple times to remove all violating filler cells. For more information, see Checking for Filler Cell DRC Violations 7. Insert nonmetal filler cells by using the create_stdcell_fillers command. Use the -lib_cells option to specify the nonmetal filler library cells to insert. The tool tries to insert the filler cells in the order that you specify; for the best results, specify them from the largest to the smallest. For more information, see Controlling Standard Filler Cell Insertion 8. Connect the inserted filler cells to the PG network by using the connect_pg_net -automatic command. See Also Generic ECO Flow for Timing or Functional Changes Removing Filler Cells"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling Movement When Legalizing Relative Placement"}, {"role": "assistant", "content": "When a relative placement cell is modified or moved, the relative placement structure can be disturbed. When a relative placement cell is removed during optimization, the relative placement information of the instance is also removed, disrupting the relative placement structure. To preserve the relative placement structures during various postplacement optimization processes, use the -optimization_restriction option with the set_rp_group_options command and specify the appropriate setting as shown in Table 60 Table 60 Settings for the -optimization_restriction Option To do this Use this setting all_opt size_only size_in_place no_opt For a hierarchical relative placement group, the -optimization_restriction option setting applied to the top level is propagated to the lower-level groups and any settings applied to the lower-level groups are ignored."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling Legalization When Using the place_eco_cells"}, {"role": "assistant", "content": "The place_eco_cells command places and legalizes each ECO cell based on the connectivity and the delays associated with the cell. You can control the placement of the ECO cells as follows: To use the channels areas between macro cells for ECO placement, use the -channel_aware option. By default, the command avoids channel areas during ECO placement. To place ECO cells closer to fixed points, such as I/O pads or macro cells, specify a weight for the nets connected to the fixed cells by using the -fixed_connection_net_weight option. By default, nets connected to fixed cells have a weight of one. To place ECO cells closer to fixed points, specify an integer value greater than one for the corresponding net. To prioritize specific nets during ECO placement by specifying net weights, 1. Specify net weights by using the set_eco_placement_net_weight command. 2. Specify that the tool honors the net weights by using the -honor_user_net_weight option with the place_eco_cells command. To report the net weights you specify, use the report_eco_placement_net_weight command. To create virtual connections for ECO cells and use them during ECO placement, instead of the actual connections, 1. Create virtual connections by using the create_virtual_connection command 2. Use these virtual connections during ECO placement by using the -use_virtual_connection option with the place_eco_cells command. The following example creates virtual connections for the inputs and output of the cell named ECO17 and performs ECO placement using these virtual connections: fc_shell> create_virtual_connection -name VC_0 \\ -pins {U1/Y ECO17/A} fc_shell> create_virtual_connection -name VC_1 \\ -pins {U2/Y ECO17/B} fc_shell> create_virtual_connection -name VC_2 \\ -pins {ECO17/Y D17_OUT} -weight 3 fc_shell> place_eco_cells -cells ECO17 -use_virtual_connection To remove virtual connections you have created, use the remove_virtual_connections command. To query virtual connections, use the get_virtual_connections command. To ignore high-fanout nets connected to ECO cells that exceed a specific threshold, use the -max_fanout option with the place_eco_cells command. To ignore the connections of specific pins on ECO cells, use the -ignore_pin_connection option with the place_eco_cells command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Spreading Repeater Cells During Placement"}, {"role": "assistant", "content": "When you enable IR-drop-aware placement by setting the place.coarse.ir_drop_aware application option to true, the tool creates three categories of cells based on the total number of cells. Default Cell Categories for IR-Drop-Aware Placement By default, the tool selects cells for the three categories by using the criteria shown in The upper category consists of the top one percent of the total number of cells with the highest voltage drop values. During placement, the tool spreads these cells the most. The middle category consists of the next five percent of the cells. During placement, the tool spreads these cells less than those in the upper category. The lower category consists of the rest of the cells. The tool does not spread these cells. You can change the percentage of cells in the upper and middle categories by using the place.coarse.ir_drop_default_target_high_percentage and place.coarse.ir_drop_default_target_low_percentage application options. The following example puts the top 2 percent of cells in the upper category and the next 6 percent of cells in the middle category: fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_high_percentage \\ -value 2.0 fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_low_percentage \\ -value 6.0 Instead of using a percentage of the total number of cells to define the cell categories, you can use the cell voltage drop as a percentage of supply voltage by setting the place.coarse.ir_drop_default_target_high_population and place.coarse.ir_drop_default_target_low_population application options to false. They are true by default. The following example puts cells with a voltage drop larger than 8 percent of the supply voltage into the upper category and cells with a voltage drop between 4 to 8 percent of the supply voltage into the middle category: fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_high_population \\ -value false fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_high_percentage \\ -value 8.0 fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_low_population \\ -value false fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_low_percentage \\ -value 4.0 You can specify a percentage of the total number of cells to define the upper category and cell voltage drop as a percentage of supply voltage to define the middle category, or vice versa. The following example puts the top 2 percent of the total cells in the upper category, and the next cells that have a voltage drop larger than 4 percent of supply voltage in the middle category: fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_high_population \\ -value true fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_high_percentage \\ -value 2.0 fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_low_population \\ -value false fc_shell> set_app_options \\ -name place.coarse.ir_drop_default_target_low_percentage \\ -value 4.0 You can set constraints for specific voltage areas by using the set_placement_ir_drop_target command. The following example puts the top 1.5 percent of the cells in the VA1 voltage area into the upper category and the next 4.5 percent of the cells into the middle category: fc_shell> set_placement_ir_drop_target VA1 high 1.5 fc_shell> set_placement_ir_drop_target VA1 low 4.5 The following example puts the cells with a voltage drop larger than 10 percent of the supply voltage in the VA2 voltage area into the upper category and the cells with a voltage drop between 5 and 10 percent of the supply voltage into the middle category: fc_shell> set_placement_ir_drop_target VA2 high 10 -irdrop fc_shell> set_placement_ir_drop_target VA2 low 5 -irdrop To get, report, and reset the voltage-area-based constraints, use the get_placement_ir_drop_target report_placement_ir_drop_target, and reset_placement_ir_drop_target commands."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying the Net Names, Buffers Types, and Their Locations"}, {"role": "assistant", "content": "To add buffers or pairs of inverters on a fully routed net, use the add_buffer_on_route command as described in the following topics: Specifying the Net Names, Buffers Types, and Their Locations Controlling How Buffers are Added Specifying Settings for Multivoltage Designs Specifying Settings for the Freeze Silicon ECO Flow"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Running the Hierarchical Synthesis Flow Using ETMs"}, {"role": "assistant", "content": "To minimize the number of iterations and obtain optimal results, you can perform feasibility analysis before running hierarchical synthesis, as shown in The hierarchical synthesis feasibility flow uses the following block-level information generated post compile_fusion Floorplanning information to generate the ETM in step 2 Power intent and test model (CTL) information for top-level synthesis in step 4 Hierarchical Synthesis Feasibility Analysis 1. Synthesize the block in the front- end tool compile_fusion RTL Block UPF (front end) Block CTL (front end) UPF SDC, floorplan SDC Design (ndm) Netlist UPF CTL SPEF Design (frame) 2. Create an ETM in the front-end tool extract_model Block_ETM (ndm) 3. Synthesize the top-level design in the front-end tool compile_fusion RTL Top-level UPF SDC, floorplan"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Excluding Specific Sinks"}, {"role": "assistant", "content": "To exclude a specific scenarios from concurrent clock and data optimization, use the ccd.ignore_scenarios application option and specify the name of the scenarios you want to ignore. For example, to ignore the scenario named scnB, use the following command: fc_shell> set_app_options -name ccd.ignore_scenarios \\ -value {scnB}} This setting affects concurrent clock and data optimization performed during the place_opt clock_opt, and route_opt commands."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Importing the Floorplan Information"}, {"role": "assistant", "content": "During early design development, frequent design updates can cause incomplete or inconsistent data, such as pin mismatches between a block-level design and the reference to it from a top-level design. To enable the tool to successfully link a block even if it has certain types of design mismatch, set a mismatch configuration for the block. By default, the tool cannot link any block with inconsistent or mismatching data. When you set mismatch configurations, the tool either ignores or fixes several different types of mismatching data and continues the linking process. Blocks linked with mismatching data can be used only for feasibility analysis. To learn how to mitigate design mismatches, see the Fusion Compiler Data Model User Guide"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Automatically Fixing Double-Patterning Odd-Cycle Violations"}, {"role": "assistant", "content": "By default, the signoff_fix_drc command performs the following tasks: 1. Runs the signoff_check_drc command to generate the initial signoff DRC results, as described in Checking for DRC Violations If you have already run the signoff_check_drc command, you can use the existing signoff DRC results instead of rerunning signoff design rule checking. To reuse the existing results, specify the directory that contains the results by setting the signoff.fix_drc.init_drc_error_db application option. You can specify either a relative path or an absolute path. If you specify a relative path, it is relative to the current working directory. For example, to use the results from the default signoff_check_drc run directory, use the following commands: fc_shell> set_app_options \\ -name signoff.fix_drc.init_drc_error_db \\ -value signoff_check_drc_run fc_shell> signoff_fix_drc Note: To use existing signoff DRC results as input to the signoff_fix_drc command, you must use the signoff DRC application options described in Generating Input for the Automatic Fixing Flow 2. Runs two repair loops to fix the DRC violations In each repair loop, the signoff_fix_drc command performs the following tasks; a. Tries to fix the DRC violations detected in the previous IC Validator signoff DRC run, as described in Fixing DRC Violations b. Runs IC Validator signoff design rule checking on the modified block, as described in Checking for DRC Violations To change the number of repair loops, use the -max_number_repair_loop option; you can specify an integer between 1 and 10. If no signoff DRC violations remain after a loop, the tool does not perform additional repair loops. As the repair loop number increases, so does the physical scope of the rerouting performed by that repair loop. To change the scope, increase the number of the initial repair loop by using the -start_repair_loop option. Note that increasing the initial loop number might cause a greater disturbance to the block, which would require additional design rule checking and fixing by Zroute. 3. Writes a summary report of the results For information about the summary report, see Summary Report for Automatic Design Rule Fixing Fixing DRC Violations In each repair loop, the signoff_fix_drc command tries to fix the DRC violations detected in the previous signoff DRC run. For the first loop, the tool uses the IC Validator data in the directory specified by the signoff.fix_drc.init_drc_error_db application option (or the signoff_drc_run_init directory if you do not use this option). For successive loops, the tool uses the IC Validator DRC data from the previous loop, which is stored in the directory specified by the signoff.fix_drc.run_dir application option (or the signoff_fix_drc_run directory if you do not use this option). When fixing DRC violations, the signoff_fix_drc command has the following default behavior: Tries to fix all design rule violations detected in the previous signoff DRC run except those design rules that have more than 1000 violations Performs DRC fixing on data nets for the whole block To modify the regions for design rule fixing, use one or both of the following options: -coordinates This option restricts design rule fixing to the specified regions. -excluded_coordinates This option prevents design rule fixing in the specified regions. If you specify this option with the -coordinates option, the command does not fix design rules in the overlapping regions. To specify the coordinates, use the following format: {{x } {x }... {x }} Note that there must be a space between each set of coordinates. To prevent fixes that might impact timing-critical nets, use one or both of the following options: -nets This option explicitly specifies the critical nets. -timing_preserve_setup_slack_threshold This option enables the tool to automatically determine the critical nets based on a setup slack threshold. The unit for the slack threshold setting is the library time unit. Performs five iterations of detail routing after DRC fixing to fix any DRC violations introduced during DRC fixing Saves the modified block in a design view named block _ADR_# To change the default behavior, use the following options: signoff.fix_drc.max_errors_per_rule This application option specifies the error threshold for ignoring a design rule. signoff.fix_drc.fix_detail_route_drc This application option controls the scope of DRC fixing. To reduce runtime by performing DRC fixing only in areas near the signoff DRC violations, set this application option to local signoff.fix_drc.target_clock_nets This application option controls whether DRC fixing targets data nets or clock nets. To target clock nets, set this application option to true signoff.fix_drc.max_detail_route_iterations This application option specifies the number of detail routing iterations; you can specify an integer between 0 and 1000. Checking for DRC Violations When performing signoff design rule checking, the signoff_fix_drc command has the following default behavior: Reads the design view for the top-level block and library cell instances, and the pin information from the frame view for the macro cell and I/O pad cell instances For information about changing the view used for specific cells, see Reading Blocks for Signoff Design Rule Checking After the initial run, performs design rule checking only on those portions of the design affected by design rule fixing To perform signoff design rule checking on the entire block for the last repair loop, set the signoff.fix_drc.last_run_full_chip application option to true. Setting this option to true increases accuracy but also increases runtime. To perform signoff design rule checking on the entire block for all repair loops, set the signoff.fix_drc.check_drc application option to global. Setting this option to global increases accuracy but can greatly increase runtime. Does not check for violations in child blocks Excludes rules that are not suitable for automatic design rule fixing To explicitly specify the design rules checked by the IC Validator tool, set the -select_rules rules and -unselect_rules rules application options. Stores the IC Validator results in the signoff_fix_drc_run directory To use a different run directory, set the signoff.fix_drc.run_dir application option. Note: The IC Validator results for the initial signoff DRC run are stored in the signoff_drc_run_init directory. In addition, you can specify options to add to the IC Validator command line by setting the signoff.fix_drc.user_defined_options application option. See Also Performing Signoff Design Rule Checking"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Checking PG Electromigration Violations"}, {"role": "assistant", "content": "A PG electromigration map is a visual display of the color-coded electromigration values overlaid on the physical supply nets. For static analysis, the map displays average electromigration values. For dynamic analysis, the map displays average electromigration values, peak electromigration values, or root mean square electromigration values. shows an example of the electromigration map in which problem areas are highlighted in different colors. Use the options to investigate the problem areas by selecting layers or nets to display. For example, to examine the current value of one specific net, deselect all the nets and then select the net to display from the list. To analyze only the shapes on a layer, select the layer from the list. For a detailed procedure about how to display an electromigration map, see Displaying Maps in the GUI Displaying a PG Electromigration Map"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Reporting the Wire Length"}, {"role": "assistant", "content": "To report statistics about the routing results, use the report_design -routing command. This command reports the following information: Final wiring statistics, including the Number of signal net shapes for each metal layer Signal wire length for each metal layer Number of PG net shapes for each metal layer PG wire length for each metal layer Horizontal and vertical wire distribution for each metal layer Total number of signal net shapes for the block Total signal wire length for the block Final via statistics, including the Simple vias used in each via layer, including the number of instances of each via Double via conversion rate for each via layer Double via conversion rate for the block Custom vias used in the block, including the number of instances of each user- defined via By default, this command reports the information only for the top-level block. To report the information for the entire physical hierarchy, use the -hierarchical option. See Also Defining Vias"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Deriving Mask Colors"}, {"role": "assistant", "content": "To save the route information, use the write_routes command. This command generates a Tcl script that reproduces the metal shapes and vias for a block, including their attribute settings. Note that the write_routes command reproduces routes, but not routing blockages. To generate a Tcl script that reproduces routing blockages, use the write_floorplan command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Creating Constraints for Auto Floorplanning"}, {"role": "assistant", "content": "During early design stages, a design often undergoes many iterations due to changes such as adding features and macros; as a result, the floorplan contains limited or no physical information. Automatic floorplanning can generate high-quality floorplans and create missing physical information early in the design cycle, which allows you to Achieve better correlation between the results of RTL synthesis and design implementation Identify and fix design issues early in the design cycle Generate a better starting point for place and route, eliminating costly iterations During automatic floorplanning, the compile_fusion command performs the following tasks: Creates the die, rows, and tracks Shapes and places voltage areas Places macros Places pins and I/Os By default, the top-level floorplan is created with a core utilization of 0.7. For information about setting constraints for automatic floorplanning, see Creating Constraints for Auto Floorplanning"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Grouping Variant Cell"}, {"role": "assistant", "content": "To set application option before using the add group repeaters and place_group_repeaters commands, use the set_app_option -name eco.placement.variant_cell_swapping -value true command. Based on the requirement, you can plan the variant cell flow. The rules of variant reference swapping differ in various variant cell flows. By default, the variant cell support in the eco_change_legal_reference command detects the variant mode and settings automatically. The eco_change_legal_reference command checks whether the current reference of the cell is legal or illegal for the placed location. If it is illegal, the command attempts to find a legal reference from its variant cell group defined to swap with the illegal one. To use the variant cell features directly for other cells, use the eco_change_legal_reference command. For complicated scenarios, you can switch the variant mode and tune the settings manually. Following are the new application options for variant cell support: To set variant mode for different customers and different design flows, use the set_app_options -name eco.placement.variant_cell_group_mode -value command. To honor the variant cell groups, which are not sharing timing view, use the set_app_options -name eco.placement.honor_cell_group_not_sharing_timing -value command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Performing Design Rule Checking Using Zroute"}, {"role": "assistant", "content": "To display the global route congestion map, choose View > Map > Global Route Congestion in the GUI. If the design library contains global route congestion information for the block, the tool generates the congestion map based on this information; otherwise, you must click Reload to generate the congestion map. When you click Reload, the tool opens a dialog box that contains the following command: route_global -congestion_map_only true Note: By default, only the hard congestion data is saved in the design library. To also save the soft congestion data, set the route.global.export_soft_congestion_maps application option to true before performing global routing. When you click OK in this dialog box, the tool generates a new congestion map. If you want to use different options for the route_global command, you can modify this command before clicking OK. shows an example of a congestion map. Global Route Congestion Map By default, the congestion map displays only the hard congestion data. To display soft congestion data, select the desired rule level in the Rule level drop-down list. The rule level refers to the spacing weight level of the soft nondefault spacing rules. The congestion map displays the sum of the hard and soft congestion with a weight level of at least the selected rule level. The congestion map shows the borders between global routing cells highlighted with different colors that represent the congestion values. The congestion map supports two methods for calculating the congestion value: Sum of overflow for each layer (the default) In this mode, the tool calculates the congestion value as the sum of the overflow for all selected layers. Underflow is not considered; if a layer has underflow, it contributes zero overflow to the total overflow calculation. Total demand minus total supply In this mode, the tool calculates the congestion value by subtracting the supply for all selected layers from the demand for all selected layers. Note that because this calculation considers the underflow, it produces a more optimistic congestion result in regions that contain both overflow and underflow. For example, assume that the METAL2 layer is heavily congested with a demand of 13 routing tracks and a supply of only 7 tracks for an overflow of 6. The METAL4 is moderately congested with an overflow of 4, and the METAL6 layer is not congested and contains an underflow of 3. Other layers are not used in the congestion calculation in this example. The sum of overflow calculation results in a congestion value of 6+4=10. The underflow of 3 for the METAL4 layer is not used in the calculation. The total demand calculation results in a congestion value of 6+4-3=7. In this case, the underflow of 3 for the METAL4 layer is used in the calculation. To select the mode, select either \"Sum of overflow for each layer\" or \"Total demand minus total supply\" in the \"Congestion calculation\" section of the Map Mode panel. By default, all metal layers are selected in the congestion map, except those specified as ignored layers with the set_ignored_layers command. To display the congestion map for a subset of layers, select (or deselect) the layers on the Map Mode panel. For example, if the global routing report shows that the maximum overflow occurs on the METAL2 layer, you can deselect all layers, except for METAL2, to display only the METAL2 congestion. The Map Mode panel also displays a histogram showing the number of global routing cells in different ranges (bins) of congestion values for the selected layers. If your block contains global routing cells that have no available routing resources, an additional bin named Blocked is displayed that shows the number of global routing cells with no routing resources. You can select which bins to display in the congestion map by selecting or deselecting them on the Map Mode panel. If the block shows congested areas, zoom into the congested area to see the congestion value on the global routing cell. For example, in, the red highlight on the edge of the global routing cell shows 18/9. This means there are 9 wire tracks available, but 18 tracks are needed. Global Route Overflow on Global Routing Cell"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Minimizing Large Displacements During Legalization"}, {"role": "assistant", "content": "The tool performs legalization at various points during the design flow. The following topics describe settings for controlling legalization: Minimizing Large Displacements During Legalization Optimizing Pin Access During Legalization Enabling Advanced PG Net Checks Enabling Advanced Legalization Algorithms Setting Up for Variant-Aware Legalization Checking if Library Cells Are Legally Placeable"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Timing-Driven Power Grid Augmentation"}, {"role": "assistant", "content": "Before you run the signoff_create_pg_augmentation command, configure the run by setting the application options shown in Table 48. To set the application options, use the set_app_options command. To see the current settings, use the report_app_options command. Table 48 Application Options for Power Grid Augmentation Application option Default Description signoff. create_pg_augmentation. ground_net_name signoff. create_pg_augmentation.po wer_net_name signoff. create_pg_augmentation. run_dir signoff_create_pg_augmentation Table 48 Application Options for Power Grid Augmentation (Continued) Application option Default Description signoff. create_pg_augmentation. user_defined_options"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Making ECO Changes Using Netlist Editing Commands"}, {"role": "assistant", "content": "You can make ECO changes to a block by using the eco_netlist command. If you are using the freeze silicon ECO flow, enable ECO changes in the freeze silicon mode by setting the design.eco_freeze_silicon_mode application option to true before you run the eco_netlist command. When you use the eco_netlist command, use one of the following two methods to make the ECO changes: Specify a golden Verilog netlist that includes the ECO changes by using the -by_verilog_file option Specify a golden block that includes the ECO changes by using the -block option When you use the -block option, by default, The tool assumes the golden block is in the current design library. To specify a different design library, use the -golden_lib option. The tool makes the ECO changes to the current design. To make the ECO changes to a different design, use the -working_block option. To specify the design library that contains the design specified by the -working_block option, use the -working_lib option. The tool compares the working design to the input Verilog netlist or the golden design and generates a change file containing netlist editing Tcl commands that implements the functional changes. You must specify the name of the output file by using the -write_changes option. By default, the tool ignores the following: Differences in the physical-only cells To consider the differences in the physical-only cells, use the -compare_physical_only_cells option. Timing ECO changes, such as cells that are resized or repeaters that are added or removed. To consider the timing ECO changes, in addition to the functional ECO changes, use the -extract_timing_eco_changes option. Differences in power and ground objects. To make the ECO changes to the working design, source the change file that the eco_netlist command generates, as shown in the following example: fc_shell> eco_netlist -by_verilog_file eco.v \\ -compare_physical_only_cells -write_changes eco_changes.tcl fc_shell> source eco_changes.tcl"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Self-Gating Flow"}, {"role": "assistant", "content": "The tool supports self-gating optimization, which occurs at the compile_fusion command. This feature reduces dynamic power consumption by turning off the clock signal of certain registers during clock cycles when the data remains unchanged. Example of a Self-Gating Cell CLK Registers with an enable condition that cannot be inferred from the existing logic can only be gated using the self-gating technique. They cannot be gated using traditional clock gating. By default, the tool supports self-gating only on registers that are not gated. You can use the set_self_gating_options command to allow self-gating on these registers. However, the time duration that the clock signal is turned off might increase for these registers,. To ensure QoR improvements, the self-gating algorithm takes timing and power into consideration. A self-gating cell is inserted for the registers if There is enough timing slack available in the register's data pin. For designs with multiple scenarios, the algorithm considers the timing of the worst case among active scenarios enabled for setup. Internal dynamic power of the circuit is reduced. For designs with mutiple scenarios, the algorithm uses the average internal dynamic power among active scenarios enabled for dynamic power. To minimize the area and power overhead, a self-gating cell can be shared across a few registers by creating a combined enable condition with a tree of comparator cells. If the self-gated registers are driven by synchronous set or synchronous clear signals, these signals are also included in the construction of the enable signal so that the circuit remains functionally unchanged. is an example of a self-gating cell that is shared across two registers (4 bits). Note that one of the self-gated registers is a multibit register and the other register is a single-bit register. The tool can also self-gate a group of multibit registers or a group of single-bit registers. Self-Gating Tree CLK D0 Q0 D2 Q2 D1 Q1 EN The tool does not support the following types of sequential cells for self-gate insertion: Level-sensitive sequential cells Level-sensitive scan design registers Master-slave flip-flops Retention registers Single-bit and multibit registers that belong to shift registers Multibit registers with multiple clock paths For more information, see the following topics: Self-Gating Flow Library Requirements for Self-Gating Setting Up for Self-Gating Reporting and Querying Self-Gating Cells"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Track-Based Metal Fill Insertion"}, {"role": "assistant", "content": "Pattern-based metal fill insertion is the default mode for the signoff_create_metal_fill command. It inserts metal and via fill by using a foundry runset. Before running the signoff_create_metal_fill command, you must specify the runset by setting the signoff.create_metal_fill.runset application option. During pattern-based metal fill insertion, the signoff_create_metal_fill command performs the following tasks: 1. Loads the block into the IC Validator tool, as described in Reading Blocks for Signoff Metal Fill Insertion 2. Removes existing metal and via fill By default, the command removes the metal and via fill from the entire block. For information about performing incremental metal fill insertion, see Incremental Metal Fill Insertion 3. Inserts metal and via fill in the empty regions By default, the command uses the spacing rules defined in the technology file to perform metal fill insertion on all metal and via layers for the entire block. The command uses the metal fill mode specified in the runset file, which is either hierarchical or flat. To modify the default behavior, Set one or more of the following application options before running the signoff_create_metal_fill command: signoff.create_metal_fill.apply_nondefault_rules To enable the use of nondefault spacing rules in addition to the spacing rules defined in the technology file, set this application option to true signoff.create_metal_fill.flat To force the use of the flat metal fill mode, set this application option to true Use one or more of the following command options with the signoff_create_metal_fill command: -select_layers or -all_runset_layers To restrict the layers on which to insert metal fill, use these options, as described in Specifying the Layers for Metal Fill Insertion -coordinates and -excluded_coordinates To restrict the regions on which to insert metal fill, use these options, as described in Specifying the Regions for Metal Fill Insertion 4. Removes floating via fill from the specified via layers and from the via layers associated with the specified metal layers Floating via fill is via fill that does not have both an upper and lower metal enclosure. 5. Saves the fill data in the design view 6. Writes the result files to the run directory For information about the generated result files, see Signoff Metal Fill Result Files See Also Timing-Driven Metal Fill Insertion Reading Blocks for Signoff Metal Fill Insertion By default, the IC Validator tool reads the design view for the top-level block and the library cell instances, and the pin information from the frame view for the macro cell and I/O pad cell instances. To read the GDSII or OASIS data for specific reference cells, specify the stream files by setting the signoff.physical.merge_stream_files application option. When you use this option, the GDSII or OASIS data replaces the cell library view for the cells defined in the specified stream files, except for cells in the cell libraries specified with the signoff.physical.merge_exclude_libraries application option. To read the layout view for specific reference cells, specify the cells by setting the signoff.create_metal_fill.read_layout_views application option. The layout view is identical to the GDSII or OASIS data that was used to create them, but reduces the runtime for signoff design rule checking. Note: By default, layout views are not included in the cell libraries To save the layout views, you must set the lib.workspace.save_layout_views application option to true during library preparation, as described in the Library Manager User Guide To read the design view for specific reference cells, specify the cells by setting the signoff.create_metal_fill.read_design_views application option. Note: By default, design views are not included in the cell libraries To save the design views, you must set the lib.workspace.save_design_views application option to true during library preparation, as described in the Library Manager User Guide The order of precedence for child cell data is 1. GDSII or OASIS data specified with the signoff.physical.merge_stream_files application option 2. Layout views specified with the signoff.create_metal_fill.read_layout_views application option If the IC Validator tool cannot find a layout view and the cell is specified in the signoff.check_drc.read_design_views application option, it reads the design view. Otherwise, it reads the frame view. If it cannot find the frame view, the cell is ignored during design rule checking. 3. Design views specified with the signoff.create_metal_fill.read_design_views application option If the IC Validator tool cannot find a design view, it reads the frame view instead. If it cannot find the frame view, the cell is ignored during design rule checking. 4. Frame views Specifying the Layers for Metal Fill Insertion By default, the signoff_create_metal_fill command inserts metal fill on all the metal routing layers and via fill on all the via layers. To modify the layers for metal fill insertion, use one of the following options: -select_layers metal_fill_layers This option restricts metal fill insertion to the specified set of metal and via layers. -all_runset_layers true This option enables metal fill insertion on all the fill layers specified in the runset. This option applies only to pattern-based metal fill insertion. When you specify the layers for metal fill insertion, the signoff_create_metal_fill command 1. Removes the existing metal and via fill from the block By default, the command removes all existing metal and via fill. For incremental metal fill insertion, the command removes metal and via fill only from the specified layers. 2. Inserts metal and via fill only on the specified layers 3. Removes floating via fill from the specified via layers and from the via layers associated with the specified metal layers For example, if you specify -select_layers {M2}, the tool removes floating via fill from the V1 and V2 layers. Specifying the Regions for Metal Fill Insertion By default, the signoff_create_metal_fill command inserts metal and via fill for the whole chip. To modify the regions for metal fill insertion, use one or both of the following options: -coordinates This option restricts metal fill insertion to the specified regions. Note: The bounding box coordinates passed to the IC Validator tool in the METAL_FILL_SELECT_WINDOW parameter are enlarged by 1 um to avoid DRC violations on the boundary of the specified regions during metal fill insertion. The actual metal fill insertion occurs within the regions specified by the -coordinates option. In addition, when you use the -coordinates option, the signoff_create_metal_fill command always uses the flat metal fill mode. -excluded_coordinates This option prevents metal fill insertion in the specified regions. If you specify this option with the -coordinates option, the command does not perform metal fill insertion in the overlapping regions. To specify the coordinates, use the following format: {{x } {x }... {x }} Note that there must be a space between each set of coordinates. When you specify the regions for metal fill insertion, the signoff_create_metal_fill command 1. Removes all existing metal and via fill from the block For standard metal fill insertion, the command removes all existing metal and via fill. For incremental metal fill insertion, the command removes metal and via fill only from the specified regions. 2. Inserts metal and via fill only on the specified regions 3. Removes floating via fill from the specified regions For example, to remove all metal fill from the block and then fill all empty regions outside the bounding box with corners at (100,150) and (300,200), use the following command: fc_shell> signoff_create_metal_fill \\ -excluded_coordinates {{100 150} {300 200}}"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Overriding the Alignment When Adding Objects"}, {"role": "assistant", "content": "To align a group by pin location, use the -alignment pin and -pin_name options with the set_rp_group_options command. The tool looks for the specified alignment pin in each cell in the column. If the alignment pin exists in a cell, the cell is aligned by using the pin location. If the specified alignment pin does not exist in a cell, the cell is aligned by the left edge, and the tool issues an information message. If the specified alignment pin does not exist in any cell in the column, the Fusion Compiler tool issues a warning message. The script in Example 46 creates a relative placement group rp1, adds cells to it, and specifies that the cells are aligned by pin A. Example 46 Definition for Relative Placement Group Aligned by Pins create_rp_group -name rp1 -columns 1 -rows 4 set_rp_group_options -alignment pin -pin_name A add_to_rp_group rp1 -cells U1 -column 0 -row 0 add_to_rp_group rp1 -cells U2 -column 0 -row 1 add_to_rp_group rp1 -cells U3 -column 0 -row 2 add_to_rp_group rp1 -cells U4 -column 0 -row 3 When aligning by pins, the tool tries different orientations for the cells and selects the orientation for each cell that gives the minimum column width. For example, changing the orientation of cell U2, as shown in, reduces the width of column 0. However, if you specify an orientation when adding a cell to a relative placement group by using the -cells and -orientation options with the add_to_rp_group command, the tool honors the orientation you specify. Minimizing the Column Width of a Relative Placement Group Aligned by Pins U4 U3 U2 U1 row 3 row 2 row 1 row 0 column 0 Pin A U4 U3 U2 U1 row 3 row 2 row 1 row 0 column 0 When you specify an alignment pin for a group, the pin applies to all cells in the group. You can override the group alignment pin for specific cells in the group by specifying the -pin_name option when you use the add_to_rp_group command to add the cells to the group. The script in Example 47 defines relative placement group rp2, and specified pin A as the group alignment pin. However, instances I5 and I6 use pin B as their alignment pin, rather than the group alignment pin. The resulting structure is shown in Example 47 Definition for Aligning a Group and Leaf Cells by Pins create_rp_group -name rp2 -columns 1 -rows 6 set_rp_group_options rp2 -alignment pin -pin_name A add_to_rp_group rp2 -cells I3 -column 0 -row 0 add_to_rp_group rp2 -cells I4 -column 0 -row 1 add_to_rp_group rp2 -cells I5 -column 0 -row 2 -pin_name B add_to_rp_group rp2 -cells I6 -column 0 -row 3 -pin_name B add_to_rp_group rp2 -cells I7 -column 0 -row 4 add_to_rp_group rp2 -cells I8 -column 0 -row 5 Relative Placement Group Aligned by Different Pins I5 I4 I3 row 3 row 2 row 1 row 0 col 0 I6 I7 I8 row 4 row 5 Pin A Pin B"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Enabling Advanced Logic Restructuring"}, {"role": "assistant", "content": "For designs that cannot be legalized due to areas of high utilization, you can specify that the tool perform area recovery in regions where the utilization is high by setting the opt.common.small_region_area_recovery application option to true When you enable this feature, the tool performs the area recovery during the compile_fusion and clock_opt commands. However, doing so can slightly degrade the timing QoR."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Deriving the Clock Trees"}, {"role": "assistant", "content": "This section details the information required to analyze and define each clock tree before running clock tree synthesis. Before you run clock tree synthesis, analyze each clock tree in the block and determine What the clock root is What the required clock sinks and clock tree exceptions are Whether the clock tree contains preexisting cells, such as clock-gating cells Whether the clock tree converges, either with itself (a convergent clock path, definedclockconvergent convergent clock path) or with another clock tree (an overlaping clock path, definedclockoverlaping overlapping clock path) Whether the clock tree has timing relationships with other clock trees in the block, such as interclock skew requirements Use this information to define the clock trees and validate that the tool has the correct clock tree definitions. The Fusion Compiler tool derives the clock trees based on the clocks defined in the block. If the derived clock trees do not meet your requirements, you can define clock trees as described in the following topics: Deriving the Clock Trees Defining Clock Tree Exceptions Restricting Optimization on the Clock Network Copying Clock Tree Exceptions Across Modes Deriving Clock Tree Exceptions From Ideal Clock Latencies Handling Endpoints With Balancing Conflicts"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Reporting Commands and Examples"}, {"role": "assistant", "content": "Use the reports generated by Fusion Compiler to analyze and debug your design. You can generate reports before and after you compile your design. Generate reports before compile to check that you have set attributes, constraints, and design rules properly. Generate reports after compile to analyze the results and debug your design. This section includes the following topics: Reporting Commands and Examples Measuring Quality of Results Comparing QoR Data Reporting Logic Levels in Batch Mode Querying Specific Message IDs"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting the Policy for Early Data Checks"}, {"role": "assistant", "content": "The tool can identify issues and violations in data during the early stages of design. You can set policies and strategy configurations for the predefined checks to allow, tolerate, or repair data. Table 64 describes the predefined checks for top-level closure. Table 64 Top-Level Closure Checks, Policies, and Strategies Check Description Strategy Supported Policies Supported References hier.block.miss ing_frame_view error, tolerate, repair MID BOT hier.block.refe rence_missing_p ort_location error, tolerate, repair MID BOT hier.block.refe rence_port_outs ide_boundary error, tolerate, repair MID BOT Table 64 Top-Level Closure Checks, Policies, and Strategies (Continued) Check Description Strategy Supported Policies Supported References hier.block.refe rence_missing_p ort error, tolerate, repair MID BOT hier.block.inst ance_bound_to_f rame error, tolerate TOP hier.block.inst ance_with_desig n_type_macro error, tolerate TOP hier.top.estima ted_corner error, tolerate TOP hier.block.miss ing_leaf_cell_l ocation error, tolerate, repair MID BOT hier.block.leaf _cell_outside_b oundary error, tolerate, repair MID BOT hier.block.miss ing_child_block _instance_locat ion error, tolerate, repair MID Table 64 Top-Level Closure Checks, Policies, and Strategies (Continued) Check Description Strategy Supported Policies Supported References hier.block.chil d_block_instanc e_outside_bound ary error, tolerate, repair MID hier.block.port _mismatch_betwe en_views error, tolerate, repair MID BOT hier.block.miss ing_design_view _for_abs error, tolerate MID BOT hier.block.inst ance_unlinked error TOP hier.block.abst ract_type_non_t iming error MID BOT hier.block.abst ract_target_use _non_implementa tion error MID BOT hier.block.miss ing_core_area error MID BOT Table 64 Top-Level Closure Checks, Policies, and Strategies (Continued) Check Description Strategy Supported Policies Supported References hier.block.unma pped_logic error MID BOT Where BOT signifies bottom level design. MID signifies intermediate level design, which instantiates BOT. TOP signifies the top-level design, which instantiates MID."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Defining Voltage Areas"}, {"role": "assistant", "content": "A floating logical supply net is a power or ground net that is not connected to any logical pin or port in the block. For example, a power feedthrough net created during power planning is a floating supply net. To create a floating supply net with the connect_pg_net command, use the following steps: 1. Specify the supply net type in the UPF file by using the supply_net_pg_type attribute, as shown in the following UPF file example: create_supply_net VDD set_design_attributes -elements VDD \\ -attribute supply_net_pg_type power 2. Enable floating supply nets by setting the mv.pg.create_floating_pg application option to true before you create supply nets with the connect_pg_net command, as shown in the following script example: # Apply the UPF load_upf $upf_input_file_name commit_upf # create logical supply nets set_app_options -as_user_default \\ -name mv.pg.create_floating_pg -value true connect_pg_net -automatic check_mv_design The tool creates the logical supply nets in the topmost hierarchy of the current UPF scope for domain-independent supply nets. For domain-dependent supply nets, the tool creates the logical supply nets in the topmost hierarchy of the domain. The tool does not create a logical supply net in the following situations: There is a conflict between the connection and the supply net type specified with the supply_net_pg_type attribute. The supply net is connected to a PG pin of an instance. The connect_pg_net command is not specified in the current or parent physical hierarchy."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I RedHawk/RedHawk-SC Fusion Analysis Flow"}, {"role": "assistant", "content": "The RedHawk/RedHawk-SC Fusion feature allows you to perform rail analysis during the implementation stage. With the required input files, the Fusion Compiler tool creates the RedHawk run script and the Global System Requirements (GSR) configuration file for invoking the RedHawk tool (or the RedHawk-SC Python script for invoking the RedHawk-SC tool) to run PG net extraction, power analysis, voltage drop analysis, and PG electromigration analysis. When analysis is complete, the Fusion Compiler tool generates analysis reports and maps using the results calculated by the RedHawk or RedHawk-SC tool. You can then check for hotspots graphically in the Fusion Compiler GUI. Error data and ASCII reports are also available to check for locations where limits are violated. illustrates the data flow when using RedHawk Fusion or RedHawk-SC Fusion to perform rail analysis in the Fusion Compiler environment. RedHawk Fusion and RedHawk-SC Fusion Data Flow"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Voltage Driven Power Switch Cell Sizing"}, {"role": "assistant", "content": "Note: The distributed rail analysis feature is supported only in the RedHawk Fusion analysis flow. By default, the analyze_rail command uses a single process to perform RedHawk rail analysis. To reduce memory usage and total runtime, use the distributed processing method to run RedHawk Fusion on a machine other than the one on which the Fusion Compiler tool is run. You can submit multiple RedHawk jobs to the target farm machines and run the jobs in parallel in the same Fusion Compiler session. This allows you to run multiple RedHawk analyses with only one Fusion Compiler license. Each of the RedHawk jobs requires one SNPS_INDESIGN_RH_RAIL license key. To examine the generated analysis result, first run the open_rail_result command to load the result that is saved in the directory you specify. You can then investigate the problematic areas in the map and check for violations in a text file or in an error view. You can open one result context at a time. To load the rail context generated in another analysis run, first close the current rail result using the close_rail_result command, and then open the desired rail result (see Displaying Maps in the GUI ). License Requirement By default, the number of required licenses is the number of script files or configurations specified with the -multiple_script_files option during distributed processing mode. If the number of available licenses is less than the number of script files at the time when the analyze_rail command is run, the command stops with an error message. To check for available SNPS_INDESIGN_RH_RAIL licenses continuously during the analyze_rail run, set the rail.license_checkout_mode application option to wait. If the tool detects that a license becomes available, the tool reuses or checks out the license and submits a script to a farm machine immediately. By default, the rail.license_checkout_mode application option is set to nowait When the analysis is finished, run the remove_licenses command to release the SNPS_INDESIGN_RH_RAIL licenses. fc_shell> remove_licenses SNPS_INDESIGN_RH_RAIL In, the rail.license_checkout_mode application option is set to wait. There are six scripts to submit to the farm machines with only two available SNPS_INDESIGN_RH_RAIL licenses. In this case, the tool first checks out two licenses and waits for other licenses to become available. When a script finishes the job, the tool reuses its license immediately to submit other scripts. Waiting for Available Licenses During Distributed RedHawk Fusion Run Invoke analyze_rail Check the number of available licenses Script 1 Script 2 license 1 license 2 Script 3 Script 4 Script 5 Script 6 Set rail.license_checkout_mode to wait The tool first submits two scripts to the farm machines, because there are only two licenses available.... The tool checks for available licenses during the analyze_rail run. When a license becomes available, the tool reuses it. Steps to Enable Distributed Processing To enable distributed processing for RedHawk Fusion, 1. Define the distributed processing configuration by using the set_host_options command. You can specify one or more of the following options: Option Description -submit_protocol rsh -target -timeout Option Description -submit_command -max_cores 2. Run the analyze_rail command with the following options: Option Description -submit_to_other_machines -multiple_script_files\\ directory_name script_name Example 51 %> rsh myMachine ls test1 CSHRC DESKTOP > set_host_options \"myMachine\" -target RedHawk \\ -max_cores 2 -timeout 100 > analyze_rail -submit_to_other_machines \\ -voltage_drop static -nets {VDD VDDG VDDX VDDY VSS} The above example first checks if the machine myMachine supports the rsh protocol, and then enables job submission to the myMachine machine for RedHawk Fusion only. Timeout value is 100 and the number of cores to use is 2. Example 52 > set_host_options -submit_protocol sge \\ -submit_command { qsub -P normal } > analyze_rail -submit_to_other_machines -voltage_drop \\ static -nets {VDD VSS} The above example enables job submission to a machine on the SGE farm machine. Example 53 > set_host_options -submit_protocol lsf \\ -submit_command {bsub} > analyze_rail -submit_to_other_machines \\ -multiple_script_files {{result1 RH1.tcl} {result2 RH2.tcl}} > open_rail_result result1 > close_rail_result > open_rail_result result2 The above example submits two RedHawk jobs with two RedHawk scripts to the LSF farm machines and specifies the directories for saving the analysis results as result1 and result2. Example 54 > set_app_options -name rail.license_checkout_mode \\ -value wait > set_host_options -submit_protocol sge \\ -submit_command {qsub} > analyze_rail -submit_to_other_machines \\ -multiple_script_files {{ result1 RH1.tcl} {result2 RH2.tcl} \\ {result3 RH3.tcl}} The above example submits three RedHawk scripts to the SGE farm machines and waits for an available license during the analyze_rail run."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Reporting Clock-Gating Results"}, {"role": "assistant", "content": "If sequential clock gating is enabled, the report_clock_gating command automatically displays a summary table, similar to the following: Sequential Clock Gating Summary | | Bitwidth | |No of sequential clock gates | 2 | | | | | | |No of fanin-based sequential clock gates | 2 (100.0%) | | | | | | |No of sequentially-gated registers | 7 (21.2%) | 7 (21.2%) | | | | | |No of fanin-based sequentially-gated regs | 7 (21.2%) | 7 (21.2%) | | | | | |No of registers not sequentially gated | 26 (78.8%) | 26 (78.8%) | | | | | |Total number of registers | 33 | 33 | Use the report_clock_gating -ungated command to report the reasons why sequential clock gating is not implemented. The report is similar to the following: fc_shell> report_clock_gating -ungated Not fanin-based sequentially gated registers Register | Reason for not gating | What's next? q2_reg[0] | Register contains object different than edge-triggered flip-flops in its transitive fanin | Check the register transitive fanin q2_reg[4] | Register contains object different than edge-triggered flip-flops in its transitive fanin | Check the register transitive fanin u/reg1_reg[2] | Register enable function is not a cover of the transitive fanin enable function | Check the register enable condition Total 7"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Copying Clock Tree Exceptions Across Modes"}, {"role": "assistant", "content": "To set a size-only setting on a cell, use the set_size_only command. The following command sets a size-only setting on a cell: fc_shell> set_size_only [get_cells cell_name ] true To report all the size-only settings set on the current block, use the report_size_only command. fc_shell> report_size_only -all"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Clock Tree Design Rule Constraints"}, {"role": "assistant", "content": "Before you synthesize the clock trees, use the check_clock_tre comandcomandscheck_clock_tre check_clock_trees command to verify that the clock trees are properly defined. For example, to verify that the CLK clock tree is properly defined, use the following command: fc_shell> check_clock_trees -clocks [get_clocks CLK] If you do not specify the -clock option, the tool checks all clocks in the current block. The check_clock_trees command checks for the following issues: Clock (master or generated) with no sinks Loops in the clock network Multiple clocks reach the same register because of overlapping clocks, but multiple- clocks-per-register propagation is not enabled Ignored clock tree exceptions Stop pin or float pin defined on an output pin Buffers with multiple timing arcs used in clock tree references Situations that cause an empty buffer list Generated clock without a valid master clock source A generated clock does not have a valid master-clock source in the following situations: The master clock specified in create_generated_clock does not exist The master clock specified in create_generated_clock does not drive the source pin of the generated clock The source pin of the generated clock is driven by multiple clocks, and some of the master clocks are not specified with create_generated_clock For example, in, the GEN_REG/Q pin is driven by both CLKA and CLKB. If only CLKA is specified as a master clock in a create_generated_clock command, GEN_CLK does not have a valid master clock source. Generated Clock With Invalid Master Clock Source REG1 REG2 GEN_REG CLKA CLKB GEN_CLK For multicorner-multimode designs, the check_clock_trees command checks all active scenarios for the following issues: Conflicting per-clock exception settings Conflicting balancing settings Before you implement the clock trees, you should manually fix the reported issues. Each message generated by the check_clock_trees command has a detailed man page that describes how to fix the identified issue. You can improve the clock tree and timing QoR by fixing all the issues identified by the check_clock_trees command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Horizontal and Vertical Spacing for Repeater Groups"}, {"role": "assistant", "content": "Use one of the following mutually exclusive options to control cutting for repeater groups: -layer_cutting_spacing specifies the cut space of the routes to the driver pin. The cut starts from the driver side. -layer_cutting_distance specifies the cut distance from the repeater center to the input and output routes."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Defining a Customized Via Mapping Table"}, {"role": "assistant", "content": "By default, Zroute reads the default contact codes from the technology file and generates an optimized via mapping table. To see the default mapping table, use the add_redundant_vias -list_only true command. In most cases you achieve better results if you use a customized mapping table rather than the default mapping table. For information about defining a customized mapping table, see Defining a Customized Via Mapping Table If you have not previously defined a customized mapping table for the block, you can see the default mapping table by using the add_redundant_vias -list_only true command. Note: After you have created a customized mapping table by using the method described in Defining a Customized Via Mapping Table, this command shows the customized mapping table. Example 27 shows an example of a default via mapping table. Example 27 Default Via Mapping Table fc_shell> add_redundant_vias -list_only... Redundant via optimization will attempt to replace the following vias: VIA12SQ_C -> VIA12SQ_C_2x1 VIA12SQ_C_2x1(r) VIA12SQ_C_1x2 VIA12SQ_ C_1x2(r) VIA12SQ_C(r) -> VIA12SQ_C_2x1 VIA12SQ_C_2x1(r) VIA12SQ_C_1x2 VIA12SQ_ C_1x2(r)... VIA89(r) -> VIA89_C_1x2(r) VIA89_1x2(r) VIA89_1x2 VIA89_C_1x2 VIA89_C_2x1(r) VIA89_2x1(r) VIA89_2x1 VIA89_C_2x1 VIA9RDL -> VIA9RDL_2x1 VIA9RDL_1x2"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Troubleshooting"}, {"role": "assistant", "content": "Use the add_group_repeaters and place_group_repeaters commands to display the summary report for variant cell swapping in command cell collections."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Creating a Multibit Register Bank From Specific Single-Bit"}, {"role": "assistant", "content": "To perform integrated multibit register optimization during the compile_fusion command, 1. Enable multibit register optimization by setting the compile.flow.enable_multibit application option to true When you do so, by default, the tool performs the following multibit optimizations during different stages of the compile_fusion command: Combines single registers or smaller register banks at the RTL level to create larger register banks during the initial_map stage To disable this feature, set the compile.flow.enable_rtl_multibit_banking application option to false Splits multibit register banks created at the RTL level if the register bank includes registers on critical timing paths during the logic_opto stage To disable this feature, set the compile.flow.enable_rtl_multibit_debanking application option to false Creates multibit register banks considering placement during the initial_opto stage To disable this feature, set the compile.flow.enable_physical_multibit_banking application option to false You can enable placement-based multibit banking during the final_place stage of the compile_fusion command, instead of the initial_opto stage, by setting the compile.flow.enable_second_pass_multibit_banking application option to true and the compile.flow.enable_physical_multibit_banking application option to false You should enable placement-based multibit banking either during the initial_opto stage or the final_place stage; not both. Splits multibit register banks, if it improves total negative slack (TNS), during the initial_opto and final_opto stages To disable this feature, set the compile.flow.enable_multibit_debanking application option to false 2. (Optional). 3. Specify settings for multibit register banking by using the set_multibit_options command. For example, the following command excludes the reg[1] cell from multibit optimization during the RTL-banking stage: fc_shell> set_multibit_options -exclude [get_cells \"reg[1]\"] \\ -stage rtl The following command specifies that during the physical-banking stage, the tool banks only registers that are connected to the same bus: fc_shell> set_multibit_options -bus_registers_only \\ -stage physical 4. (Optional) Control multibit register optimization using application options as shown in the following table. Table 22 General Application Options for Controlling Multibit Register Optimization To do this Set this application option multibit.banking.enable_strict_scan_check true multibit.banking.lcs_consider_multi_si_cells true multibit.banking.across_equivalent_icg true dont_touch legalize_only size_only mv.cells.enable_multibit_pm_cells true size_only multibit.common.exclude_size_only_cells false compile_fusion compile.flow.enable_multibit_rewiring true To do this Set this application option logic_opto compile.flow.enable_toggle_aware_rtl_multibit_ reordering true initial_opto (compile_fusion) final_place final_opto (compile_fusion/place_opt) logic_opto compile_fusion opt.common.enable_multibit_feature true 5. (Optional) Create a multibit register bank from specific single-bit registers as described in Creating a Multibit Register Bank From Specific Single-Bit Registers 6. (Optional) Control the naming style used for multibit banking as described in Specifying Naming Styles for Multibit Registers 7. Perform optimization by using the compile_fusion command. 8. (Optional) Report multibit information. To report the multibit register banks inferred by the tool, use the report_transformed_registers -multibit command, as described in Reporting Multibit Registers To report multibit statistics such as the total number of single-bit and multibit registers, the multibit banking ratio, and so on, use the report_multibit command. For more information about how to determine why multibit register banking is not performed for specific cells, see Identifying Why Multibit Banking Is Not Performed 9. (Optional) Analyze the multibit banking components in the GUI as described in Viewing Multibit Components in the GUI"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Diodes After Detail Routing"}, {"role": "assistant", "content": "One way to protect gates from antenna effects is to provide a discharge path for the accumulated charge to leave the net. However, the discharge path should not allow current to flow during normal chip operation. Discharging can be accomplished by inserting a reverse-biased diode on the net close to the gate that is being protected. To enable diode insertion during detail routing, set the route.detail.insert_diodes_during_routing application option to true To control diode insertion, set the following application options: To specify a preference for fixing antenna violations by using diode insertion rather than layer hopping, set the route.detail.antenna_fixing_preference application option to use_diodes To require fixing of antenna violations by using diode insertion, disable layer hopping by setting the route.detail.hop_layers_to_fix_antenna application option to false By default, when you enable diode insertion, Zroute can fix an antenna violation either by adding a new diode or by using an existing spare diode. Zroute determines which method to use, based on which is closest to the required location: an empty location for a new diode or an existing spare diode. To specify a preference for using a new diode or using an existing spare diode, set the route.detail.diode_preference application option to new or spare respectively. To reset the diode preference to the default behavior, set the route.detail.diode_preference application option to none If you want Zroute to use only one of these methods, set the route.detail.diode_insertion_mode application option to new to force the insertion of new diodes or to spare to force the use of existing spare diodes. To reset the diode insertion method to the default behavior, set the route.detail.diode_insertion_mode application option to new_and_spare Note: To take advantage of spare diodes for antenna violation fixing, you need to add the spare diodes either before or after standard-cell placement and before routing the areas where antenna violations might occur. When inserting new diodes, Zroute selects the diodes from the reference libraries and inserts them into existing open spaces. To control which diodes are used, set the route.detail.diode_libcell_names application option. When you specify the diode library cells, use only the cell names. If you include the library name, the tool does not recognize the diode cells. By default, Zroute reuses existing filler cell locations for diode insertion. To prevent Zroute from reusing these locations, set the route.detail.reuse_filler_locations_for_diodes application option to false Zroute considers voltage areas when inserting diode cells and also observes the logic hierarchy assignments for diode cells. If a pin has an antenna violation, the diode cells are inserted at the same level of logic hierarchy as the violating pin. If a top-level port has an antenna violation, by default, the diode cells are inserted at the top level. However, if the port belongs to a voltage area, you can insert the diode cells in the logic hierarchy associated with the voltage area by setting the route.detail.use_lower_hierarchy_for_port_diodes application option to true To remove the redundant diodes during routing, set the route.detail.delete_redundant_diodes_during_routing application option to true"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Datapath Implementation"}, {"role": "assistant", "content": "Datapath extraction transforms arithmetic operators, such as addition, subtraction, and multiplication, into datapath blocks to be implemented by a datapath generator. This transformation improves the quality of results (QoR) by using carry-save arithmetic. Carry-save arithmetic does not fully propagate carries but stores results in an intermediate form. The carry-save adders are faster than the conventional carry-propagate adders because the carry-save adder delay is independent of bit-width. These adders use significantly less area than carry-propagate adders because they do not use full adders for the carry. The following example shows the code for the a * b + c + d = z expression. As shown in, the conventional implementation of the expression use three carry-propagate adders, whereas the carry-save arithmetic requires only one carry-propagate adder and two carry-save adders. The figure also shows the timing and area numbers for both implementations. module dp (a, b, c, d, e); input [15:0] a, b; input [31:0] c, d; output [31:0] Z; assign Z = (a * b) + c + d; endmodule Conventional Carry-Propagate Adder Versus Carry-Save Adder The tool supports extraction of the following components: Arithmetic operators that can be merged into one carry-save arithmetic tree Operators extracted as part of a datapath: *, +, -, >, <, <=, >=, ==,!=, and MUXes Variable shift operators (<<, >>, <<<, >>> for Verilog and sll, srl, sla, sra, rol, ror for VHDL) Operations with bit truncation The datapath flow can extract these components only if they are directly connected to each other, that is, no nonarithmetic logic between components. Keep the following points in mind: Extraction of mixed signed and unsigned operators is allowed only for adder trees Instantiated DesignWare components cannot be extracted"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Clock-Tree Layer Constraints"}, {"role": "assistant", "content": "To remove net-specific routing layer constraints, use the set_routing_rule -clear command. Note that when you use this command, it also removes any nondefault routing rules assigned to the specified nets."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Defining Routing Blockages"}, {"role": "assistant", "content": "Routing constraints provide guidance during routing. Table 29 describes the types of guidance provided by the routing constraints. Table 29 Routing Constraints Guidance Description onWireTrack onGrid physical_status locked Table 29 Routing Constraints (Continued) Guidance Description derive_metal_cut_route_guides"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Routing Rules for Clock Gates"}, {"role": "assistant", "content": "By default, clock gating optimization occurs automatically when you synthesize fhs design. You can, however, define settings to allow or prevent clock gating optimization on specific objects. The tool makes no distinction among clock gates. Every clock gate is subject to optimization, whether it is a preexisting or tool-inserted clock gate. The simplest way to restrict clock gating optimization is by using the set_dont_touch and set_size_only commands. These commands restrict all clock gating optimization by preventing removal, merging, and splitting of all clock gates. For a more refined approach, use the set_clock_gate_transformations command. With this command, you can set specific constraints on each integrated clock gate and control which operations can be performed on the clock gate. The set_clock_gate_transformations command provides the following options: -split_fanout Setting this option to false prevents fanout splitting even if the fanout is larger than the maximum allowed. This setting also prevents any splitting performed by placement- aware clock gating. -merge_equivalents Setting this option to true allows a clock gate to be merged with an equivalent clock gate. -collapse_levels Setting this option to false prevents redundant clock gates from being collapsed -ungate_fanout Setting this option to true specifies that the clock gate fanout remain ungated -reset Resets all clock gate settings for the whole design If the size_only or dont_touch attributes are set on a clock-gating instance or clock- gating library cell, these attributes take precedence over any of the constraints specified by the set_clock_gate_transformations command. Example Using Clock Gating Transformations For the example in, suppose you set the following restrictions: set_clock_gating_options -minimum_bitwidth 6 set_clock_gate_transformations [get_cells uicg_b*] true \\ -ungate_fanout false set_clock_gate_transformations [get_cells uicg_c*] false Example of Clock Gating Restrictions During optimization, the tool removes the uicg_a clock gate because of a minimum bitwidth violation (minimum bitwidth is 6). The uicg_b1 and uicg_b2 clock gates are merged (assuming they have an equivalent enable signal). Even though the minimum bitwidth is not met, ungating is not allowed, so the registers remain gated. The uicg_c1 and uicg_c2 clock gates do not allow any transformations, therefore no optimizations are performed for these clock gates."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Using Routing Guides to Prioritize Routing Regions"}, {"role": "assistant", "content": "By default, the maximum track utilization is 100 percent. You can use a routing guide to control the routing density within the routing guide boundary. To set the maximum track utilization for layers with a horizontal preferred direction, use the -horizontal_track_utilization option with the create_routing_guide command. To set the maximum track utilization for layers with a vertical preferred direction, use the -vertical_track_utilization option with the create_routing_guide command. By default, when you create these routing guides, they apply to all layers within the routing guide boundary. To set the routing density only for specific layers, use the -layers option to specify the affected layers. For example, to set a maximum track utilization of 50 percent for all layers with a horizontal preferred direction and a maximum track utilization of 30 percent for all layers with a vertical preferred direction within the rectangle with its lower-left corner at (0, 0) and its upper-right corner at (100, 100), use the following command: fc_shell> create_routing_guide -boundary {{0.0 0.0} {100.0 100.0}} \\ -horizontal_track_utilization 50 -vertical_track_utilization 30"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Routing With the Custom Router"}, {"role": "assistant", "content": "You use the custom.route.balance_mode application option in interposer designs to reduce the skews caused by wire length and via cut count differences. This topic describes how to set the custom.route.balance_mode application option and provides examples to demonstrate its use. To route using the balance mode: Set the custom.route.balance_mode application option to true. set_app_options -name custom.route.balance_mode -value true When custom.route.balance_mode is true: The Custom Router creates feedthrough routes between two \u03bcbumps and a C4 bump on the same net. The wire lengths between the \u03bcbumps and the C4 bump are equal. The number of via cuts is the same in all related \u03bcbump-C4 bump connections. Example 1 shows how the custom.route.balance_mode option is used when routing \u03bcbumps to a C4 bump. The designated routing layers are M1 through M5. The M2 and M4 layers are used for horizontal connections; and the M1, M3, and M5 layers are used for vertical connections. The number of via cuts and the array dimensions are also defined. Example 42 Routing with custom.route.balance_mode turned on create_routing_rule skew -widths {M1 6 M2 6 M3 6 M4 6 M5 25} -vias {{VIA12_1cut 3x3 R} {VIA23_1cut 3x3 R} {VIA34_1cut 3x3 R} {VIA45_1cut 2x5 R}} set_routing_rule $nets_to_route -rule skew -max_routing_layer M5 -min_routing_layer M1 set_attribute [get_layers \"M2 M4\"] routing_direction horizontal set_attribute [get_layers \"M1 M3 M5\"] routing_direction vertical set_ignored_layers -min_routing_layer M1 -max_routing_layer M5 set_app_options -list {custom.route.balance_mode true} route_custom -nets $nets_to_route The results from the example show that the wire lengths and the number of vias are the same in each of the four \u03bcbump-to-C4 bump connections."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Fixing DRC Violations Caused by Pin Access Issues"}, {"role": "assistant", "content": "The recommended flow for performing postroute logic optimization consists of multiple iterations of the route_opt command with different settings. However, you can reduce the number of postroute optimization iterations by using a single iteration of the hyper_route_opt command. The postroute optimization flow using the hyper_route_opt command consists of the following steps: 1. Enable different settings for postroute optimization using the same settings as for the route_opt command. For example, you can Specify the path-based analysis (PBA) mode by using the time.pba_optimization_mode application option Enable concurrent clock and data optimization by using the route_opt.flow.enable_ccd application option Enable power optimization by using the route_opt.flow.enable_power application option 2. (Optional) Specify settings for metal fill insertion, PG augmentation, and so on that should to be performed during the different stages of optimization and ECO routing within the hyper_route_opt command by using the snps_hyper_route_opt_post_eco Tcl-callback procedure. 3. (Optional) To improve the timing QoR, the hyper_route_opt command can debank sequential multibit registers. To enable this feature, set the route_opt.flow.enable_multibit_debanking application option to true. By default, the route_opt.flow.enable_multibit_debanking application option is set to false 4. Run postroute optimization using the hyper_route_opt command. 5. (Optional) Specify endpoints to target by using the set_route_opt_target_endpoints command and optimize these endpoints by using the route_opt command if there are any violating endpoints remaining after the hyper_route_opt command. 6. (Optional) Fix any remaining route DRC violations by using the route_detail -incremental command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Routing Application Options"}, {"role": "assistant", "content": "By default, Zroute can reroute nets as needed. You can prevent rerouting or limit rerouting to minor changes by setting the physical_status attribute on the nets. To freeze the net and prevent rerouting, set the attribute to locked To limit rerouting to minor changes, set the attribute to minor_change To allow Zroute to reroute the nets as needed, set the attribute to unrestricted For example, to prevent rerouting of the net1 net, which uses the default routing rule, use the following command: fc_shell> set_attribute -objects [get_nets net1] \\ -name physical_status -value locked"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Interior Tap Walls"}, {"role": "assistant", "content": "An exterior tap wall is a row or column of tap cells that is placed outside the boundary of a block, macro, or hard placement blockage. The tap cells in the tap wall are placed linearly without any gaps between cells. To insert an exterior tap wall, use the create_exterior_tap_walls command. You must specify the following information: The tap cell used in the tap wall (the -lib_cell option) By default, the command inserts the tap cells with R0 orientation. To place the cells with a different orientation, use the -orientation option. If the design has a FinFET grid, follow these guidelines when selecting the tap cell to ensure proper insertion of the tap wall: For horizontal tap walls, ensure that the cell's width in the specified orientation is an integer multiple of the x-pitch of the FinFET grid For vertical tap walls, ensure that the cell's height in the specified orientation is an integer multiple of the y-pitch of the FinFET grid By default, the tool uses the following naming convention for inserted tap cells: extTapWall__ library_cell_name _R _C number To identify the tap cells inserted in a specific run, use the -prefix option to specify a prefix string. When you use this option, the tool uses the following naming convention: prefix __ library_cell_name _R _C number The side along which to insert the tap wall (the -side option) You can specify only a single side, top bottom right, or left. To insert a tap wall on more than one side, run the command multiple times. The tap insertion region (the -bbox option) You specify the tap insertion region by specifying the lower-left and upper-right corners of its bounding box: -bbox {{ llx lly } { urx ury }} The bounding box must span a portion of the object's edge on the specified side along which to insert the tap wall. If the bounding box spans multiple edges along the specified side, the command inserts the tap wall along the longest edge. If the bounding box does not span any edges of the specified side, the command issues an error message. By default, a horizontal tap wall starts at the left edge of the specified bounding box and abuts the top or bottom boundary edge; a vertical tap wall starts at the bottom edge of the specified bounding box and abuts the left or right boundary edge. To specify margins for the tap wall insertion, use the -x_margin and -y_margin options. If the specified region, including the margins, is too small to fit a tap wall, the command does not insert tap cells. You should ensure that the insertion region does not contain any placement blockages, fixed cells, or macros. These obstructions can prevent the insertion of the tap cells and result in an incomplete or missing tap wall. When inserting the tap wall, the command does not honor the standard cell rows or sites and does not cross the object boundary. After insertion, the command fixes the placement of the inserted tap cells."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Creating Abstracts for Signal Electromigration Analysis"}, {"role": "assistant", "content": "To create an abstract that contains power information of the corresponding block, use the following steps at the block level: 1. Activate the scenarios for which you want to perform power analysis by using the -active true option of the set_scenario_status command and enable them for power analysis by using the following options: -dynamic_power true for dynamic power analysis -leakage_power true for leakage power analysis Power information is stored only for active scenarios that are enabled for dynamic or leakage power. 2. (Optional) Apply switching activity by either reading in a SAIF file with the read_saif command or annotating the switching activity information on the nets with the set_switching_activity command. For more information about applying switching activity, see Annotating the Switching Activity 3. Store the power information in the abstract by setting the abstract.annotate_power application option to true 4. Create the abstract for the block by using the create_abstract command. When you create an abstract with power information, the tool stores the power information only for the logic that is removed. When you instantiate such an abstract and perform power analysis at the top level, the tool Recomputes the power for the interface logic in the abstract, in context, based on the switching activity and loading seen at the top level Uses the stored power in the abstract for the logic that was removed when the abstract was created To report the power information in an abstract instantiated at the top level, use the report_power -blocks command. If there are multiple levels of physical hierarchy, to specify the number of level for which you want to report, use the -levels option."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Removing Repeater Groups"}, {"role": "assistant", "content": "To unplace the previous placement of repeaters, use the unplace_group_repeaters command. unplace_group_repeaters \\ -cells cell_list | -repeater_groups group_id_list [-lib_cell_input pin_name ] \\ [-lib_cell_output pin_name"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Physical Constraints for Placement and Legalization"}, {"role": "assistant", "content": "By default, the tool identifies preexisting clock-gating cells during the execution of the analyze and elaborate commands. During compile, the tool inserts one more level of clock-gating cells at the leaf level and implements clock-gating logic using the default clock-gating settings if you do not specify any clock-gating constraints. You cannot disable clock gating. Before you set up clock-gating constraints, load your design and libraries in memory and then use the following commands to set up the constraints: The set_clock_gate_style command To select the type of integrated clock-gating cell, specify the following options: Option Description -test_point none before after -observation_output -target pos_edge_flip_flop neg_edge_flip_flop -objects The set_clock_gating_options command To define the netlist structure of the inserted clock-gating cells, specify the following options: Option Description minimum_bitwidth max_fanout The set_clock_gating_objects command To control clock gating for specified objects and override the default clock-gating behavior that is set during compile, specify the following options. An object can be a hierarchical cell, register, power domain, or module. Option Description -include -exclude Option Description -clear -reset set_clock_gating_objects The default During clock-gating optimization, the tool uses the following setup defaults: Setup Default For more information, see Setting Up Clock Gating"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Using the create_tap_cells Command"}, {"role": "assistant", "content": "tap cell is a special nonlogic cell with a well tie, substrate tie, or both. These cells are typically used when most or all of the standard cells in the library contain no substrate or well taps. Generally, the design rules specify the maximum distance allowed between every transistor in a standard cell and a well or substrate tap. Before global placement (during the floorplanning stage), you can insert tap cells in the block to form a two-dimensional array structure to ensure that all standard cells placed subsequently comply with the maximum diffusion-to-tap distance limit. After you insert the tap cells, visually check to ensure that all standard-cell placeable areas are properly protected by tap cells. The Fusion Compiler tool provides two methods to insert a tap cell array: Insert the tap cell array based on the site rows and the maximum distance between tap cells To use this method, use the create_tap_cells command, as described in Using the create_tap_cells Command Insert the tap cell array using a specified offset and pitch, and optionally insert additional tap cells near the boundary To use this method, use the create_cell_array command, as described in Using the create_cell_array Command Advanced nodes often require the insertion of additional tap cells to manage the substrate and well noise. You can use the following capabilities to insert additional tap cells after standard tap cell insertion: Insertion of tap walls tap wall is a row or column of tap cells placed linearly without any gaps between cells. You can insert a tap wall outside or inside of the boundary of a block, macro, or hard placement blockage. A tap wall that is outside a boundary is called an exterior tap wall. A tap wall that is inside a boundary is called an interior tap wall To insert an exterior tap wall, use the create_exterior_tap_walls command, as described in Inserting Exterior Tap Walls To insert an interior tap wall, use the create_interior_tap_walls command, as described in Inserting Interior Tap Walls Insertion of tap meshes tap mesh is a two-dimensional array of tap cells with a tap cell in each mesh window. To insert a tap mesh, use the create_tap_meshes command, as described in Inserting Tap Meshes Insertion of dense tap arrays dense tap array is a tap cell array whose tap distance is smaller than the tap distance used by the create_tap_cells command. To insert a dense tap array, use the create_dense_tap_cells command, as described in Inserting Dense Tap Arrays"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Reporting Cell Spacing Constraints"}, {"role": "assistant", "content": "Cell spacing constraints control the spacing between a standard cell and another standard cell or a boundary (the chip boundary, a hard macro, a hard macro keepout margin, a hard placement blockage, or a voltage area guard band). You assign library cells to groups (the boundaries are in a predefined group named SNPS_BOUNDARY), and then define the required spacing between cells in these groups. By default, there are no spacing constraints between standard cells during legalization. To enhance yield, you can define the valid spacing between standard cells or between a standard cell and a boundary. Note: The support for spacing constraints between standard cells and power or ground nets depends on how the net is represented in the block. If the power or ground net is defined as a complete blockage, the legalizer and the check_legality command ignore spacing rule violations between standard cells and the power or ground net. If the power or ground net is defined as a partial blockage, the legalizer and the check_legality command check for spacing rule violations between standard cells and the power or ground net. Cell spacing constraints are implemented by attaching labels, which are similar to attributes, to the left and right sides of library cells, assuming that the cell is in its north orientation, and specifying the invalid spacings between these labels. To define cell spacing constraints, 1. Add labels to the library cells that have spacing constraints by using the set_placement_spacing_label command. You must specify the following information for each label: The label name (the -name option) The library cells to which to apply the label (the -lib_cells option) The sides of the library cells to which to apply the label (the -side option, which can take a value of right left, or both The label definitions are additive; you can specify the same label to be used on the right side of some cells and the left side of other cells. For example, to assign a label named X to the right side of the cellA library cell and the left side of the cellB and cellC library cells, use the following commands: fc_shell> set_placement_spacing_label -name X \\ -lib_cells {cellA} -side right fc_shell> set_placement_spacing_label -name X \\ -lib_cells {cellB cellC} -side left You can assign multiple labels to a side of a library cell. For example, to assign labels named Y and Z to the right side of the cellB library cell, use the following commands: fc_shell> set_placement_spacing_label -name Y \\ -lib_cells {cellB} -side right fc_shell> set_placement_spacing_label -name Z \\ -lib_cells {cellB} -side right 2. Define the spacing requirements between the labels by using the set_placement_spacing_rule command. You must specify the following information for each rule: The labels being constrained (the -labels option) You must specify exactly two labels in each set_spacing_label_rule comandcomandset_spacing_label_rule set_placement_spacing_rule command. You can specify any of the labels defined by the set_placement_spacing_label command or the predefined SNPS_BOUNDARY label, which includes the chip boundary, hard macro boundaries, a hard macro keepout margins, hard placement blockages, and voltage area guard bands. The two labels can be the same or different. The range of invalid spacings, in number of unit tiles For example, to specify that there must be at least one unit tile between labels X and Y (they cannot abut), use the following command: fc_shell> set_placement_spacing_rule -labels {X Y} {0 0} To specify that there must be at least one unit tile between X labels and any boundary, use the following command: fc_shell> set_placement_spacing_rule \\ -labels {X SNPS_BOUNDARY} {0 0} To specify that two X labels cannot have a spacing of two unit tiles, use the following command: fc_shell> set_placement_spacing_rule -labels {X X} {2 2} To specify that labels X and Z must have a spacing of less than two unit tiles or more than four unit tiles, use the following command: fc_shell> set_placement_spacing_rule -labels {X Z} {2 4} Caution: The cell spacing constraints are not saved with the block; they apply only to the current session and must be redefined in each session."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Voltage Hotspot Analysis"}, {"role": "assistant", "content": "When you use the RedHawk mesh add command to add virtual PG meshes in the top block for the current subblock, by default the virtual PG meshes created by the RedHawk mesh add command are not shown as layout objects in the GUI. Therefore, these GUI shapes cannot be queried using layout object collection commands (such as, get_shapes ), and are not saved to the design library when you save the block. To save ECO shapes along with rail results and display them in the GUI, enable the rail.display_eco_shapes application option, like set_app_options -name rail.display_eco_shapes -value true Note: The mesh add command is available only in RedHawk, not in RedHawk SC. Therefore, the tool issues an error message when you enable both the rail.enable_redhawk_sc and rail.display_eco_shapes application options. To display ECO shapes in GUI, you must first enable the RedHawk signoff license key by setting the rail.allow_redhawk_license_checkout application option to true. Otherwise, an error message is issued. To add virtual PG meshes and display the created ECO shapes in the GUI, 1. Prepare a script file (such as, mesh.tcl) that contains the mesh add command. 2. Run design setup with the mesh.tcl script file. fc_shell> set_rail_command_options -script_file mesh.tcl \\ -command setup_design -order after_the_command The tool generates the RedHawk script file and sources the mesh.tcl file after design setup. 3. Perform rail analysis using the following command: fc_shell> analyze_rail -nets -voltage_drop 4. Run the open_rail_result command to load the design data and analysis results. 5. Run the gui_start command to open the Fusion Compiler GUI. In the GUI layout window, choose View > Map and select the map to display. You can now display and query the ECO shapes that are created by the RedHawk mesh add command in the GUI. Script Examples The following script displays ECO shapes in the GUI by using the set_rail_command_option command. ## Open design ## open_block link_block ## Specify taps ## create_taps ## Specify RedHawk Fusion input files or variables ## set_app_options -name rail.enable_redhawk -value 1 set_app_options -name rail.redhawk_path -value set_app_options -name rail.disable_timestamps -value true set_app_options -name rail.display_eco_shapes -value true set_rail_command_options -script_file mesh.tcl -command \\ setup_design... ## Analyze## analyze_rail -voltage_drop... -nets {VDD VSS} ## Check GUI ## open_rail_result The following script displays ECO shapes in the GUI by using a RedHawk script. ## Open design ## open_block link_block ## Specify taps ## create_taps ## Specify RedHawk Fusion input files or variables ## set_app_options -name rail.enable_redhawk -value 1 set_app_options -name rail.redhawk_path -value set_app_options -name rail.disable_timestamps -value true set_app_options -name rail.display_eco_shapes -value true ## Analyze ## analyze_rail -voltage_drop... -nets {VDD VSS} -script_only ## Modify the script.tcl containing mesh add command ## analyze_rail -redhawk_script_file ## Check GUI ## open_rail_result"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Corner Type"}, {"role": "assistant", "content": "The Custom Router bus routing application options allow you to specify: Corner Type Intra-shield Placement Pin-Trunk Offset Trunk Splitting Tapoffs"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Using an IC Validator Parameter File"}, {"role": "assistant", "content": "Track-based metal fill insertion inserts metal and via fill by using a runset derived from the attributes and rules in the technology file to create fill shapes aligned to tracks. It does not use the runset specified by the signoff.create_metal_fill.runset application option. Track-based metal fill insertion offers the following benefits as compared to pattern-based metal fill insertion: Higher density Better control of density Well-balanced mask distribution for double-patterning layers To perform track-based metal fill insertion, set the -track_fill option of the signoff_create_metal_fill command to a value other than off. Track-based metal fill insertion supports three modes: Sparse This is the default mode. In this mode, track-based metal fill insertion skips one track between signal shapes and fill shapes. Dense To enable this mode, use the -fill_all_tracks true option. In this mode, track- based metal fill insertion does not skip tracks between signal shapes and fill shapes. Note: If your block uses double-patterning technology, using this option increases runtime if the block is not precolored. Mixed To use sparse mode for some layers and dense mode for other layers, you must set the appropriate parameters in a parameter file, as described in Using an IC Validator Parameter File During track-based metal fill insertion, the signoff_create_metal_fill command performs the following tasks: 1. Loads the block into the IC Validator tool, as described in Reading Blocks for Signoff Metal Fill Insertion 2. Removes existing metal and via fill By default, the command removes the metal and via fill from the entire block. For information about performing incremental metal fill insertion, see Incremental Metal Fill Insertion 3. Inserts metal and via fill in the empty regions By default, the command uses the design rules defined in the technology file to insert fill shapes on-track on all metal and via layers for the entire block. The fill shapes have a length of 5 microns and a width equal to the defaultWidth attribute defined for the layer in the technology file. You can modify the default behavior by using Application options set before running the signoff_create_metal_fill command: signoff.create_metal_fill.apply_nondefault_rules To enable the use of nondefault spacing rules in addition to the spacing rules defined in the technology file, set this application option to true Command options used with the signoff_create_metal_fill command: -track_fill foundry_node To enable foundry-specific design rules, use the appropriate foundry keyword with the -track_fill option. To see the list of supported keywords, use the following command: fc_shell> signoff_create_metal_fill -track_fill list -select_layers To restrict the layers on which to insert metal fill, use this option, as described in Specifying the Layers for Metal Fill Insertion -coordinates and -excluded_coordinates To restrict the regions on which to insert metal fill, use these options, as described in Specifying the Regions for Metal Fill Insertion Parameters set in the IC Validator parameter file: _fill_width _min_fill_length, and _max_fill_length To change the size of the fill shapes, set these parameters, as described in Using an IC Validator Parameter File 4. Removes floating via fill from the specified via layers and from the via layers associated with the specified metal layers Floating via fill is via fill that does not have both an upper and lower metal enclosure. 5. (Optional) Trims the metal fill for each layer to try to meet the maximum density threshold defined by the signoff.create_metal_fill.max_density_threshold application option The metal fill is trimmed only for those layers specified in the application option. If you do not set this option, the metal fill is not trimmed. 6. Saves the fill data in the design view By default, The IC Validator tool assigns a data type of 0 to the fill shapes To use different data type values, set the _fill_datatype and via _fill_datatype parameters in the IC Validator parameter file. The IC Validator tool does not set mask constraints on the fill shapes If your block uses double-patterning technology, use the -output_colored_fill true option to set mask constraints on the fill shapes. If your block uses double-patterning technology, use the -output_colored_fill option to set mask constraints on the fill shapes. When you use this option, the IC Validator tool assigns a data type of 235 for fill shapes with mask_one mask constraint and 236 for fill shapes with a mask_two mask constraint. To assign different data types for the colored fill, set the following parameters in the IC Validator parameter file: _fill_datatype_color1 via _fill_datatype_color1 _fill_datatype_color2, and via _fill_datatype_color2 The IC Validator tool does not write exclude layers If your foundry uses exclude layers, define the data types for the exclude layers by setting the _exclude_layer_datatype parameters in the IC Validator parameter file. The IC Validator tool outputs the exclude layers that have defined data types. For information about using an IC Validator parameter file, see Using an IC Validator Parameter File 7. Writes the result files to the run directory In addition to the standard output files generated by signoff metal fill insertion, when you perform track-based metal fill insertion, you can output detailed density and density gradient reports by using the -report_density option. When you enable this option, the signoff_create_metal_fill command writes the following report files: prefix _color_balance_and_density_report.txt prefix _fill_density_gradient_report.txt You can specify either on (in which case the tool uses \"track_fill\" as the prefix) or the prefix string. For example, to perform track-based metal fill insertion and use a prefix of my_prefix for the detailed density and density gradient reports, use the following command: fc_shell> signoff_create_metal_fill -track_fill true \\ -report_density my_prefix For information about the generated result files, see Signoff Metal Fill Result Files See Also Timing-Driven Metal Fill Insertion"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Datapath Extraction"}, {"role": "assistant", "content": "Datapath design is commonly used in applications that contain extensive data manipulation, such as 3-D, multimedia, and digital signal processing (DSP). By default, when you run the compile_fusion command, datapath optimization is enabled and both standard and DesignWare Foundation libraries are automatically linked. During datapath optimization, the tool performs the following tasks: Shares (or reverses the sharing) of datapath operators Uses the carry-save arithmetic technique Extracts the data path Performs high-level arithmetic optimization on the extracted data path Explores better solutions that might involve a different resource-sharing configuration Makes tradeoffs between resource sharing and datapath optimization Topics in this section Datapath Extraction Transforms arithmetic operators, such as addition, subtraction, and multiplication, into datapath blocks. Datapath Implementation Uses a datapath generator to generate the best implementations for the extracted components. Optimizing Datapaths"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Replacing Clock Gates"}, {"role": "assistant", "content": "To insert clock gating logic in an RTL design and to synthesize the design with the clock- gating logic, follow these steps: 1. Read the RTL design. 2. (Optional) Use the insert_dft command to insert test cells into the design. 3. Use the compile_fusion command to compile the design. During the compile process, the tool inserts clock gates on the registers qualified for clock-gating. By default, during clock-gate insertion, the compile_fusion command uses the clock gating default settings and also honors the setup, hold, and other constraints specified in the logic libraries. To override the setup and hold values specified in the library, use the set_clock_gating_check command before compiling the design. The default settings are suitable for most designs. The compile_fusion command automatically connects the scan enable and test ports or pins of the integrated clock-gating cells, as needed. 4. Use the report_clock_gating command to report the registers and the clock-gating cells in the design. Use the report_power command to get information about the dynamic power used by the design after clock-gate insertion. The following example illustrates a typical command sequence for clock using default settings: fc_shell> read_verilog design.v fc_shell> create_clock -period 10 -name CLK fc_shell> compile_fusion fc_shell> insert_dft fc_shell> report_clock_gating fc_shell> report_power"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Resolving Overlapping Voltage Areas"}, {"role": "assistant", "content": "To merge the voltage area shapes into a minimum set of disjoint shapes, use the -merge_regions option with the create_voltage_area create_voltage_area_shape or set_voltage_area command. When you use the create_voltage_area -merge_regions command, the merges the shapes specified with the -region option. When you use the create_voltage_area_shape -merge_regions command, the merges the shape specified with the -region option and the existing shapes of the specified voltage area. When you use the set_voltage_area -merge_regions command, the tool merges all existing shapes of the specified voltage area. The tool merges the voltage area shapes based on their stacking order. By default, the stacking order is the order in which you define the shapes, with the last shape defined on top. The merged shape replaces the top shape of a set of abutting or overlapping shapes; the other shapes in the set are removed and are no longer associated with the voltage area. For example, assume that you use the following command to create a voltage area comprising three rectangle shapes, as shown on the left side of fc_shell> create_voltage_area -power_domains {PD1} \\ -region { {{0 0} {10 10}} {{10 0} {30 10}} {{15 5} {35 15}} } {PD1} fc_shell> get_voltage_area_shapes -of_objects PD1 {VOLTAGE_AREA_SHAPE_1 VOLTAGE_AREA_SHAPE_2 VOLTAGE_AREA_SHAPE_3} After you use the -merge_regions option to merge these shapes, the voltage area consists of a single rectilinear shape, as shown on the right side of. The merged voltage area shape is named VOLTAGE_AREA_SHAPE_3, which was the last voltage area shape defined when the voltage area was created. fc_shell> set_voltage_area PD1 -merge_regions Information: Merging abutted and overlapping shapes in voltage_area 'PD1'. (NDMUI-154) fc_shell> get_voltage_area_shapes -of_objects PD1 {VOLTAGE_AREA_SHAPE_3} Merging Voltage Area Shapes To report the stacking order of the voltage area shapes, use the report_voltage_areas -verbose command. To modify the stacking order of the voltage area shapes, use the set_voltage_area_shape command, as described in Modifying the Stacking Order"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling Datapath Optimization"}, {"role": "assistant", "content": "You can control boundary optimization across user-specified logical boundaries and match the interface boundary of a physical block with the RTL module interface. Boundary optimization allows you to use RTL floorplanning DEF files during block implementation. The following figure shows how constants, equal-opposite logic, logic phase, and unloaded ports are propagated through the logical boundaries without and with boundary optimization. Constant propagation Phase inversion Unloaded propagation Equal-opposite logic propagation Disabled Enabled Disabled Disabled Disabled Enabled Enabled Enabled Disabled: without boundary optimization Enabled: with boundary optimization Global Control By default, all types of boundary optimization are enabled during compile. To control boundary optimization globally, use the compile.flow.boundary_optimization application option. When you set the compile.flow.boundary_optimization application option to false The tool disables propagation of equal-opposite logic and phase inversion. Constants and unloaded ports continue to propagate across hierarchies. To disable constant propagation and unloaded propagation globally, set the compile.flow.constant_and_unloaded_propagation_with_no_boundary_opt application option to false. The default is true. The setting does not affect object-level specifications. Controlling Specific Types of Boundary Optimization To control the level of boundary optimization for hierarchical cell pins, hierarchical cells, or blocks, use the set_boundary_optimization command. The tool uses the following order of precedence to determine the setting to use during optimization: 1. Setting applied on pins of hierarchical cell instances 2. Setting applied on hierarchical cell instances, which applies to its pins as well 3. Setting applied on modules, which applies to all its cells and pins as well The following table shows the level of boundary optimization you can specify with the set_boundary_optimization command and the types of boundary optimization that are enabled for each level. Table 20 Levels of Boundary Optimization and the Corresponding Types of Boundary Optimization Performed Level of boundary optimization Constant propagation Unloaded propagation Equal-opposite logic propagation Phase inversion all auto none You can control the specific types of boundary optimization allowed for an object by using the -constant_propagation -unloaded_propagation -equal_opposite_propagation, and -phase_inversion options. These options are mutually exclusive with the boundary optimization level specified by using all auto, or none and cannot be used on the same object in a single command invocation. If you use the set_boundary_optimization command multiple times on the same object, the effect is additive. Based on the types of boundary optimization you enable or disable, the tool sets the constant_propagation unloaded_propagation equal_opposite_propagation, and phase_inversion read-only attributes of the specified object to true or false. If you Enable all four types, the tool sets the boundary_optimization read-only attribute to true Disable at least one type, the tool sets the boundary_optimization read-only attribute to false To report boundary optimization settings, use the report_boundary_optimization command. To remove them, use the remove_boundary_optimization command. The following example Disables all boundary optimization for the U1 cell instance Disables equal-opposite logic propagation and phase inversion for the U2 cell instance Disables constant propagation and phase inversion for the U3/in1 cell pin fc_shell> set_boundary_optimization [get_cells U1] none fc_shell> set_boundary_optimization [get_cells U2] auto fc_shell> set_boundary_optimization [get_pins U3/in1] \\ -constant_propagation false fc_shell> set_boundary_optimization [get_pins U3/in1] \\ -phase_inversion false Controlling Phase Inversion To prevent boundary optimization from moving inverters across hierarchical boundaries, set the compile.optimization.enable_hierarchical_inverter application option to false. By default, the application option is set to true to allow phase inversion. This application option is only effective when boundary optimization is enabled."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Applying Required Settings for High Performance Cores"}, {"role": "assistant", "content": "To apply placement, legalization, routing, and extraction setting specific to 12 or 7 nanometer technology nodes, use the set_technology command with the -node 12 or -node 7 option. When using this command, perform the following steps before placement, optimization, and routing: 1. Load and link the design. 2. Apply the settings required for the technology nodes by using the set_technology -node command, as shown in the following example: fc_shell> set_technology -node 7 3. (Optional) Report the technology-node settings by using the set_technology -report_only command. 4. Apply your design-specific application option or command settings to override the generic setting of the set_technology command. When you save the design library with the save_lib command, the technology-node setting is saved. Note: After you specify a technology node with the set_technology command, you cannot change it. For more information about which ASIC technologies are supported by this command, contact Synopsys Support."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Clock Gate Efficiency Reporting"}, {"role": "assistant", "content": "A clock gate often has an enable signal that is a Boolean expression comprising of one or more of the following reference (or invariant) points: Hierarchical ports Sequential output pins Black box output pins To report the clock gate enable signal as a Boolean function, use the report_clock_gating_enable_condition command. You must specify a collection of clock gates to be reported."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Settings for Multivoltage Designs"}, {"role": "assistant", "content": "By default, the add_buffer_on_route command Adds buffers over all placement blockages, soft macros, and hard macros. To prevent buffers from being placed over specific macro cells, use the -dont_allow_insertion_over_cell option. Alternatively, you can prevent the buffers from being placed over all blockages and macro cells by using the -respect_blockages option. When you use this option, you can specify a list of macro cells over which buffers are allowed by using the -allow_insertion_over_cell option. Adds buffers on both global routed and detail routed nets. To add buffers only on nets that are global routed only, without assigned tracks or detail routing, use the -only_global_routed_nets option. Adds buffers at the lowest common level of hierarchy of the pins being driven by the buffers. To add the buffers on the highest possible level of hierarchy, use the -on_top_hierarchy option. Does not add buffers on a route segment if it is necessary to create new ports because of a difference in the logical and physical topology of the net. To add buffers on such route segments by creating new ports, use the -punch_port option."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Standard Filler Cell Insertion"}, {"role": "assistant", "content": "To ensure that all power nets are connected, you can fill empty space in the standard-cell rows with filler cells. The Fusion Compiler tool supports filler cells with and without metal and supports both single-height and multiheight filler cells. Filler cell insertion is often used to add decoupling capacitors to improve the stability of the power supply. Note: Before inserting filler cells, ensure that the block is legalized by using the check_legality command. The Fusion Compiler tool can select the filler cells to use based on An ordered list of filler cell references In the standard filler cell insertion flow, you specify an ordered list of filler library cells and the tool inserts the first cell that fits in each gap. If your technology requires specific filler cells abutting the standard cells, you can insert these required filler cells first, and then use standard filler cell insertion to fill the remaining space. For details about this method, see Standard Filler Cell Insertion Threshold-voltage rules In the threshold-voltage-based flow, the tool selects the filler cells by using user-defined insertion rules, which are based the threshold-voltage types of the cells that border the gap. This flow is typically used only for established foundry nodes. For details about this method, see Threshold-Voltage-Based Filler Cell Insertion"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Metal Fill"}, {"role": "assistant", "content": "Filler cells inserted by the Fusion Compiler tool have instance names that start with the string xofiller. To remove all the filler cells from a block, use the remove_cells command, as shown in the following example: fc_shell> remove_cells [get_cells xofiller*] If you used the standard filler cell insertion flow and want to remove only those filler cells with DRC violations, use the remove_stdcell_fillers_with_violation command, as described in Checking for Filler Cell DRC Violations"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Signoff ECO Flow"}, {"role": "assistant", "content": "Use this flow if your cell placement is fixed, and you can only change the metal and via mask patterns. This flow is recommended if you have taped out your design and you want to avoid the expense of generating a whole new mask set. To perform the freeze silicon ECO flow, your block must contain spare cells. You can add spare cells to a block, anytime during the design flow, by using one of the following methods: Manually instantiate spare cells, as described in Manually Instantiating Spare Cells Automatically add spare cells after placement by using the add_spare_cells command, as described in Automatically Adding Spare Cells Add programmable spare cells during the chip finishing stage by using the create_stdcell_fillers, as described in Adding Programmable Spare Cells The freeze silicon ECO flow consists of the following steps: 1. Enable ECO changes in the freeze silicon mode by setting the design.eco_freeze_silicon_mode application option to true 2. Update the design with the ECO changes by using one of the following methods: Using the eco_netlist command, as described in Making ECO Changes Using the eco_netlist Command Using netlist editing Tcl commands, as described in Making ECO Changes Using Netlist Editing Commands 3. Analyze the mapping of ECO cells to spare cells by using the check_freeze_silicon command. 4. Automatically map all the ECO changes to spare cells by using the place_freeze_silicon command or manually map each ECO cell to a specific spare cell by using the map_freeze_silicon command, as described in Placing and Mapping ECO Cells to Spare Cells 5. Update the routing by using the route_eco command, as described in Performing ECO Routing, or by manually rerouting the affected nets."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Using Automatic Floorplanning"}, {"role": "assistant", "content": "The read_def command extracts physical constraint information from DEF files and annotates it on the block. However, only the following physical constraints are extracted and annotated: Placement Area Port Locations Cell Locations Placement Blockages Site Rows Routing Tracks Placement Bounds Routing Blockages Preroutes To visually inspect the extracted physical constraints, use the layout view in the GUI. All physical constraints extracted from the DEF file are automatically added to the layout view. Placement Area Placement area is computed based on the site array information. Port Locations For each port with the location specified in the DEF file, the tool sets the location on the corresponding port in the block. Note: If the DEF file does not contain port-location information, the tool inherits the port locations from the locations of the pad cells, as described in. Example 1 DEF Port Location Information PINS 2 ; -Out1 + NET Out1 + DIRECTION OUTPUT + USE SIGNAL + LAYER M3 (0 0) (4200 200) + PLACED (80875 0) N; -Sel0 + NET Sel0 + DIRECTION INPUT + USE SIGNAL + LAYER M4 (0 0)(200 200) + PLACED (135920 42475) N; END PINS Ports with changed names and multiple layers are supported. Example 2 DEF Port Locations With Changed Names and Multiple Layers PINS 2 ; - sys_addr\\[23\\].extra2 + NET sys_addr[23] + DIRECTION INPUT +USE SIGNAL + LAYER METAL4 ( 0 0 ) ( 820 5820 ) + FIXED ( 1587825 2744180 ) N ; - sys_addr[23] + NET sys_addr[23] + DIRECTION INPUT + USE SIGNAL + LAYER METAL3 ( 0 0 ) ( 820 5820 ) + FIXED ( 1587825 2744180 ) N ; END PINS Example 3 DEF Port Orientation Information PINS 1; - OUT + NET OUT + DIRECTION INPUT + USE SIGNAL + LAYER m4 ( -120 0 ) ( 120 240 ) + FIXED ( 4557120 1726080 ) S ; END PINS Cell Locations For each cell with a location and the FIXED attribute specified in the DEF file, the tool sets the location on the corresponding cell in the block. Example 4 shows DEF macro location and orientation information, where the letters E and W denote east rotation and west rotation respectively. Example 4 DEF Cell Location Information COMPONENTS 2 ; - macro_cell_abx2 + FIXED ( 4350720 8160 ) E ; - macro_cell_cdy1 + FIXED ( 4800 8160 ) W ; END COMPONENTS Placement Blockages The read_def command imports hard, soft, and partial placement blockages defined in the DEF file. Note: DEF versions before version 5.7 did not support partial blockages. In addition, if your floorplanning tool creates a DEF file with DEF version 5.6, you need to manually add the #SNPS_SOFT_BLOCKAGE pragma to specify a soft blockage, as shown in Example 7 Example 5 DEF Hard Placement Blockage Information BLOCKAGES 50 ;... - PLACEMENT RECT ( 970460 7500 ) ( 3247660 129940 )... END BLOCKAGES Example 6 DEF Version 5.7 Soft Placement Blockage Information BLOCKAGES 50 ;... - PLACEMENT + SOFT RECT ( 970460 7500 ) ( 3247660 129940 ) ;... END BLOCKAGES Example 7 DEF Version 5.6 Soft Placement Blockage Information BLOCKAGES 50 ;... - PLACEMENT RECT ( 970460 7500 ) ( 3247660 129940 ) ; #SNPS_SOFT_BLOCKAGE... END BLOCKAGES Example 8 DEF Partial Placement Blockage Information BLOCKAGES 50 ;... - PLACEMENT + PARTIAL 80 RECT ( 970460 7500 ) ( 3247660 129940 ) ;... END BLOCKAGES Site Rows Site row information in the DEF file defines the placement area. Example 9 DEF Site Row Information ROW ROW_0 core 0 0 N DO 838 BY 1 STEP 560 0; Routing Tracks The track information in the DEF file defines the routing grid for designs based on standard cells. This information can be used during routing, and track support can enhance congestion evaluation and reporting to make it match more closely with the routing results. Example 10 DEF Routing Track Information TRACKS X 330 DO 457 STEP 660 LAYER METAL1 ; TRACKS Y 280 DO 540 STEP 560 LAYER METAL1 ; Placement Bounds If REGIONS defining bounds exist in the DEF file, the read_def command imports those placement bounds. Also, if any cells in the related GROUP are attached to the region, fuzzy cell matching occurs between these cells and the ones in the block.matched cells are attached to the bounds in the following ways: If there are regions in the block with the same name as in the DEF, the cells in the related group are attached to the region by the add_to_bound command in incremental mode. If the region does not exist in the block, it is created with the same name as in the DEF file by applying the create_bound command; matched cells in the related group are also attached. Example 11 DEF Placement Bound Information REGIONS 1 ; - c20_group ( 201970 40040 ) ( 237914 75984 ) + TYPE FENCE ; END REGIONS GROUPS 1 ; - c20_group cell_abc1 cell_sm1 cell_sm2 + SOFT + REGION c20_group ; END GROUPS Routing Blockages Routing blockages are extracted similar to the way that placement blockages are extracted. Preroutes The tool extracts preroutes that are defined in the DEF file. Example 12 DEF Preroute Information SPECIALNETS 2 ; - vdd + ROUTED METAL3 10000 + SHAPE STRIPE ( 10000 150000 ) ( 50000 * ) + USE POWER ;... END SPECIALNETS"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I 11"}, {"role": "assistant", "content": "Table 63 shows some of the key commands used to perform relative placement. Table 63 Relative Placement Commands Command Described in section create_rp_group remove_rp_groups add_to_rp_group remove_from_rp_group Table 63 Relative Placement Commands (Continued) Command Described in section set_rp_group_options remove_rp_group_options modify_rp_groups legalize_rp_groups check_rp_constraints report_rp_groups get_rp_groups write_rp_groups"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Performing Prechecks for Hierarchical Synthesis Flows"}, {"role": "assistant", "content": "The following script shows an example of the hierarchical synthesis flow: # Specify reference libraries set REF_LIBS ${std_cell}.ndm lappend REF_LIBS ${block_design}_etm.ndm create_lib -tech ${TECH_FILE} -ref_libs $REF_LIBS ${DESIGN_NAME} # Read the RTL design analyze -format verilog [list $rtl_list] elaborate ${DESIGN_NAME} #ETM.ndm in ref_lib is used to link cell instances set_top_module ${DESIGN_NAME} # Load UPF for ETM cell instance load_upf ${block_design}.upf -scope cell_instance # Read test model for ETM cell instance read_test_model ${block_design}.mapped.ctl... compile_fusion -to initial_opto # Query commands # List all macro cell instances get_cells -hierarchical -filter \"is_hard_macro == true\" # ref view name is \"timing\" for cell instances bound to ETM get_attribute ${CELL} is_etm_moded_cell"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Options for Signoff Design Rule Checking"}, {"role": "assistant", "content": "To perform signoff design rule checking by running the signoff_check_drc command, 1. Set up the IC Validator environment as described in Setting Up the IC Validator Environment 2. (Optional) Enable distributed processing by using the set_host_options command, as described in Enabling IC Validator Multicore Processing 3. Set the application options for signoff design rule checking. At a minimum, you must specify the foundry runset to use for design rule checking by setting the signoff.check_drc.runset application option. For information about the options for command-based signoff design rule checking, see Setting Options for Signoff Design Rule Checking 4. Save the block to disk. When you run signoff design rule checking, the IC Validator tool uses the on- disk information for the block, not the information in memory. To ensure accurate information, use the save_block command to save the current state of the block before running signoff design rule checking. 5. Run signoff design rule checking by using the signoff_check_drc command. By default, the signoff_check_drc command performs the following tasks: 1. Loads the block into the IC Validator tool, as described in Reading Blocks for Signoff Design Rule Checking 2. Performs signoff design rule checking, as described in Signoff Design Rule Checking 3. Generates an error data file and IC Validator results files, as described in Signoff DRC Results Files You can use the results files to view the violations in the error browser, as described in Using the Error Browser, or to perform automatic design rule fixing, as described in Automatically Fixing Signoff DRC Violations You can use the following methods to analyze the DRC violations reported by the signoff_check_drc command: View the violations in the error browser, as described in Using the Error Browser. View the density of violations in a heat map, as described in Viewing the Violations in an ICV Heat Map See Also Checking Signoff Design Rules Interactively in the GUI"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Don't Touch Settings"}, {"role": "assistant", "content": "You can restrict the optimization on portions of the clock network by specifying Don't touch settings These settings identify parts of the clock tree on which clock tree synthesis and optimization is not performed. You can use don't touch settings to prevent the modification of a clock network beyond a specific pin, the buffering of specific nets, or the sizing of specific cells. For information about defining don't touch settings, see Setting Don't Touch Settings Size-only settings These settings identify clock tree cells for which the tool can perform only cell sizing. Note that these cells can be moved, unless they have a placement status of fixed. For information about defining size-only settings, see Setting Size-Only Settings"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Via Ladder Candidates for Library Pins"}, {"role": "assistant", "content": "A via ladder is a stacked via that starts from the pin layer and extends into the upper routing layers. Using via ladders during optimization improves the performance and electromigration robustness of a design. The tool can automatically insert via ladders for cell pins on timing-critical paths during the compile_fusion and clock_opt commands. To perform via ladder insertion during preroute optimization, 1. Ensure that the via ladder rules are defined as described in Defining Via Ladder Rules 2. Specify the via ladders that can be used for specific library pins by using the set_via_ladder_candidate command, as described in Specifying Via Ladder Candidates for Library Pins 3. (Optional) Enable high-performance and electromigration via ladder insertion for critical paths by setting the opt.common.enable_via_ladder_insertion application option to true 4. (Optional) Enable the insertion of global-route-based via ladders on pins with via ladder constraints by setting the route.global.insert_gr_via_ladders application option to true 5. Perform optimization using the compile_fusion or clock_opt command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Useful Skew"}, {"role": "assistant", "content": "Changing clock latencies can balance the slack in successive timing path stages to optimize clock and data paths. This capability is called concurrent clock and data (CCD) optimization, which can reduce total negative slacks (TNS), worst negative slacks (WNS), area, and leakage power. In addition, it can improve correlation between physical synthesis and place-and-route."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Clock Drivers for Designs With Multiple Levels of"}, {"role": "assistant", "content": "Before you insert clock drivers, ensure that all clock tree synthesis settings, including clock routing rules, are specified. To perform clock tree synthesis and detail routing to build an H-tree style global clock tree, use the synthesize_multisource_global_clock_trees command. When building the H-tree, the tool tries to minimize the skew between the endpoints, which is essential for multisource clock tree synthesis. When you use this command to synthesize and detail route a global clock tree, you must specify The clock net to synthesize by using the -nets option. The library cells to use by using the -lib_cells option. You can specify both single- rail and dual-rail library cells. By default, the tool uses the Custom Router to route the H-tree structure and connect to the pins of the clock tree cells. If the Custom Router is unable to resolve all routing DRC violation when making pin connections, use the Zroute to make the pin connections by using the -use_zroute_for_pin_connections options. To stop the routes at the highest available metal layer close to the pin shape, use the -skip_pin_connections option. The following example synthesizes and detail routes a global clock tree for the clock net named clkA. fc_shell> synthesize_multisource_global_clock_trees \\ -nets [get_nets clkA] -lib_cells [get_lib_cells my_lib/CKBUF8X] \\ -use_zroute_for_pin_connections You can also use the synthesize_multisource_global_clock_trees command to only perform clock detail routing for an H-tree style clock structure that has already been synthesized. When doing so, you must specify The startpoint of the global clock structure, by using the -roots option. The endpoints of the global clock structure by using the -leaves option. The following example detail routes an existing H-tree style clock structure. The startpoint is the port named clk1 and the endpoints are the inputs of a group of mesh drivers. fc_shell> synthesize_multisource_global_clock_trees \\ -roots [get_ports clk1] -leaves [get_pins mesh_buf*/A] \\ -use_zroute_for_pin_connections When routing the H-trees, the tool uses the highest routing layers available, based on the routing rules specified for the clock nets. These same layers can contain prerouted nets such as power and ground nets. To prevent placing clock drivers under these preroutes, which can cause pin accessibility issues, the synthesize_multisource_global_clock_trees command creates temporary placement blockages for the preroutes on the same layers it uses for routing. After it completes routing, it removes these temporary placement blockages, as shown in the following example output.... Net: clk; Rule: htree_ndr; Min Layer: M8; Max Layer: M9... Information: Using routing H/V layer pair 'M9'/'M8' for net 'clk'. (CTS-659)... Converting metal shapes in horizontal layer M9 and vertical layer M8 into placement blockages. In total 703 placement blockages created.... Successfully deleted all temporary placement blockages and the cell map. If you specify multirow-height cells with the -lib_cell option of the synthesize_multisource_global_clock_trees command, the tool might not be able to place them due to the temporary placement blockages it creates for the preroutes. If so, you can prevent the tool from creating the temporary placement blockages by setting the cts.multisource.enable_pin_accessibility_for_global_clock_trees application option to false To remove a clock structure created by the synthesize_multisource_global_clock_trees command, use the remove_multisource_global_clock_trees command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Identifying Redundancies, Outliers, Equivalences, and Gaps in"}, {"role": "assistant", "content": "When a family of cells with the same function is ordered in terms of increasing drive strength, specific cell property values should be monotonically increasing or decreasing. For example, when a family is ordered in terms of increasing drive strength, the area of cells should be monotonically increasing, power should be increasing, and delay (for the same output load and input slew) should be decreasing. The following figure shows a monotonic distribution of cell area versus timing for a family of cells with the same function. Monotonic Distribution in Library Cell Family A cell is considered redundant if all its metrics, such as area, delay, power, and so on, are equal or worse than another cell, as shown in the following plot of cell area versus timing for a family of cells with the same function. Redundant Cell in Library Cell Family A cell is considered an outlier if its metrics has a very large deviation from the expected values, as shown in the following plot of cell area versus timing for a family of cells with the same function. Outlier Cell in Library Cell Family Cells are considered equivalent if all their properties are the same for all process, voltage, and temperature (PVT) values, as shown in the following plot of cell area versus timing for a family of cells with the same function. Equivalent Cells in Library Cell Family A gap is when there is a large difference between two successive drive strengths, as shown in the following plot of cell area versus timing for a family of cells with the same function. Gap in Library Cell Family"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Inserting Shields on the Nets"}, {"role": "assistant", "content": "To create a differential group or a differential pair for the nets, bundles, or topology edges, use the create_differential_group command. Custom Router pairs the closest pins, one from each net, and routes from a common gather point between the pins. The tool routes the net pair the closest to each other with the most similar routing patterns. You need to specify the following information: The name of the constraint group If you do not specify a name, the command names the constraint group differential_pair_ or differential_group_, where is a unique integer. By default, the command returns an error if the assigned name already exists. To delete the existing constraint group, use the -force option. The nets in the differential group To specify the nets included in the created group, use the -for option. If you specify two nets, the nets form a differential pair. If you specify three nets, the nets form a differential group. The constraints for the differential group To define the constraints that are applied per layer to the trunks and override any settings on the individual bits, use the options listed in Table 54 Table 54 Differential Group Constraints Option Constraint -twist_style diagonal none orthogonal -twist_interval -twist_offset -valid_layers -layer_spacings -layer_widths Option Constraint -shield_placement double_interleave half_interleave interleave outside (default): -gap The following example creates a differential pair for the prn and prp nets. The command names the differential pair differential_pair_0, because there is no name assigned to the different pair. No twist style is specified and the shield placement is set to default fc_shell> create_differential_group \\ -for [get_nets -physical_context {prn prp}] \\ -shield_placement default {differential_pair_0}"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Reverting Changes Made During Resizing"}, {"role": "assistant", "content": "You can resize a cell by using the size_cell command, as shown in the following example: fc_shell> size_cell U21 -lib_cell AND2X4 If you enable the freeze silicon mode by setting the design.eco_freeze_silicon_mode application option to true, by default, the size_cell command checks if a compatible spare cell is available within a distance of five times the unit site height before sizing the cell. If a compatible spare cell is not available, the tool does not size the cell. To control this distance, use the -max_distance_to_spare_cell option. To disable this feature, use the -not_spare_cell_aware option."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Generic ECO Flow for Timing or Functional Changes"}, {"role": "assistant", "content": "An engineering change order (ECO) is an incremental change made to a complete or nearly complete design. You can use ECOs to fix functional, timing, noise, and crosstalk violations without synthesizing, placing and routing the entire design. You can also use ECOs to implement late-arriving design changes while maintaining design performance. The following topics describe the various ECO flows supported in the Fusion Compiler tool, and tasks you perform in these flows: Generic ECO Flow for Timing or Functional Changes Freeze Silicon ECO Flow Signoff ECO Flow Incremental Signoff ECO Flow ECO Fusion Flow ECO Fusion Power Integrity Flow Manually Instantiating Spare Cells Automatically Adding Spare Cells Adding Programmable Spare Cells Making ECO Changes Using the eco_netlist Command Making ECO Changes Using Netlist Editing Commands Resizing Cells Adding Buffers on Nets Adding Buffers on Routed Nets Optimizing the Fanout of a Net Reporting Available Sites for Placing ECO Cells Identifying and Reverting Nonoptimal ECO Changes Placing ECO Cells Placing and Mapping ECO Cells to Spare Cells Updating Supply Nets for ECO Cells Recording the Changes Made to a Layout Performing Prerequisite Check for Group Repeater Insertion and Placement Adding a Group of Repeaters Querying Group Repeater Swapping Variant Cell Fixing Multivoltage Violations"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Constructing Faster Clock Tree to Specific Endpoints"}, {"role": "assistant", "content": "By default, the Fusion Compiler tool uses the default routing rule and any available routing layers to route the clock trees. You can specify the minimum and maximum routing layers for clock nets as described in Specifying the Routing Resources. These routing layer constraints are used during RC estimation, congestion analysis, and routing. To reduce the wire delays in the clock trees, you can use wide wires and higher metal layers instead. routing rulenondefault, defined Wide wires are represented by nondefault routing rules. To use nondefault routing rules on the clock nets, you must first define the routing rules and assign them to the clock nets as described in Using Nondefault Routing Rules"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Running and Placing Group Repeaters"}, {"role": "assistant", "content": "In the same variant cell group, the library cell variants differ from the master-variant only in mask color (or small geometry), while the timing data is same for these variants. The variant cell feature supports the following track_pattern mode siteId_based mode track_pattern mode To specify the first metal layer for track alignment checking in track_pattern mode, use the set_app_options -name eco.placement.first_track_alignment_layer -value name command. shows the cell group with two variants. Cell Group With Two Variants Based on the first track offset of library cells and the pitch value, you can define and derive the variant library cell types, which start from 0. shows variant type id definition. Variant Type id Definition You can detect the variant type id for target cell current location. You can also check if the current reference is legal or illegal. If it is not legal, select the legal reference from cell group and swap it. shows the check and swap with legal reference for target cell. Check and Swap With Legal Reference for Target Cell. siteId_based mode The variant mapping and flipped mapping information are defined in the cell group. Following is an example of the report_cell_groups command. shows the cell group definition for mapping id and flipped mapping id. Cell Group Definition for Mapping id and Flipped Mapping id There are two sub flows for siteId_based mode: 2-Variants and N-Variant. shows the 2-Variants and N-Variants sub flows in siteId_based mode 2-Variants and N-Variants Sub Flows in siteId_based Mode Each variant reference has both legal mapping id and flipped mapping id. shows the variant mapping and flipped mapping id. Variant Mapping and Flipped Mapping id For variant siteId, you can get the cycle and offset from site rows first, then use the cell placed location to do the calculation. shows the calculation for variant siteId Calculation for Variant siteId"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Setting Sequential Clock Gating Options"}, {"role": "assistant", "content": "Sequential clock gating is the process of extracting and propagating enable conditions from upstream or downstream sequential elements in the data path for the purpose of enabling clock gate insertion for additional registers. The Fusion Compiler tool supports fanin-based sequential clock gating, in which a register can be gated during a given clock cycle if all the registers in the transitive fanin did not change state in the previous clock cycle. To enable this feature, set the comple.clockgate.fanin_sequential application option to true (the default is false ). This feature requires the FC-New-Tech-Power license. and illustrate the general concept of fanin-based sequential clock gating. The circuit in has a register bank R1 whose transitive fanin consists of register bank R0. All registers in bank R0 share the same enable condition EN0 and all registers in both register banks are clocked by clock CLK. If in one clock cycle the registers in bank R0 are disabled (in other words, enable signal EN0 is 0), those registers do not change their values. Therefore, in the next clock cycle, the registers in bank R1 do not change their values and consequently they are candidates for clock gating. Before Clock Gating shows the clock-gate implementation. Clock gate CG1 is first inserted for register bank R0. The tool creates a new register RD1 to generate a delayed version of enable signal EN0. The delayed signal drives sequential clock gate SEQCG1 for register bank R1. After Clock Gating The Fusion Compiler tool implements several different clock-gating strategies as needed, based on analyzing the circuit. For example, if the fanin registers do not all have the same enable signals, the tool looks for common signals upstream from the enable signals and uses those signals as inputs to the inserted delay register. Sequential clock gates are inserted by the compile_fusion command. During the initial_map stage, the tool analyzes the local hierarchy of the registers and inserts clock gates as needed. During the logic_opto stage, the tool performs analysis across hierarchical boundaries and inserts additional clock gates as needed. The name of a clock gate inserted as a result of fanin-based sequential clock gating begins with the prefix seq_clock_gate_fi_. The rest of the name follows standard clock- gate naming conventions. If the tool inserts a delay register as a result of this feature, the register name begins with the prefix reg_seqcg_ followed by standard clock-gate naming conventions (in other words, the most common base name among the gated registers)."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Routing Signal Nets"}, {"role": "assistant", "content": "If the secondary power and ground pins have the appropriate attributes in the frame view, you can use Zroute to route the secondary power and ground pins. By default, Zroute performs four topology ECO iterations to fix secondary PG cluster fanout violations.The topology ECO iterations can be time consuming, so you can control the effort level, and therefore the runtime, by setting the route.detail.topology_eco_effort_level application option to one of the following values: off, which disables topology ECO; this is the default low, which peforms one topology ECO iteration medium, which peforms four topology ECO iterations high, which peforms eight topology ECO iterations For example, to connect the secondary power pins to the VDD1 net, run the following command: fc_shell> route_group -nets VDD1 The following example add new cells, which have secondary power and ground pins, to a block; logically connects the power and ground pins; and then connects the secondary power pins to the VDD2 net. fc_shell> add_buffer {TOP/U1001/Z} {libA/BUFHVT} \\ -new_cell_names mynewHVT fc_shell> add_buffer {TOP/U1002/Z} {libA/BUFHVT} \\ -new_cell_names mynewHVT fc_shell> legalize_placement fc_shell> connect_pg_net -automatic fc_shell> route_group -nets {VDD2}"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Running Tasks in Parallel"}, {"role": "assistant", "content": "To remove the multicore configurations defined by the set_host_options command, use the remove_host_options command. To remove all multicore configurations, use the -all option. To remove a specific multicore configuration, specify the configuration name with the -name option."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Reporting Multicore Configurations"}, {"role": "assistant", "content": "Distributed processing performs tasks in parallel by using multiple machines; each process uses its own process memory image. When using distributed processing, each parallel task is called a process. For the best performance during distributed processing, you should limit the number of processes to the number of available cores, which is the sum of the number CPUs times the number of cores per CPU for each host machine. The following commands support distributed processing configured by the set_host_options command: analyze_rail create_placement -floorplan signoff_check_drc signoff_fix_drc signoff_create_metal_fill signoff_fix_isolated_via When you configure distributed processing, you can specify one or more of the following settings: The job submission command (the -submit_command option) If you do not specify this option, the tool uses the rsh command to submit the parallel processes. The list of host machines (the host_names argument) The maximum number of processes (the -num_processes option) By default, the tool assigns a name to each configuration you define with the set_host_options command. To specify the configuration name, use the -name option. You use the configuration name to select the configuration to use for specific commands and to remove a configuration. For example, to specify a distributed processing configuration that uses the qsub command to submit the parallel processes, use the following command: fc_shell> set_host_options -name dp_config \\ -submit_command [list qsub -P bnormal -cwd]"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Generating Macro Models"}, {"role": "assistant", "content": "Memory and macro cells are used in designs with advanced process technologies to reduce memory usage and improve the rail analysis performance. Macro models are supported in both RedHawk Fusion and RedHawk-SC Fusion analysis flows. To learn about working with macro models, see the following topics: Generating Macro Models Creating Block Contexts"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Performing Automated Tap Insertion and H-Tree Synthesis"}, {"role": "assistant", "content": "To reduce skew variation, clock mesh structures require higher timing accuracy than traditional clock structures. Therefore, to analyze a clock mesh structures, use the analyze_subcircuit command, which performs transistor level circuit simulation for the clock mesh and back-annotates accurate timing information. Before you run the analyze_subcircuit command, you must Detail route the clock mesh net. Have a circuit-level model for each of the gates in your clock tree and a transistor model for each of the transistors in the circuit-level models. Have access to a SPICE simulator such, as NanoSim, FineSim, or HSPICE. For the analyze_subcircuit command, you must specify The clock mesh net you want to simulate by using the -net option. Alternatively, you can specify the sinks of the mesh net by using the -to option. If multiple clocks reach the net or the sinks you specify, use the -clock option to distinguish the clock you want to analyze. A name by using the -name option. This name is used to construct the circuit elements. It is also used in the name of the output files and the directory where the output is stored. Optionally you can specify an annotated transition on the clock port or the start point of your clock mesh. If you do so, the clock must be specified as propagated by using the set_propagated_clock command. When you run the analyze_subcircuit command, the tool performs the following steps: 1. Performs RC extraction and generates parasitic files. You can run extraction as a standalone step by using the -extraction option. 2. Generates SPICE files for simulating the clock mesh, using the parasitic files from the previous step as input. You can generate the SPICE files as a standalone step by using the -create_spice_deck option. When you do so, you can use parasitic files generated by a different extraction tool. If these parasitic files have a different naming convention, you can specify the appropriate file suffix by using the -spef_input_file_suffix and -rc_include_file_suffix options. 3. Runs SPICE simulation, using the SPICE files generated in the previous step as input. By default, the tool uses the NanoSim simulator. You can use the FineSim or HSPICE simulators by using the finesim or hspice setting with the -simulator option. You must specify the location of the circuit-level and transistor-level models by using the -driver_subckt_files and -spice_header_files options. You customize these settings by specifying different files for the maximum and minimum conditions within each scenario by using the -configuration option. You can run simulation as a standalone step by using the -run_simulation option. 4. Generates timing annotation files containing set_disable_timing set_annotated_delay, and set_annotated_transition commands, using the simulation results as input. For clock mesh nets, which have multiple drivers, the set_disable_timing command is used to disable all except one of the drivers, which is called the anchor driver. The annotated net delay arcs are defined from the anchor driver. You can generate the timing annotation files as a standalone step by using the -write_annotation option. 5. Applies the annotation files generated in the previous step. You can apply the annotation files as a standalone step by using the -apply_annotation option. If you want to run some of the steps of the mesh analysis flow, such as extraction or SPICE simulation, using other tools, you can do so and run the rest of the steps of the flow using the standalone options of the analyze_subcircuit command, following the same sequence. The following example analyzes the clock mesh net named clk_mesh using the HSPICE simulator. It customizes the simulation by using different files for the minimum and maximum conditions of each scenario. fc_shell> analyze_subcircuit -net clk_mesh \\ -driver_subckt_files max_spice_model \\ -spice_header_files header_file \\ -configuration { \\ {-scenario_name scenario1 \\ -max_driver_subckt_files max_file1 \\ -max_spice_header_files header_max1 \\ -min_driver_subckt_files min_file1 \\ -min_spice_header_files header_min1} \\ {-scenario_name scenario2 \\ -max_driver_subckt_files max_file2 \\ -max_spice_header_files header_max2 \\ -min_driver_subckt_files min_file2 \\ -min_spice_header_files header_min2}} -simulator hspice \\ -name clk_mesh_analysis"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Ideal Voltage Sources as Taps"}, {"role": "assistant", "content": "_scenario true set_app_options -name rail.generate_file_type -value python #Use user-defined test_def_files for DEF variable to match #with customized python set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files } create_rail_scenario -name func.ss_125c -scenario func.ss_125c set_rail_scenario -name func.ss_125c -voltage_drop dynamic create_rail_scenario -name func.ff_125c_ -scenario func.ff_125c set_rail_scenario -name func.ff_125c \\ -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py set_host_options -submit_protocol sge \\ -submit_command {qsub -V -notify -b y -cwd -j y \\ -P bnormal -l mfree=16G} # Enable IR-driven CCD analysis before running route_opt set_app_options -name opt.common.power_integrity -value true route_opt See Also Specifying RedHawk and RedHawk-SC Working Directories"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Adding Buffers at Specified Locations"}, {"role": "assistant", "content": "To add buffers in an exact configuration, specify the configuration of cells and their locations by using the -user_specified_buffers option. With the -user_specified_buffers option, you can add cells only on one net at a time. You can insert different types of buffers or inverter pairs by using this option, but you cannot combine both buffers and inverter pairs. For each cell you add, use the {instance_name library_cell_name x y layer_name... } format with the -user_specified_buffers option to specify the Instance name Library cell to use Coordinates of the exact location Layer at that location with an existing routing shape to connect to Instead of specifying the routing layer, you can have the tool automatically detect the closest routing shape to that location by using the -detect_layer option. The following example adds two cells named ECO1 and ECO2 on net n22. The ECO1 cell is of type BUF2, at location (100, 70), connecting to a routing shape on the M3 layer. The ECO2 cell is of type BUF4, at location (150, 70), also connecting to a routing shape on the M3 layer. fc_shell> add_buffer_on_route net22 \\ -user_specified_buffers {ECO1 BUF2 100 70 M3 ECO2 BUF4 150 70 M3}"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Defining Blockages That Allow Buffers Only"}, {"role": "assistant", "content": "To define partial blockages that allow relative placement cells only, specify the boundary, type ( -type allow_rp_only option), blockage percentage ( -blocked_percentage option), and optionally the name for the placement blockage. For example, to defines a partial blockage that allows relative placement cells only, with a maximum allowed cell density of 80 percent (a blocked percentage of 20), and enclosed by the rectangle with corners at (10, 20) and (100,200), use the following command: create_placement_blockage -name rp_only -type allow_rp_only \\ -boundary {10 20 100 200} -blocked_percentage 20 These blockages allows the tool to place relative placement groups, which are usually large structures, without disturbing the placement of other cells. After the tool places and legalizes the relative placement groups, you can remove these blockages and allow the tool to place other cells in them. Note: Relative-placement-cells-only blockages are honored during placement, but not during legalization, optimization, or clock tree synthesis."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Merging Voltage Area Shapes"}, {"role": "assistant", "content": "A voltage area is a physical placement area for the cells associated with a power domain. For multivoltage designs, the power domains are defined in the UPF specification. For single-voltage designs, the tool creates a default power domain when you read the Verilog netlist and associates it with a default voltage area, which comprises the core area of the block. The placer treats a voltage area the same as an exclusive move bound; it must place the cells in a voltage area within a specified region and it must place all other cells outside of the voltage area. Voltage areas can be rectangular or rectilinear. In addition, they can be disjoint, nested, or overlapping. For overlapping voltage areas, the effective shape of each voltage area is determined by the stacking order of the voltage area shapes. To define a voltage area, use the create_voltage_area command. When you define a voltage area, at a minimum, you must specify the power domains associated with the voltage area. To specify the power domains, use the -power_domains option. You can specify one or more power domains; however, all specified power domains must have the same primary supply net. If you specify a single power domain, the name of the voltage area is derived from the name of the power domain. If you specify multiple power domains, you must specify a name for the voltage area by using the -name option. A voltage area consists of one or more rectangular or rectilinear shapes, which can be abutted, disjoint, or overlapping. To define the boundaries of these shapes, use the -region option with the create_voltage_area command (if you are creating a new voltage area) or the create_voltage_area_shape command (if you are adding shapes to an existing voltage area). Note that you can specify one or more shapes when using the create_voltage_area command, but only a single shape in each create_voltage_area_shape command. To specify the boundary of a rectangle shape, use the following format to specify its lower-left and upper-right corners: {{ llx lly } { urx ury }} To specify the boundary of a rectilinear shape, use the following format to specify the coordinates of its vertices: {{ x1 y1 } { x2 y2 } { x3 y3 } { x4 y4 }...} If a voltage area consists of multiple abutting or overlapping shapes, you can merge the shapes into a minimum set of disjoint shapes based on the stacking order of the shapes. For information about how to merge the voltage area shapes, see Merging Voltage Area Shapes The tool also uses the stacking order to resolve overlapping shapes from different voltage areas. For information about resolving overlapping voltage areas, see Resolving Overlapping Voltage Areas To ensure that no shorts occur at the boundaries of the voltage areas, you can define guard bands for the voltage areas, which act as hard keepout margins surrounding the voltage areas. If you define guard bands for a voltage area shape, the guard bands are included in the effective boundary of the shape; however, they are not included in the effective placement area of the voltage area. For information about defining guard bands, see Defining Guard Bands To modify an existing voltage area, use the set_voltage_area command, as described in Modifying Voltage Areas Multivoltage designs typically have power domains that are shut down and powered up during the operation of the chip while other power domains remain powered up. When dealing with shutdown domains, there can be some situations in which certain cells in the shutdown portion need to continuously stay active, such as for implementing retention registers, isolation cells, retention control paths, and isolation enable paths. These cells are referred to as always-on cells. To define a special placement area for always-on cells (an always-on well) within a voltage area, define an exclusive move bound within the boundary of the voltage area. For information about defining exclusive move bounds, see Defining Move Bounds After creating the voltage areas, run the check_mv_design command to verify that the design does not have any multivoltage violations."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling Pin Tapering"}, {"role": "assistant", "content": "By default, Zroute connects a signal route to a pin by using wires or vias anywhere on the pin. To restrict the allowed types of pin connections on a per-layer basis, use the following syntax to set the route.common.connect_within_pins_by_layer_name application option: set_app_options -name route.common.connect_within_pins_by_layer_name -value { { layer mode }... } Valid values for the mode argument are off (the default) There are no restrictions on pin connections. via_standard_cell_pins Only the connections to standard cell pins by using a via are restricted. When using a via connection, the via's metal enclosure must be contained within the pin shape. There are no restrictions on signal routes connected to macro cell and pad cell pins by using a via or to any pins by using wires. via_wire_standard_cell_pins The connections to standard cell pins by using a via or a wire are restricted. When using a via connection, the via's metal enclosure must be contained within the pin shape. When using a wire, the wire must be contained within the pin shape. via_all_pins The connections to any pins (standard cell, macro cell, or pad cell) by using a via are restricted. When using a via connection, the via's metal enclosure must be contained within the pin shape. There are no restrictions on signal routes connected to any pins by using wires. via_wire_all_pins The connections to any pins by using a via or a wire are restricted. When using a via connection, the via's metal enclosure must be contained within the pin shape. When using a wire, the wire must be contained within the pin shape. For example, if you use the following command (or use the default settings), all of the connections shown in are valid and no DRC violations are reported: fc_shell> set_app_options \\ -name route.common.connect_within_pins_by_layer_name \\ -value {{M1 off}} Unrestricted Pin Connections If you set the mode for M1 to via_all_pins, as shown in the following example, the via enclosures must be inside the pin shape. The connections shown on the left side of are valid; however, the connections on the right side of the figure cause DRC violations. fc_shell> set_app_options \\ -name route.common.connect_within_pins_by_layer_name \\ -value {{M1 via_all_pins}} Restricted Via-to-Pin Connections No DRC Violations DRC Violations If you set the mode for M1 to via_wire_standard_cell_pins, as shown in the following example, both the via enclosures and wires must be inside the pin shape. The connections shown on the left side of are valid; however the connections on the right side of the figure cause DRC violations. fc_shell> set_app_options \\ -name route.common.connect_within_pins_by_layer_name \\ -value {{M1 via_wire_standard_cell_pins}} Restricted Via-to-Pin and Wire-to-Pin Connections DRC Violations No DRC Violations"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Summary Report for Automatic Design Rule Fixing"}, {"role": "assistant", "content": "If your block uses double-patterning technology, you must perform separate signoff DRC fixing runs for the non-double-patterning routing rules and the double-patterning routing rules. To perform automatic fixing of the signoff DRC violations for a block that uses double- patterning technology, 1. Perform automatic fixing for the non-double-patterning signoff DRC violations by using the process described in Automatically Fixing Signoff DRC Violations When you run the signoff_check_drc and signoff_fix_drc commands, use the -unselect_rules option to ignore the double-patterning rules during signoff design rule checking. fc_shell> signoff_check_drc -unselect_rules { list_of_dpt_rules Note: To determine the double-patterning rules for your technology, see the design rule manual (DRM) provided by your vendor. 2. Perform automatic fixing for the double-patterning odd-cycle violations by using the process described in Automatically Fixing Signoff DRC Violations Before you run the signoff_fix_drc command, set the signoff.fix_drc.custom_guidance application option to dpt fc_shell> set_app_options \\ -name signoff.fix_drc.custom_guidance -value dpt When you run the signoff_check_drc and signoff_fix_drc commands, use the -select_rules option to consider only the double-patterning rules during signoff design rule checking. fc_shell> signoff_check_drc -select_rules { list_of_dpt_rules 3. Perform signoff design rule checking to verify the results by using the process described in Performing Signoff Design Rule Checking"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Querying Voltage Areas"}, {"role": "assistant", "content": "Gas stations are small voltage areas that are created for the purpose of minimizing the use of dual-rail buffers on physical feedthrough paths. Only single-rail repeaters are allowed in gas stations, and only optimization steps can add cells to gas stations. You create gas stations by using the create_voltage_area command during the design planning stage. The tool recognizes gas stations automatically and uses them by trading off the cost of a routing detour with the cost of using a dual-rail cell. Use the -nwell and -pwell options of the create_voltage_area command to specify n-well and p-well supply nets for a voltage area. Defining well supplies for gas station voltage areas provides flexibility for using gas stations for different design styles. If you do not use these options for a voltage area, the well bias values are assumed to be the same as the domain supply values. The report_voltage_areas command lists the n-well and p-well supply nets regardless of whether they are explicitly set."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Tap Assignment Options and Settings"}, {"role": "assistant", "content": "To perform this task, you must 1. Specify the required settings by using the set_regular_multisource_clock_tree_options command as follows: The clock name by using the -clock option The topology for the global clock tree by using the -topology htree_only option The number of rows and columns of tap cells to insert by using the -tap_boxes option A list of library cells to use as tap drivers by using the -tap_lib_cells option The library cells you specify must be enabled for clock tree synthesis by using the set_lib_cell_purpose -include cts command. A list of library cells to use for synthesizing the global clock tree (H-tree) by using the -htree_lib_cells option The library cells you specify must be enabled for clock tree synthesis by using the set_lib_cell_purpose -include cts command. By default, the tool uses The net connected to the clock root to insert the tap drivers and build the clock structure You can specify a different net of the clock network by using the -net option. The locations of the sinks to determine the boundary within which to insert the tap cells You can control this boundary by using the -tap_boundary option. You can also specify keepout areas within which tap cells should not be inserted by using the -keepouts option. The layers and routing rules specified by the clock tree synthesis settings to route the H-tree You can specify the layers and routing rules for the H-tree by using the -htree_layers and -htree_routing_rule options. You can report the options you specified by using the report_regular_multisource_clock_tree_options command, and remove them by using the remove_regular_multisource_clock_tree_options command. 2. (Optional) Enable flexible H-tree synthesis by setting the cts.multisource.flexible_htree_synthesis application option to true When you enable this feature, the tool identifies the best count, configuration, and placement of tap drivers for minimum clock tree insertion delay. To specify that the tool derives a symmetric configuration of tap drivers, set the cts.multisource.tap_selection application option to symmetric. The default is user, and by default the tool uses the configuration specified by the -tap_boxes option of the set_regular_multisource_clock_tree_options command for the tap drivers. 3. Insert the tap drivers and build the H-tree by using the synthesize_regular_multisource_clock_trees command, which consists of the following two stages: tap_synthesis, during which the tool inserts the tap drivers htree_synthesis, during which the tool builds the H-tree that drives the tap drivers By default, the tool performs both stages. You can perform only one of these stages by using the -to or -from option. The following example script inserts tap drivers in four columns and two rows and builds the H-tree: ## Include only tap driver and H-tree library cell for CTS set cts_references [get_lib_cells -filter valid_purposes=~*cts*] set_lib_cell_purpose -exclude cts [get_lib_cells $cts_references] set_lib_cell_purpose -include cts { LIB1/BUF1 LIB1/BUF2} ## Set up and insert tap drivers and build H-tree set_regular_multisource_clock_tree_options \\ -clock clk -topology htree_only -tap_boxes {4 2} \\ -tap_lib_cells [get_lib_cells */CKBUF*] \\ -htree_lib_cells [get_lib_cells */CKINV*] \\ -htree_layers \"m9 m10\" -htree_routing_rule \"htree_ndr\" synthesize_regular_multisource_clock_trees ## Reapply CTS library cell list as required for the subsequent steps set_lib_cell_purpose -include cts [get_lib_cells $cts_references]"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Routing the Secondary Power and Ground Pins"}, {"role": "assistant", "content": "You can set routing constraints for secondary power and ground pin routing in the same way as for regular signal routing. For example, you can set constraints by Defining the minimum and maximum routing layers by using the set_routing_rule command For more information about using the set_routing_rule command, see Specifying Net-Specific Layer Constraints Specifying the preferred pin connections by setting the route.common.single_connection_to_pins and route.common.connect_within_pins_by_layer_name application options For example, to require a single connection to the secondary power and ground pins and require that the M1 connections use vias contained within the pin shapes, use the following command: fc_shell> set_app_options \\ -name route.common.single_connection_to_pins \\ -value standard_cell_pins fc_shell> set_app_options \\ -name route.common.connect_within_pins_by_layer_name \\ -value {{M1 via_standard_cell_pins}} Defining the maximum number of power or ground pins in a cluster by setting the route.common.number_of_secondary_pg_pin_connections application option A cluster is a set of connected secondary power or ground pins that has one connection to a PG strap or ring. By default, the value of this option is 0, which means that there is no limit on the number of secondary power or ground pins in a cluster. For example, to connect all secondary power and ground pins directly to a PG strap or ring, use the following command: fc_shell> set_app_options \\ -name route.common.number_of_secondary_pg_pin_connections \\ -value 1 Defining a nondefault routing rule for secondary power and ground pin routing For example, to define a nondefault routing rule named wideSVDD for wide M1 and M2 and set the nondefault routing rule on the VDD2 net, to which the secondary power and ground pins are connected, use the following commands: fc_shell> create_routing_rule wideSVDD -widths { M1 0.3 M2 0.3 } fc_shell> set_routing_rule -rule wideSVDD {VDD2} For more information about using nondefault routing rules, see Using Nondefault Routing Rules By default, the constraints apply to both the secondary power and ground connections and the tie-off connections. To separate these connections so that you can set constraints only for the secondary power and ground connections, set the route.common.separate_tie_off_from_secondary_pg application option to true"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Fixing Diodes"}, {"role": "assistant", "content": "The -buffer option of the fix_mv_design command fixes isolation violations and illegal library cells in buffer trees throughout the design. The command can perform the following changes: Minimize the number of dual-rail buffers or inverters Fix isolation violations in buffer trees Fix buffers and inverters that have illegal settings, as follows: Process, voltage, and temperature settings Library cell purpose or subset settings Target library subset settings Bias voltages Fix a mismatch between a buffer's power domain and the voltage area in which the buffer or inverter is physically placed The command can change the netlist as follows: Swap buffer library cells to fix illegal settings Swap single-rail buffers for dual-rail buffers Swap dual-rail buffers for single-rail buffers Change the backup supplies of dual-rail buffers and inverters Change the input or output supplies of level shifters Fix a mismatch between a buffer's power domain and a voltage area by using a physical or logical feedthrough Fix a mismatch between a buffer's power domain and a gas station voltage area by using a physical or logical feedthrough The fix_mv_design command keeps the placement of the original buffers or inverters and honors the repeater strategies associated with existing buffers and inverters. In addition, the command only uses supplies that are available in the voltage area or voltage area region. The fix_mv_design command does not insert isolation cells or level-shifter cells to fix existing isolation or voltage violations. Netlist changes caused by the command do not introduce new isolation or voltage violations. To specify a buffer tree, use the -from option with the name of a net or driver pin. If you specify a net name, its driver pin is used. In both cases, the driver pin defines a full or partial buffer tree. Wildcards are supported. The -lib_cells option specifies a list of single-rail and dual-rail buffer or inverter library cells that the fix_mv_design command can use as replacement cells. By default, the command does not swap dual-rail and single-rail cells if the swap is not necessary to fix isolation violations. However, if you also specify the -minimize_dual_rail option, the tool tries to minimize the usage of dual-rail buffers to save area. If the tool inserts a new library cell as a result of the fix_mv_design command, the new cell is chosen according to the following rules, in priority order: A cell from the same library as the original library cell A cell from a library with a name similar to the original library A cell with a name similar to the original library cell name By default, buffer trees stop at level-shifter cells. Specify the -level_shifter option to allow the fix_mv_design command to modify the input or output supplies of level-shifter cells. However, the command does not change level-shifter library cells. To report the changes that the tool recommends without making any netlist changes, use the -report_only option."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Reporting Cross-Probing Information for Optimized Registers"}, {"role": "assistant", "content": "To optimize the design by reducing area, the tool can automatically detect and remove constant registers and unloaded registers. You can control this behavior as described in the following topics: Removing Constant Registers Certain registers in a design might never change state because they have constant values on one or more input pins. These constant values can either be directly at the input or result from the optimization of fanin logic that eventually leads to a constant input of the register. Eliminating such registers can improve area significantly. By default, the compile_fusion command removes constant registers and prints an information message in the compile log file. This table lists cases in which a sequential element can be eliminated. Type of register Data Preset Reset Type of register Data Preset Reset To disable constant register removal for the entire block you are synthesizing, set the compile.seqmap.remove_constant_registers application option to false, changing it from its default of true. To control constant register removal for a specific cell or module, use the set_constant_register_removal command. For example, the following settings prevent the tool from removing the constant register named reg11: fc_shell> set_constant_register_removal reg11 false The following settings globally disables constant register removal for the entire block except for the module named sub5 : fc_shell> set_app_option -name compile.seqmap.remove_constant_registers -value false fc_shell> set_constant_register_removal [get_module sub5] true Information about removed constant registers is written to the verification guidance.svf file and the compile log file. To report the constant registers removed during compile, use the report_constant_registers command. Removing Unloaded Registers During optimization, the tool deletes registers with outputs that do not drive any load. The combinational logic cone associated with the input of the register can also be deleted if the cell is not used in the design. Register outputs can become unloaded because of redundancy in the circuit or as a result of constant propagation. In some designs where the registers have been instantiated, the outputs might already be unloaded. By default, the compile_fusion command removes unloaded registers in the design and prints an information message in the compile log file. To disable this capability for the block you are synthesizing, set the compile.seqmap.remove_unloaded_registers application option to false, changing it from its default of true. To control unloaded register removal for a specific cell or module, use the set_unloaded_register_removal command. For example, the following settings prevent the tool from removing the unloaded register named reg22: fc_shell> set_unloaded_register_removal reg22 false The following settings globally disables unloaded register removal for the entire block except for the module named sub5 : fc_shell> set_app_option -name compile.seqmap.remove_unloaded_registers -value false fc_shell> set_unloaded_register_removal [get_module sub5] true To report the unloaded registers that were removed during compile, use the report_unloaded_registers command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling Timing Optimization Effort"}, {"role": "assistant", "content": "To exclude a specific sink from concurrent clock and data optimization, 1. Apply a cts_fixed_balance_pin attribute on the sink pin by using the set_attribute command as shown in the following example: fc_shell> set_attribute -objects reg21/CK \\ -name cts_fixed_balance_pin -value true 2. Set the ccd.respect_cts_fixed_balance_pins application option to true These setting prevents the tool from adjusting the latencies of the sinks that have a cts_fixed_balance_pin attribute set to true. However, changes in the clock tree due to concurrent clock and data optimization performed on other sinks can change the latencies of the sinks that have a cts_fixed_balance_pin attribute set to true To prevent the tool from making any changes to the clock paths between the sinks that have a cts_fixed_balance_pin attribute set to true and the clock root, set the ccd.respect_cts_fixed_balance_pins application option to upstream instead of true This application option setting affects concurrent clock and data optimization performed during the place_opt clock_opt, and route_opt commands."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Running Interclock Delay Balancing"}, {"role": "assistant", "content": "The Fusion Compiler tool can automatically generate the interclock delay balancing constraints based on the timing relationships between the clocks. To automatically generate the interclock delay balancing constraints, use the following command: fc_shell> derive_clock_balance_constraints This command identifies clocks that have interclock timing paths and places them in the same balance group. After running this command, use the report_clock_balance_groups command to report the generated interclock delay balancing constraints, as described in Reporting Clock Balance Groups. If necessary, you can modify the clock balance groups as described in Defining the Interclock Delay Balancing Constraints By default, the tool considers all timing paths when identifying the timing relationships between the clocks. To consider only those timing paths with slack less than a specified value, use the -slack_less_than option with the derive_clock_balance_constraints command. For example, to generate interclock balancing constraints only for paths with slack less than -0.2 ns, use the following command: fc_shell> derive_clock_balance_constraints -slack_less_than -0.2 Assume you run this command on a block for which clock A has a timing relationship only with clock B and the worst negative slack (WNS) of this group of timing paths is -0.1 ns and clock C has a timing relationship only to clock D and the WNS of this group of timing paths is -0.3 ns. The command considers only those timing paths with slack less than -0.2 ns, so it defines a single balance group that contains clocks C and D. Clocks A and B are not constrained because the timing paths between them have slack greater than -0.2 ns."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I UPF Flows"}, {"role": "assistant", "content": "The UPF language establishes a set of commands to specify the low-power design intent for electronic systems. Using UPF commands, you can specify the supply network, switches, isolation, retention, and other aspects relevant to power management of a chip design. The same set of low-power design specification commands is to be used throughout the design, analysis, verification, and implementation flow. Synopsys tools are designed to follow the official IEEE 1801 UPF standard. The UPF language provides a way to specify the power requirements of a design, but without specifying explicitly how those requirements are implemented. The language specifies how to create a power supply network for each design element, the behavior of supply nets with respect to each other, and how the logic functionality is extended to support dynamic power switching to design elements. It does not contain any placement or routing information. In the UPF language, a power domain is a group of elements in the design that share a common set of power supply needs. By default, all logic elements in a power domain use the same primary supply and primary ground. Other power supplies can be defined for a power domain as well. A power domain is typically implemented as a contiguous voltage area in the physical chip layout, although this is not a requirement of the language. Each power domain has a scope and an extent. The scope is the level of logic hierarchy designated as the root of the domain. The extent is the set of logic elements that belong to the power domain and share the same power supply needs. The scope is the hierarchical level at which the domain is defined and is an ancestor of the elements belonging to the power domain, whereas the extent is the actual set of elements belonging to the power domain. Each scope in the design has supply nets and supply ports at the defined hierarchical level of the scope. A supply net is a conductor that carries a supply voltage or ground throughout a given power domain. A supply net that spans more than one power domain is said to be \"reused\" in multiple domains. A supply port is a power supply connection point between two adjacent levels of the design hierarchy, between the parent and child blocks of the hierarchy. A supply net that crosses from one level of the design hierarchy to the next passes through a supply port. supply set is an abstract collection of supply nets, consisting of two supply functions, power and ground. A supply set is domain-independent, which means that the power and ground in the supply set are available to be used by any power domain defined within the scope where the supply set was created. However, each power domain can be restricted to limit its usage of supply sets within that power domain. You can use supply sets to define power intent at the RTL level, so you can synthesize a design even before you know the names of the actual supply nets. A supply set is an abstraction of the supply nets and supply ports needed to power a design. Before such a design can physically implemented (placed and routed), its supply sets must be refined, or associated with actual supply nets. supply set handle is an abstract supply set created for a power domain. By default, a power domain has supply set handles for the domain's primary supply set, a default isolation supply set, and a default retention supply set. These supply set handles let you synthesize a design even before you create any supply sets, supply nets, and supply ports for the power domain. Before such a design can be physically implemented, its supply set handles must be refined, or associated with actual supply sets; and those supply sets must be refined so that they are associated with actual supply nets. power switch (or simply switch ) is a device that turns on and turns off power for a supply net. A switch has an input supply net, an output supply net that can be switched on or off, and at least one input signal to control switching. The switch can optionally have multiple input control signals and one or more output acknowledge signals. A power state table lists the allowed combinations of voltage values and states of the power switches for all power domains in the design. level shifter must be present where a logic signal leaves one power domain and enters another at a substantially different supply voltage. The level shifter converts a signal from the voltage swing of the first domain to that of the second domain. An isolation cell must be present where a logic signal leaves a switchable power domain and enters a different power domain. The level shifter generates a known logic value during shutdown of the domain. If the voltage levels of the two domains are substantially different, the interface cell must be able to perform both level shifting (when the domain is powered up) and isolation (when the domain is powered down). A cell that can perform both functions is called an enable level shifter In a power domain that has power switching, any registers that must retain data during shutdown must be implemented as retention registers. A retention register has a separate, always-on supply net, sometimes called the backup supply, which keeps the data stable in the retention register while the primary supply of the domain is shut down."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Reading Designs Using the -autoread Option"}, {"role": "assistant", "content": "Use the analyze and elaborate commands followed by the set_top_module command. The analyze command automatically creates HDL template libraries on disk based on the name of the library provided by the -hdl_library option. The location of the HDL template libraries is controlled by the hdlin.hdl_library.default_dirname application option. When the -hdl_library option is not specified, the default library name is WORK. To specify a different default library name, use the hdlin.hdl_library.default_name application option. Note: All of the application options that control the RTL reading behavior have the hdlin prefix. The elaborate command builds the module specified without linking the rest of the design. Design linking can be performed only after the entire design is in memory, so linking is not performed by the elaborate command. This allows multiple elaborate commands to be run before performing the single linking of the entire design. The top-level module must be one of the modules that is elaborated. Linking of the design and setting the top-level module is done using the set_top_module command. The top-level module is given as an argument to the set_top_module command. The top-level module must be a module that was previously elaborated with the elaborate command. The set_top_module command sets the specified module to be the top-level design, links the entire design, and creates a single block to be used for the remainder of the synthesis flow. The following script reads VHDL files using template libraries and creates a block called top. You do not need to specify the location of the template libraries on disk, which is automatically created by the analyze command based on the -hdl_library option. analyze -format vhdl -hdl_library BOT_HDL_LIB bot.vhd analyze -format vhdl -hdl_library MID_HDL_LIB mid.vhd analyze -format vhdl top.vhd elaborate top set_top_module top If the top-level design is analyzed to an HDL template library other than the default library, you should provide the HDL template library name for the top-level design using the -hdl_library option. For example, analyze -format vhdl -hdl_library BOT_HDL_LIB bot.vhd analyze -format vhdl -hdl_library MID_HDL_LIB mid.vhd analyze -format vhdl -hdl_library TOP_HDL_LIB top.vhd elaborate -hdl_library TOP_HDL_LIB top set_top_module top You can optionally specify the location of the HDL template libraries on disk by using the define_hdl_library command. For example, define_hdl_library BOT_HDL_LIB -path./TEMPLATES/BOT_HDL_LIB define_hdl_library MID_HDL_LIB -path./TEMPLATES/MID_HDL_LIB define_hdl_library WORK -path./TEMPLATES/WORK analyze -format vhdl -hdl_library BOT_HDL_LIB bot.vhd analyze -format vhdl -hdl_library MID_HDL_LIB mid.vhd analyze -format vhdl top.vhd elaborate top set_top_module top"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Sorting and Filtering the Data"}, {"role": "assistant", "content": "By default, the comparison tables show the QoR values for all runs. For example, the NVE number for the following run is 2374: To cycle through different display styles of the data, right-click anywhere in the table. You can view the data as a percentage delta against the baseline as an absolute delta against the baseline (shown in For example, as a percentage delta, the NVE number shows 2.7% fewer failing endpoints than the baseline: As an absolute delta, the NVE number shows 65 fewer failing endpoints than the baseline: See Also Sorting and Filtering the Data Exploring the Detailed Comparison Data"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Verifying Routing Corridors"}, {"role": "assistant", "content": "To assign nets and supernets to a routing corridor, use the add_to_routing_corridor command. You must specify the routing corridor and the nets or supernets to add to it. You can assign a net or supernet to only one routing corridor and that routing corridor must cover all pins connected to the associated nets. In addition, the supernets must belong to the same block as the routing corridor. For example, to define a routing corridor named corridor_a and assign the nets named n1 and n2 to this routing corridor, use the following commands: fc_shell> create_routing_corridor -name corridor_a \\ -boundary { {10 10} {20 35} } \\ -min_layer_name M2 -max_layer_name M4 fc_shell> create_routing_corridor_shape -routing_corridor corridor_a \\ -boundary { {20 25} {40 35} } \\ -min_layer_name M2 -max_layer_name M4 fc_shell> create_routing_corridor_shape -routing_corridor corridor_a \\ -boundary { {40 10} {50 35} } \\ -min_layer_name M2 -max_layer_name M4 fc_shell> add_to_routing_corridor corridor_a [get_nets {n1 n2}] Note: You can also assign nets or supernets to the routing corridor by using the -object option when you use the create_routing_corridor command to create the routing corridor."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Verifying the Clock Trees"}, {"role": "assistant", "content": "In some blocks, the clocks have endpoints that are structurally impossible to balance. The Fusion Compiler tool can automatically detect endpoints with balancing conflicts and derive an ignore pin to resolve the conflict. This capability is enabled by default for the synthesize_clock_trees and clock_opt commands. To disable this capability, set the cts.common.enable_auto_exceptions application option to false With this capability, the tool detects and fixes the following types of balancing conflicts: Internal sink pins of modules that have a combinational clock path If a module contains both internal sink pins and combinational clock paths, it is impossible to balance the internal sink pins. To resolve the balancing conflict, the tool defines the internal sink pins as ignore pins. For example, assume that you have a module that contains a combinational path in the clock network, as shown in figure (a) in, which is represented by the extracted timing model (ETM) shown in figure (b). Module With Combinational Clock Path Clk_out Clk (a) Netlist (b) ETM with check pin Clk Clk_out Clk_check_pin_1 Combinational delay In this case, the internal check pin inside the ETM has delays coming from the ETM timing library; these delays are considered by clock tree synthesis as sinks and are balanced with other sinks at the top level. If the path to the check pin is the shortest path, top-level clock tree synthesis cannot insert buffers on the shortest path and therefore leaves a large skew at the top level. Setting the internal check pin as an ignore pin resolves the skew issue coming from the ETM. Sink pins that cannot be balanced simultaneously If a block contains two clocks that drive common sinks, one of which is a clock pin that is the parent of another sink, due to a generated clock, it is impossible to simultaneously balance the parent and child clock pins with another common sink. To resolve the balancing conflict, the tool defines the parent clock pin as an ignore pin. For example, in, FF_gen/CLK and FF0_1-10/CLK are sinks of clkb, FF1_1-10/CLK and FF0_1-10/CLK are sinks of clka, and FF_gen/CLK is the parent of FF1_1-10/CLK. In this case, the tool defines FF_gen/CLK as an ignore pin for clkb to resolve the balancing conflict. Clock Pins That Cannot Be Balanced Simultaneously"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling the Adjustment of I/O Clock Latencies"}, {"role": "assistant", "content": "By default, the tool focuses on fixing setup violations during concurrent clock and data optimization. However, if your design has hold violations that are difficult to fix, you can increase the effort for hold fixing by setting the ccd.hold_control_effort application option to medium high, or ultra. The default is low Increasing the priority of hold violations reduces the number of setup violations that are fixed. Therefore, the hold priority should be increased only if the hold timing is critical. This setting affects concurrent clock and data optimization performed during the final_opt stage of the clock_opt command and the route_opt command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Defining Keepout Margins"}, {"role": "assistant", "content": "During placement and legalization, the floorplan information dictates where cells are placed. The following topics describe how to specify additional physical constraints that affect placement and legalization: Defining Keepout Margins Defining Area-Based Placement Blockages Defining Placement Bounds Defining Placement Attractions Specifying Locations for Unmapped Cells Defining Cell Spacing Constraints for Legalization"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Restricting the Target Libraries Used"}, {"role": "assistant", "content": "To ensure that the tool resize preexisting gates in the clock network during clock tree synthesis and optimization, you must specify equivalent cells as clock references. Not specifying a complete list of equivalent cells for preexisting gates can affect clock tree QoR. You can automatically derive equivalent cells for all the preexisting clock tree cells and specify them as clock references by using the derive_clock_cell_references command. When you run this command, the tool sets the valid_purpose attribute to true on equivalent library cells of the preexisting clock tree cells that are not buffers or inverters. This command does not derive equivalent library cells for preexisting buffers and inverters, Therefore, you must manually specify the buffers and inverters to use for clock tree synthesis, as shown in the following example: fc_shell> set_lib_cell_purpose -include cts \\ {tech_lib/clk_buf* tech_lib/clk_inv*} fc_shell> derive_clock_cell_references fc_shell> synthesize_clock_trees Instead of automatically specifying the equivalent library cells of the preexisting clock tree cells as clock tree references, you can generate a Tcl script that specifies the equivalent library cells of the preexisting clock tree cells as clock tree references. To do so, use the -output option. fc_shell> derive_clock_cell_references -output cts_leq_cells.tcl You can the output file, source it, and then run clock tree synthesis, as shown in the following example: fc_shell> set_lib_cell_purpose -include cts \\ {tech_lib/clk_buf* tech_lib/clk_inv*} fc_shell> source cts_leq_cells.tcl fc_shell> synthesize_clock_trees"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Optimizing Wire Length and Via Count"}, {"role": "assistant", "content": "After redundant via insertion, whether concurrent or postroute, Zroute generates a redundant via report that provides the following information: The via conversion rate for nondefault vias The via conversion rate for nondefault vias is listed at the top of the report as the total optimized via conversion rate. The optimized via conversion rate for each layer The optimized via conversion rate includes both double vias and DFM-friendly bar vias, which have a single cut but a larger metal enclosure. The tool reports two values for the via conversion rate: The total optimized via conversion rate This value is computed based on the total via count, which includes both fixed vias and routed vias. Fixed vias are vias that cannot be optimized by the router, such as unrouted vias and user-defined vias. The optimized via conversion rate based on the total routed via count This value is computed based only on the routed via count, which includes only those vias that can be optimized by the router. Note: The optimized via conversion rate is not useful if you are using bar vias. The distribution of optimized vias by weight for each layer To determine the via conversion rate for conversions above a certain weight, you must add the reported conversion rates for those weights. For example, in Example 29, the via conversion rate for weight 5 and above for layer V03 is 10.75+64.50=75.25%. Note: The conversion rate for unweighted vias is reported as \"Un-optimized.\" The total double via conversion rate for the block Note: The redundant via rate reported by the report_design command differs from the redundant via rate reported by Zroute during redundant via insertion or the check_routes command. This difference occurs because the report_design command reports the double via rate for both PG vias and signal vias, while Zroute reports the double via rate only for signal vias. In addition, Zroute bases the conversion rate only on the redundant via mapping. Example 29 shows an example of the redundant via report. Example 29 Redundant Via Report Total optimized via conversion rate = 96.94% (1401030 / 1445268 vias) Layer V01 = 41.89% (490617 / 1171301 vias) Weight 10 = 9.64% (112869 vias) Weight 5 = 32.25% (377689 vias) Weight 1 = 0.01% (59 vias) Un-optimized = 58.11% (680684 vias) Layer V02 = 76.20% (1567822/ 2057614 vias) Weight 10 = 43.51% (895270 vias) Weight 5 = 28.62% (588805 vias) Weight 1 = 4.07% (83747 vias) Un-optimized = 23.80% (489792 vias) Layer V03 = 81.87% (687115 / 839297 vias) Weight 10 = 64.50% (541369 vias) Weight 5 = 10.75% (90224 vias) Weight 1 = 6.62% (55522 vias) Un-optimized = 18.13% (152182 vias) Layer V04 = 81.60% (226833 / 277977 vias) Weight 10 = 81.45% (226418 vias) Weight 1 = 0.15% (415 vias) Un-optimized = 18.40% (51144 vias)... Layer V09 = 85.47% (1329 / 1555 vias) Weight 10 = 85.47% (1329 vias) Un-optimized = 14.53% (226 vias) Total double via conversion rate = 46.69% (2158006 / 4622189 vias)"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying Mapping Rules for Programmable Spare Cells"}, {"role": "assistant", "content": "For the freeze silicon ECO flow, place and map the ECO cells to spare cells by using the place_freeze_silicon command. By default, this command places and maps all ECO cells. To place and map specific ECO cells, use the -cells option. The following example places and maps the ECO cells named ECO1, ECO2, and ECO3: fc_shell> place_freeze_silicon -cells {ECO1 ECO2 ECO3} This command places each ECO cell and maps it to the nearest matching spare cell. Cells that are deleted as a result of the ECO changes are not removed from the design. They are converted to spare cells and remain in the design. When you use the place_freeze_silicon command, you can Place the ECO cells by the target spare cells, but not map them to the spare cells, by using the -no_spare_cell_swapping option This feature allows you to place the ECO cells and analyze the QoR before you map them. Map the spare cells that are already placed by the target spare cells by using the -map_spare_cells_only option. Generate an ECO cell to spare cell mapping file by using the -write_map_file command. You can the mapping file, if necessary, and map the ECO cells by using the map_freeze_silicon command. Specify a minimum distance between ECO cells that are mapped to programmable filler cells by using the -min_filler_distance option."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Removing Via Ladders"}, {"role": "assistant", "content": "To query the via ladders in a block, use the get_via_ladders command. To report on the via ladders in a block, use the report_via_ladders command."}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Specifying RedHawk and RedHawk-SC Working Directories"}, {"role": "assistant", "content": "To run RedHawk Fusion or RedHawk-SC Fusion features, enable the features and specify the location of the RedHawk or RedHawk-SC executable by setting the rail.product and rail.redhawk_path application options. For example, fc_shell> set_app_options -name rail.product -value redhawk|redhawk_sc fc_shell> set_app_options -name rail.redhawk_path \\ -value /tools/RedHawk_Linux64e5_V19.0.2p2/bin You must ensure that the specified executable is compatible with the Fusion Compiler version that you are using. See Also Specifying RedHawk and RedHawk-SC Working Directories"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Viewing Your Checkpoint History"}, {"role": "assistant", "content": "To return a list of all the checkpoints or checkpoint behaviors in the current session, or to return detailed information for any checkpoint or checkpoint behavior, use the get_checkpoint_data command. To return a list of all the checkpoints that have been executed, specify the -list_names option: fc_shell> get_checkpoint_data -list_names remove_buffers place_opt_to_initial_drc incr_placement place_opt_to_initial_opto place_opt_to_final_opto To return detailed information for a checkpoint, specify the checkpoint with the -name option. The tool returns the output as a Tcl dictionary: fc_shell> get_checkpoint_data -name place_opt_to_initial_drc memory 173.85 start_time 2.34 end_time 2.34 before_runtime 2.34 before_report_runtime 0.00 after_report_runtime 0.00 self_runtime 0.00 before_reports {} after_reports {app_options timing} before_actions {gropto} after_actions {} replace_actions {} To return a list of all the checkpoint behaviors defined in your configuration, specify the -list_reports or -list_actions option: fc_shell> get_checkpoint_data -list_reports timing app_options fc_shell> get_checkpoint_data -list_actions gropto placer_high_effort_congestion To return the contents and associations of a checkpoint report or action, specify the report or action with the -report or -action option: fc_shell> get_checkpoint_data -report app_options contents { set name [get_current_checkpoint -name] set pos [get_current_checkpoint -position] report_app_options -non_default \\ >./checkpoint/$name.$pos.app_options.rpt } before_patterns {*} after_patterns {} See Also Viewing Your Checkpoint History"}]}
{"messages": [{"role": "system", "content": "You are a chip design assistant. You should help the user to answer their question."}, {"role": "user", "content": "How do I Controlling Physical-Feedthrough Nets in Voltage Areas"}, {"role": "assistant", "content": "After you have created voltage areas, you can make the following modifications to a voltage area: Change the power domains associated with the voltage area To change the power domains associated with a voltage area, use the -add_power_domains and -remove_power_domains options with the set_voltage_area command. Change the voltage area name To change the name of the voltage area, use the -name option with the set_voltage_area command. Change the voltage area region To add shapes to a voltage area, use the create_voltage_area_shape command. To remove shapes from a voltage area, use the remove_voltage_area_shapes command."}]}
