{"instruction": "How do I Setting the Rerouting Mode", "input": "", "output": "By default, Zroute can reroute nets as needed. You can prevent rerouting or limit rerouting to minor changes by setting the physical_status attribute on the nets. To freeze the net and prevent rerouting, set the attribute to locked To limit rerouting to minor changes, set the attribute to minor_change To allow Zroute to reroute the nets as needed, set the attribute to unrestricted For example, to prevent rerouting of the net1 net, which uses the default routing rule, use the following command: fc_shell> set_attribute -objects [get_nets net1] \\ -name physical_status -value locked"}
{"instruction": "How do I Performing IR-Drop-Aware Placement", "input": "", "output": "During placement, the tool can use the voltage (IR) drop values of cells to identify areas of high power density and spread the cells with high voltage drop values, which reduces the power density of such areas. To perform IR-drop-aware placement, use the following steps: 1. Place and legalize the block. 2. Set up for RedHawk Fusion and perform static or dynamic voltage drop analysis by using the analyze_rail -voltage_drop command as shown in the following example: fc_shell> source redhawk_setup.tcl fc_shell> analyze_rail -voltage_drop static -nets {VDD VSS} For more information, see Performing Voltage Drop Analysis 3. Enable IR-drop-aware placement by setting the place.coarse.ir_drop_aware application option to true 159 Specifying Placement Settings Feedback 4. (Optional) Specify additional settings for IR-drop-aware placement, as described in Controlling IR-Drop-Aware Placement 5. Rerun placement. Note: To perform IR-drop-aware placement, you must have Digital-AF and SNPS_INDESIGN_RH_RAIL license keys."}
{"instruction": "How do I Avoiding Overlapping Repeaters With Existing Tap Cells", "input": "", "output": "Use the -honor_special_cell option to avoid overlapping with existing tap cells when inserting repeaters."}
{"instruction": "How do I Adding Leaf Cells", "input": "", "output": "To add leaf cells, including physical only cells, to a relative placement group, use the -cells option with the add_to_rp_group command. Specify the column and row position within the relative placement group at which to add the cell by using the -column and -row options. In a relative placement group, a leaf cell can occupy multiple column positions or multiple row positions, which is known as leaf cell straddling. To specify the number of columns and rows the cells occupies, use the -num_columns and -num_rows options respectively. If you do not set these options, the default is 1 for both the number of columns and rows. For example, to add a leaf cell that occupies two columns and one row at position (0,0), use fc_shell> add_to_rp_group rp1 -cells U23 \\ -column 0 -row 0 -num_columns 2 -num_rows 1 Straddling is for leaf cells only, and not for hierarchical groups or blockages. 785 Adding Objects to a Group Feedback"}
{"instruction": "How do I Synthesizing the Global Clock Trees", "input": "", "output": "Before you insert clock drivers, ensure that all clock tree synthesis settings, including clock routing rules, are specified. To perform clock tree synthesis and detail routing to build an H-tree style global clock tree, use the synthesize_multisource_global_clock_trees command. When building the H-tree, the tool tries to minimize the skew between the endpoints, which is essential for multisource clock tree synthesis. When you use this command to synthesize and detail route a global clock tree, you must specify The clock net to synthesize by using the -nets option. The library cells to use by using the -lib_cells option. You can specify both single- rail and dual-rail library cells. By default, the tool uses the Custom Router to route the H-tree structure and connect to the pins of the clock tree cells. If the Custom Router is unable to resolve all routing DRC violation when making pin connections, use the Zroute to make the pin connections by using the -use_zroute_for_pin_connections options. To stop the routes at the highest available metal layer close to the pin shape, use the -skip_pin_connections option. The following example synthesizes and detail routes a global clock tree for the clock net named clkA. fc_shell> synthesize_multisource_global_clock_trees \\ -nets [get_nets clkA] -lib_cells [get_lib_cells my_lib/CKBUF8X] \\ -use_zroute_for_pin_connections You can also use the synthesize_multisource_global_clock_trees command to only perform clock detail routing for an H-tree style clock structure that has already been synthesized. 413 Implementing Multisource Clock Trees Feedback When doing so, you must specify The startpoint of the global clock structure, by using the -roots option. The endpoints of the global clock structure by using the -leaves option. The following example detail routes an existing H-tree style clock structure. The startpoint is the port named clk1 and the endpoints are the inputs of a group of mesh drivers. fc_shell> synthesize_multisource_global_clock_trees \\ -roots [get_ports clk1] -leaves [get_pins mesh_buf*/A] \\ -use_zroute_for_pin_connections When routing the H-trees, the tool uses the highest routing layers available, based on the routing rules specified for the clock nets. These same layers can contain prerouted nets such as power and ground nets. To prevent placing clock drivers under these preroutes, which can cause pin accessibility issues, the synthesize_multisource_global_clock_trees command creates temporary placement blockages for the preroutes on the same layers it uses for routing. After it completes routing, it removes these temporary placement blockages, as shown in the following example output.... Net: clk; Rule: htree_ndr; Min Layer: M8; Max Layer: M9... Information: Using routing H/V layer pair 'M9'/'M8' for net 'clk'. (CTS-659)... Converting metal shapes in horizontal layer M9 and vertical layer M8 into placement blockages. In total 703 placement blockages created.... Successfully deleted all temporary placement blockages and the cell map. If you specify multirow-height cells with the -lib_cell option of the synthesize_multisource_global_clock_trees command, the tool might not be able to place them due to the temporary placement blockages it creates for the preroutes. If so, you can prevent the tool from creating the temporary placement blockages by setting the cts.multisource.enable_pin_accessibility_for_global_clock_trees application option to false To remove a clock structure created by the synthesize_multisource_global_clock_trees command, use the remove_multisource_global_clock_trees command. 414 Implementing Multisource Clock Trees Feedback"}
{"instruction": "How do I Aligning Leaf Cells Within a Column", "input": "", "output": "You can align the leaf cells in a column of a relative placement group by using the following alignment methods: Left alignment (default) Right alignment Pin alignment Controlling the cell alignment can improve the timing and routability of your design."}
{"instruction": "How do I Tool", "input": "", "output": "The Fusion Compiler tool provides a set of Tcl commands to run Custom Router in the Fusion Compiler environment. These commands define routing constraints for adding wires on one or more nets at the block level or adding differential pair routing, bus routing, shielding, and other routing features. A set of application options is also available for specifying the parameters for performing custom routing. For more information about how to define routing constraints and application options, see Defining Routing Constraints and Using Custom Routing Application Options The route_custom command uses the specified routing constraints, as well as information from the technology file and the design, to perform automatic routing using the Custom Router. For more information about using the route_custom command, see Routing With the Custom Router Custom Router supports the following constraints: Net shielding and differential pairs Matched length Variable width and space Pin width matching and tapering Custom Router supports the following Fusion Compiler nondefault routing rules: Routing layers and vias Routing width and spacing Routing grids Inter- and intra-group spacing Taper halo Routing blockage 747 Before Using Custom Router Feedback Routing corridors Shielding Figure 153 shows the basic Custom Router flow. Figure 153 Basic Custom Router Flow Define routing constraints Perform custom routing Block with routed power nets and unrouted clock trees Technology file with design rule definitions Perform postroute optimization Analyze routing results"}
{"instruction": "How do I Mapping ECO Cells to Specific Spare Cells", "input": "", "output": "To map an ECO cell to a specific spare cell, use the map_freeze_silicon command. Specify the ECO cell name and the corresponding spare cell name by using the -eco_cell and -spare_cell options. The following example maps the ECO cell named ECO1 to the spare cell named spare_1: fc_shell> map_freeze_silicon -eco_cell ECO1 -spare_cell spare_1 You can specify the ECO cell to spare cell mapping by using a map file and specifying this map file name by using the -map_file option with the map_freeze_silicon command. The map file has the following format: ECO_cell_1 spare_cell_1 ECO_cell_2 spare_cell_2...... 978 Updating Supply Nets for ECO Cells Feedback"}
{"instruction": "How do I Specifying Orientations for Leaf Cells", "input": "", "output": "You can specify orientations for leaf cells when you add them to a relative placement group. If you do not specify a leaf cell orientation, the tool automatically assigns a legal orientation for the leaf cells. To specify the orientation for leaf cells, use one of the following two methods: Use the -orientation option with a list of possible orientations when you add the cells to the group with the add_to_rp_group command. Set the rp_orientation attribute on leaf cells by using the set_attribute command. physopt_rp_enable_orient_opt variablevariablesphysopt_rp_enable_orient_opt The tool chooses one legal orientation from the list of orientations that you provide."}
{"instruction": "How do I Removing PG Augmentation Shapes", "input": "", "output": "To remove PG augmentation shapes, use the -mode remove option with the signoff_create_pg_augmentation command. When you use this command, the IC Validator tool removes all PG augmentation shapes from the current block."}
{"instruction": "How do I Creating Abstracts for Minimum Pulse Width Analysis", "input": "", "output": "In the top-level timing abstracts, the Fusion Compiler tool enables you to check minimum pulse width (MPW) violations. The tool retains the clock sinks with MPW violations including their fan-in cells and nets at the time of abstract creation. You can use the following application options to: Check and retain registers with MPW violations including their full clock path, set the abstract.keep_min_pulse_width_violation_pins application option to true The data paths to these registers are not retained. By default, this application is set to false Limit the MPW violations within a given slack limit, set the abstract.min_pulse_width_violation_slack_limit application option to the required slack. This helps to preserve MPW pins that might not be violating but have a slightly positive slack."}
{"instruction": "How do I Optimization", "input": "", "output": "A via ladder is a stacked via that starts from the pin layer and extends into the upper routing layers. Using via ladders during optimization improves the performance and electromigration robustness of a design. The tool can automatically insert via ladders for cell pins on timing-critical paths during the compile_fusion and clock_opt commands. To perform via ladder insertion during preroute optimization, 1. Ensure that the via ladder rules are defined as described in Defining Via Ladder Rules 2. Specify the via ladders that can be used for specific library pins by using the set_via_ladder_candidate command, as described in Specifying Via Ladder Candidates for Library Pins 3. (Optional) Enable high-performance and electromigration via ladder insertion for critical paths by setting the opt.common.enable_via_ladder_insertion application option to true 4. (Optional) Enable the insertion of global-route-based via ladders on pins with via ladder constraints by setting the route.global.insert_gr_via_ladders application option to true 5. Perform optimization using the compile_fusion or clock_opt command."}
{"instruction": "How do I Generating Via Ladder Rules for Performance Via Ladders", "input": "", "output": "Instead of explicitly defining via ladder rules for performance via ladders, you can use the setup_performance_via_ladder command to generate the via ladder rules and associations. By default, this command Generates via ladder rules for all layers up to the M5 layer To specify a different maximum layer, use the -max_layer attribute. 451 Inserting Via Ladders Feedback The command uses information from the technology file to generate the via ladder rules. The command derives the following information from the technology file: The cut layers that connect the specified metal layers The cut names The minimum required length for each metal layer Note: You must open the block before running the setup_performance_via_ladder command to ensure that the command has access to the technology data for the block. The command outputs an XML file that provides information about the via ladder rules and a script file that defines the via ladder rules. For details about these files, see Via Ladder Rule Files You can also generate these files by using the generate_via_rules_for_performance command. Associates via ladder rules with the pins of all library cells that do not have a dont_use attribute To include the pins of library cells that have a dont_use attribute, use the -dont_use option. To associate via ladder rules only with specific pins, use the -lib_pins option. The command analyzes the information about each library cell pin and its shapes to determine the via ladder rules to associate with that pin and then outputs a script file that defines the associations. For details about this file, see Via Ladder Association File You can also generate this file by using the associate_performance_via_ladder command. Runs the generated script files See Also Defining Via Ladder Rules Specifying Automatic Via Ladder Insertion Settings for Preroute Optimization 452 Inserting Via Ladders Feedback"}
{"instruction": "How do I Physical Hierarchy", "input": "", "output": "To insert clock drivers from the top level of a design with multiple levels of physical hierarchy, 1. Enable the lower-level physical blocks for editing by using the set_editability command. 2. Enable clock driver insertion for multiple levels of physical hierarchy by setting the cts.multisource.enable_mlph_flow application option to true 412 Implementing Multisource Clock Trees Feedback 3. Insert clock drivers by using the create_clock_drivers command. 4. Route the inserted clock drivers by using the synthesize_multisource_global_clock_trees -roots -leaves -use_zroute_for_pin_connections command. When inserting clock drivers to lower-level blocks, the tool reuses existing clock ports. If there are no existing clock ports, the tool creates new ports, if it is allowed. You can allow new ports to be added to a block by using use the set_freeze_ports command."}
{"instruction": "How do I Contents", "input": "", "output": "....................................... 321 Reporting Clock-Gate Enable Signals.................................. 323 Clock Gate Efficiency Reporting....................................... 323 Self-Gating Optimization............................................. 328 Self-Gating Flow................................................ 330 Library Requirements for Self-Gating................................331 Setting Up for Self-Gating........................................ 332 Setting Self-Gating Options.................................... 332 Controlling the Selection of Self-Gating Objects.................... 333 Reporting and Querying Self-Gating Cells............................ 333 Special Naming and Querying for DFT Wrapper Clock Gates................ 334 5. Clock Tree Synthesis.............................................. 338 Prerequisites for Clock Tree Synthesis..................................338 Defining the Clock Trees.............................................339 Deriving the Clock Trees......................................... 340 Identifying the Clock Roots.................................... 340 Identifying the Clock Endpoints................................. 342 Defining Clock Tree Exceptions.................................... 344 Defining Sink Pins........................................... 345 Defining Insertion Delay Requirements........................... 345 Defining Ignore Pins..........................................346 11 Contents Feedback Ensuring Clock Tree Exceptions are Valid.........................347 Restricting Optimization on the Clock Network........................ 349 Setting Don't Touch Settings................................... 349 Setting Size-Only Settings..................................... 350 Copying Clock Tree Exceptions Across Modes........................ 350 Deriving Clock Tree Exceptions From Ideal Clock Latencies..............351 Handling Endpoints With Balancing Conflicts......................... 352 Verifying the Clock Trees............................................ 354 Setting Clock Tree Design Rule Constraints............................. 356 Specifying the Clock Tree Synthesis Settings............................ 357 Specifying the Clock Tree References............................... 358 Deriving Clock Tree References for Preexisting Gates............... 358 Restricting the Target Libraries Used.............................359 Setting Skew and Latency Targets..................................360 Enabling Local Skew Optimization.................................. 360 Specifying the Primary Corner for Clock Tree Synthesis................. 361 Preventing Specific Clocks From Being Synthesized....................361 Preserving Preexisting Clock Trees................................. 361 Enabling Clock Tree Power Reduction Techniques..................... 361 Enabling Wire Length Aware Power-Driven Relocation.................. 362 Reducing Electromigration........................................ 362 Handling Inaccurate Constraints During Clock Tree Synthesis............ 363 Defining Clock Cell Spacing Rules..................................363 Creating Skew Groups........................................... 364 Defining a Name Prefix for Clock Cells.............................. 365 Using the Global Router During Initial Clock Tree Synthesis.............. 365 Specifying Constraints for Clock Nets............................... 365 Constructing Faster Clock Tree to Specific Endpoints................... 366 Improving Latency-Driven Clock-Gate Splitting........................ 368 Improving the Repeater Levels in Clock Tree......................... 368 Reducing Signal Integrity Effects on Clock Nets....................... 368 Specifying Settings for Clock Latency Adjustments......"}
{"instruction": "How do I Scaling CCD Offsets to New Scenarios for Reporting Timing", "input": "", "output": "To copy concurrent clock and data (CCD) offsets to the new scenarios for consistent timing or QoR reports, use the copy_useful_skew command. During CCD, when a pin's CTS balance point offsets are derived in only a subset of the active scenarios, use this command to copy the offsets to the in-active scenarios and active scenarios that do not have the CCD offsets. The copy_useful_skew command also ensures that the corresponding constraints of the set_clock_latency command are set on all the pins and scenarios, where a new offset value is computed. The average value of the offset is computed across all scenarios, where a balance point offset is defined. The average value is then scaled back in each active scenario using the scaling factor of the scenario corner."}
{"instruction": "How do I Specifying Library Cells as Repeaters", "input": "", "output": "Use the -lib_cell option to specify a library cell as a repeater. This option supports the following additional options: -lib_cell_input specifies the input pin of the library cell to connect, if it has multiple inputs. -lib_cell_output specifies the output pin of the library cell to connect, if it has multiple outputs."}
{"instruction": "How do I Setting Options for Signoff Design Rule Checking", "input": "", "output": "Before you run the signoff_check_drc command, configure the run by setting the application options shown in Table 43. To set the application options, use the set_app_options command. To see the current settings, use the report_app_options command. Table 43 Application Options for Signoff Design Rule Checking Application option Default Description signoff.check_drc.runset (required) N/A Specifies the foundry runset to use for design rule checking. signoff.check_drc. auto_eco_threshold_value 20 Specifies the maximum percentage of change to the block to perform incremental design rule checking using the -auto_eco true option. signoff.check_drc. excluded_cell_types {} Specifies the cell types to exclude from checking. You can specify one or more of the following values: lib_cell (standard cells), macro (macro cells), pad (I/O pad cells), and filler (filler cells). signoff.check_drc. fill_view_data read_if_uptodate Controls whether the IC Validator tool reads the fill data. By default, it reads the fill data only if its timestamp is newer than the timestamp of the design view. To read the fill data regardless of its timestamp, set this application option to ( read ). To never read the fill data, set this application option to discard signoff.check_drc. ignore_blockages_in_cells true Controls whether the IC Validator tool reads only the pin information from the frame view true ) or both the blockages and the pin information ( false ). signoff.check_drc. ignore_child_cell_errors false Controls whether the IC Validator tool reports both top-level and child-level errors to the error data file ( false ) or only top-level errors ( true ). signoff.check_drc. max_errors_per_rule 1000 Specifies the maximum number of errors to report per rule. signoff.check_drc. read_design_views {} Specifies the reference cells for which the IC Validator tool reads the design view instead of the frame view. Using the design view can expose problems that are masked by the frame view abstraction. 667 Performing Signoff Design Rule Checking Feedback Table 43 Application Options for Signoff Design Rule Checking (Continued) Application option Default Description signoff.check_drc. read_layout_views {} Specifies the reference cells for which the IC Validator tool reads the layout view instead of the frame view. Using the layout view can expose problems that are masked by the frame view abstraction. signoff.check_drc. run_dir signoff_check_drc_run Specifies the run directory, which contains the files generated by the signoff_check_drc command. You can specify either a relative path, in which case the directory is created under the current working directory, or an absolute path. signoff.check_drc. user_defined_options (none) Specifies additional options for the IC Validator command line. The string that you specify in this option is added to the command line used to invoke the IC Validator tool. The Fusion Compiler tool does not perform any checking on the specified string. signoff.physical. layer_map_file (none) Specifies the name of the layer mapping file. If the technology file and the foundry runset file used by the IC Validator tool do not use the same layer numbers, you must supply a layer mapping file to map the technology layers to the layers used in the runset file. For details about the format of the layer mapping file, see Defining the Layer Mapping for IC Validator In-Design Commands signoff.physical. merge_exclude_libraries (none) Specifies the cell libraries whose cells are excluded from replacement with the cell data in the stream files specified in the signoff.physical. merge_stream_files application option. signoff.physical. merge_stream_files (none) Specifies the stream (GDSII or OASIS) files to merge into the current block for signoff design rule checking. When you use this option, the GDSII or OASIS data replaces the cell library data for the cells defined in the specified stream files. 668 Performing Signoff Design Rule Checking Feedback"}
{"instruction": "How do I Performing Automated Tap Insertion and H-Tree Synthesis", "input": "", "output": "To perform this task, you must 1. Specify the required settings by using the set_regular_multisource_clock_tree_options command as follows: The clock name by using the -clock option The topology for the global clock tree by using the -topology htree_only option 425 Implementing Multisource Clock Trees Feedback The number of rows and columns of tap cells to insert by using the -tap_boxes option A list of library cells to use as tap drivers by using the -tap_lib_cells option The library cells you specify must be enabled for clock tree synthesis by using the set_lib_cell_purpose -include cts command. A list of library cells to use for synthesizing the global clock tree (H-tree) by using the -htree_lib_cells option The library cells you specify must be enabled for clock tree synthesis by using the set_lib_cell_purpose -include cts command. By default, the tool uses The net connected to the clock root to insert the tap drivers and build the clock structure You can specify a different net of the clock network by using the -net option. The locations of the sinks to determine the boundary within which to insert the tap cells You can control this boundary by using the -tap_boundary option. You can also specify keepout areas within which tap cells should not be inserted by using the -keepouts option. The layers and routing rules specified by the clock tree synthesis settings to route the H-tree You can specify the layers and routing rules for the H-tree by using the -htree_layers and -htree_routing_rule options. You can report the options you specified by using the report_regular_multisource_clock_tree_options command, and remove them by using the remove_regular_multisource_clock_tree_options command. 2. (Optional) Enable flexible H-tree synthesis by setting the cts.multisource.flexible_htree_synthesis application option to true When you enable this feature, the tool identifies the best count, configuration, and placement of tap drivers for minimum clock tree insertion delay. To specify that the tool derives a symmetric configuration of tap drivers, set the cts.multisource.tap_selection application option to symmetric. The default is user, and by default the tool uses the configuration specified by the -tap_boxes option of the set_regular_multisource_clock_tree_options command for the tap drivers. 426 Implementing Multisource Clock Trees Feedback 3. Insert the tap drivers and build the H-tree by using the synthesize_regular_multisource_clock_trees command, which consists of the following two stages: tap_synthesis, during which the tool inserts the tap drivers htree_synthesis, during which the tool builds the H-tree that drives the tap drivers By default, the tool performs both stages. You can perform only one of these stages by using the -to or -from option. The following example script inserts tap drivers in four columns and two rows and builds the H-tree: ## Include only tap driver and H-tree library cell for CTS set cts_references [get_lib_cells -filter valid_purposes=~*cts*] set_lib_cell_purpose -exclude cts [get_lib_cells $cts_references] set_lib_cell_purpose -include cts { LIB1/BUF1 LIB1/BUF2} ## Set up and insert tap drivers and build H-tree set_regular_multisource_clock_tree_options \\ -clock clk -topology htree_only -tap_boxes {4 2} \\ -tap_lib_cells [get_lib_cells */CKBUF*] \\ -htree_lib_cells [get_lib_cells */CKINV*] \\ -htree_layers \"m9 m10\" -htree_routing_rule \"htree_ndr\" synthesize_regular_multisource_clock_trees ## Reapply CTS library cell list as required for the subsequent steps set_lib_cell_purpose -include cts [get_lib_cells $cts_references]"}
{"instruction": "How do I Performing Metal Fill Insertion", "input": "", "output": "You can use the signoff_create_metal_fill command to perform the following tasks: Pattern-Based Metal Fill Insertion Track-Based Metal Fill Insertion Using an IC Validator Parameter File Typical Critical Dimension Metal Fill Insertion Timing-Driven Metal Fill Insertion Incremental Metal Fill Insertion Foundry Fill and Track Fill Combined for Different Flows of Foundry"}
{"instruction": "How do I Controlling High-Fanout-Net Synthesis", "input": "", "output": "The tool performs high-fanout-net synthesis during the initial_drc stage of the compile-fusion command. To use globally routed nets to determine the topology for the buffers inserted during high-fanout synthesis, set the compile.initial_drc.global_route_based application option to true. After high- fanout synthesis, which is performed during the DRC fixing stage of the compile_fusion command, the global routes are deleted. Global-route-based buffering benefits designs with high congestion in routing channels such as the channels between banks of macros. This feature increases the runtime of the compile_fusion command. Therefore, you should enable it only for designs with highly congested routing channels."}
{"instruction": "How do I Contents", "input": "", "output": "...............412 Synthesizing the Global Clock Trees................................ 413 Inserting Clock Drivers for Designs With Multiple Levels of Physical Hierarchy...................................................415 Creating Clock Straps............................................415 Routing to Clock Straps.......................................... 419 Analyzing the Clock Mesh........................................ 423 Performing Automated Tap Insertion and H-Tree Synthesis.............. 425 Specifying Tap Assignment Options and Settings...................... 427 Building the Local Clock Subtree Structures.......................... 429 Analyzing the Clock Tree Results......................................432 Generating Clock Tree QoR Reports................................ 432 Reporting Clock Tree Power...................................... 435 Creating Collections of Clock Network Pins...........................436 Analyzing Clock Timing.......................................... 436 Analyzing Clock Trees in the GUI.................................. 437 6. Routing and Postroute Optimization..................................438 Introduction to Zroute............................................... 439 Basic Zroute Flow.................................................. 441 Prerequisites for Routing.............................................442 Defining Vias...................................................... 443 Reading Via Definitions from a LEF File............................. 444 Creating a Via Definition..........................................444 Defining Simple Vias......................................... 444 Defining Custom Vias.........................................445 14 Contents Feedback Inserting Via Ladders............................................... 446 Defining Via Ladder Rules........................................ 447 Generating Via Ladder Rules for Electromigration Via Ladders............449 Generating Via Ladder Rules for Performance Via Ladders.............. 451 Via Ladder Rule Files.........................................453 Via Ladder Association File.................................... 453 Constraint-Based Via Ladder Insertion...............................454 Defining Via Ladder Constraints....................................455 Defining Global Via Ladder Constraints...........................455 Defining Instance-Specific Via Ladder Constraints.................. 456 Inserting Via Ladders............................................ 457 Protecting Via Ladders........................................... 459 Verifying Via Ladders............................................ 460 Updating Via Ladders............................................ 461 Manual Via Ladder Insertion.......................................463 Querying Via Ladders............................................464 Removing Via Ladders........................................... 464 Checking Routability................................................ 464 Routing Constraints.................................................469 Defining Routing Blockages....................................... 471 Reserving Space for Top-Level Routing.......................... 473 Querying Routing Blockages................................... 473 Removing Routing Blockages"}
{"instruction": "How do I Performing Signoff Design Rule Checking", "input": "", "output": "IC Validator In-Design signoff design rule checking (DRC) runs the IC Validator tool within the Fusion Compiler tool to check the routing design rules defined in the foundry signoff runset. You can perform signoff design rule checking by Running the signoff_check_drc command Using the Live DRC feature in the Fusion Compiler GUI After place and route, use the signoff_check_drc command to perform signoff design rule checking on the entire block. After engineering change orders (ECO), use either method to perform incremental signoff design rule checking on the modified portions of the block. See Also Automatically Fixing Signoff DRC Violations"}
{"instruction": "How do I Checking the Routing Results", "input": "", "output": "After running Custom Router to perform custom routing on the nets, you can check the routing results by reporting the routing results, generating a congestion map, running DRC checks, and so on. For more information about the tasks to check the routing results, see Analyzing the Routing Results"}
{"instruction": "How do I Preserving Preexisting Clock Trees", "input": "", "output": "When you perform clock tree synthesis, by default, the tool removes all preexisting clock buffers and inverters. You can prevent this by setting the cts.compile.remove_existing_clock_trees application option to false To preserve specific preexisting clock buffers or inverters, apply a don't touch or size-only exception on them."}
{"instruction": "How do I Contents", "input": "", "output": "............... 369 Timing Driven Sink Transition Target................................ 370 Reporting the Clock Tree Settings.................................. 370 Implementing Clock Trees and Performing Post-CTS Optimization............ 370 Performing Standalone Clock Trees Synthesis........................ 371 Synthesizing, Optimizing, and Routing Clock Trees With the clock_opt Command..................................................... 372 12 Contents Feedback Considering Voltage Drop Information During Clock Tree Synthesis.....372 Using Nondefault Routing Rules for Critical Nets During Optimization... 373 Performing Concurrent Clock and Data Optimization During the clock_opt Command.................................................. 373 Controlling Multibit Optimization Performed During the clock_opt Command.................................................. 374 Performing Power or Area Recovery on the Clock Network........... 374 Performing IR-Drop-Aware Placement During the clock_opt Command.. 375 Controlling Concurrent Clock and Data Optimization....................376 Limiting the Latency Adjustment Values.......................... 377 Excluding Boundary Paths.....................................377 Excluding Specific Path Groups.................................378 Excluding Specific Scenarios................................... 378 Excluding Specific Sinks...................................... 378 Controlling Timing Optimization Effort............................ 379 Controlling Hold Time Optimization Effort......................... 379 Controlling the Adjustment of I/O Clock Latencies...................379 Performing Dynamic-Voltage-Drop-Driven Concurrent Clock and Data Optimization During the route_opt Command...................... 380 Specifying Optimization Targets at the Preroute Stage............... 380 Specifying Optimization Targets at the Postroute Stage.............. 381 Enabling Buffer Removal at the Postroute Stage................... 383 Reporting Concurrent Clock and Data Timing...................... 383 Scaling CCD Offsets to New Scenarios for Reporting Timing.......... 385 Skewing Latch and Discrete Clock Gates......................... 385 Splitting Clock Cells............................................. 385 Balancing Skew Between Different Clock Trees....................... 386 Defining the Interclock Delay Balancing Constraints................. 386 Generating Interclock Delay Balancing Constraints Automatically.......388 Running Interclock Delay Balancing............................. 388 Performing Global-Route-Based Optimization Using Machine Learning Data. 389 Routing Clock Trees............................................. 391 Inserting Via Ladders During Clock Tree Synthesis, Optimization, and Clock Routing....................................................... 391 Marking Clocks as Propagated After Clock Tree Synthesis...............392 Performing Postroute Clock Tree Optimization........................ 392 Performing Voltage Optimization................................... 393 Marking Clock Trees as Synthesized................................ 394 Removing Clock Trees........................................... 394 Implementing Multisource Clock Trees..................................396 Introduction to Multisource Clock Trees Structures..................... 397 Implementing a Regular Multisource Clock Tree....................... 399 13 Contents Feedback Implementing a Regular Multisource Clock Tree Using Integrated Tap Assignment.................................................... 400 Implementing a Regular Multisource Clock Tree With an H-Tree-Only Global Clock Tree Structure.............................................402 Implementing MSCTS Multiple H-Tree...............................403 Implementing Power Aware Flexible H-Tree.......................... 404 Implementing a Structural Multisource Clock Tree......................405 Implementing a Structural Multisource Clock Tree Using Integrated Subtree Synthesis......................................................406 Improving the Correlation Between the SMSCTS and CCD.............. 409 Inserting Clock Drivers........................................... 410 Inserting Clock Drivers for Designs With Multiple Levels of Physical Hierarchy...................................."}
{"instruction": "How do I Checking Designs With Abstracts for Top-Level-Closure Issues", "input": "", "output": "You can check a hierarchical design that contains abstracts for possible issues such as the application option consistency issues and the design issues related to top-level closure by using the check_hier_design command. Identifying issues and fixing them before you perform top-level closure can help reduce turnaround time. When you use the check_hier_design command, you can specify The references to check by using the -reference option. If you do not specify this option, the command checks all the references in the physical hierarchy. The type of checks to perform by using the -stage option as follows: Use the -stage timing option to perform timing related checks. If you do not specify the -stage option, by default, the tool performs timing related checks. Use the -stage pre_placement to perform both timing and preplacement related checks. The check_hier_design command can check the consistency between the top-level constraints and the constraints of every lower-level instance linked to an abstract. To enable this feature, set the abstract.check_constraints_consistency application option to true before you run the check_hier_design command. The tool saves the settings of the predetermined list of timer application options during the create_abstract command. At the top-level design, the check_hier_design command compares these timer application option settings with those of the block-level design. The following application options are automatically saved during the create_abstract command and verified by the check_hier_design command: time.case_analysis_propagate_through_icg time.case_analysis_sequential_propagation time.clock_gating_propagate_enable time.clock_gating_user_setting_only 843 Checking Designs With Abstracts for Top-Level-Closure Issues Feedback time.clock_marking time.clock_reconvergence_pessimism time.create_clock_no_input_delay time.crpr_remove_clock_to_data_crp time.delay_calc_waveform_analysis_mode time.delay_calculation_style time.disable_case_analysis_ti_hi_lo time.disable_clock_gating_checks time.disable_cond_default_arcs time.disable_internal_inout_net_arcs time.disable_recovery_removal_checks time.edge_specific_source_latency time.enable_auto_mux_clock_exclusivity time.enable_ccs_rcv_cap time.enable_clock_propagation_through_preset_clear time.enable_clock_propagation_through_three_state_enable_pins time.enable_clock_to_data_analysis time.enable_non_sequential_checks time.enable_preset_clear_arcs time.enable_si_timing_windows time.gclock_source_network_num_master_registers time.special_path_group_precedence time.use_lib_cell_generated_clock_name time.use_special_default_path_groups For more information about the issues the check_hier_design command identifies and how to fix them, see the man page for the corresponding message ID. In addition to generating a report, the check_hier_design command generates an enhanced messaging system (EMS) database that you can view by using the message 844 Checking Designs With Abstracts for Top-Level-Closure Issues Feedback browser in the Fusion Compiler GUI. Create the EMS database before you run the check_hier_design command, as shown in the following example: fc_shell> create_ems_database check_hier.ems fc_shell> check_hier_design -stage timing fc_shell> save_ems_database In the Fusion Compiler GUI message browser, you can sort, filter, and link the messages to the corresponding man page, as shown in the following figure. Figure 194 Viewing the EMS Database in the Message Browser You can also output the information in the EMS database in ASCII format by using the report_ems_database command. The checks performed by the check_hier_design command are also available in the check_design command. You can perform Timing checks specific to top-level closure by using the check_design -checks hier_timing command All timing checks, including those specific to top-level closure, by using the check_design -checks timing command Preplacement checks specific to top-level closure by using the check_design -checks hier_preplacement command All preplacement checks, including those specific to top-level closure, by using the check_design -checks preplacement command 845 Checking Designs With Abstracts for Top-Level-Closure Issues Feedback You can generate an EMS database for the check_design command and view it in the GUI, similar to the check_hier_design command."}
{"instruction": "How do I Setting Constraints of Variant Cell", "input": "", "output": "To set the constraints of variant cell: 1. Use the set_repeater_group_constraints -type variant_cell_swapping command to set the variant for cell swapping. 2. Use the report_repeater_group_constraints command to view the report of the repeater group constraint settings, after setting the variant for cell swapping. The report provides the Track pattern of the variant cell group Variant site ids Honor cell group not sharing timing First track alignment 3. Use the remove_repeater_group_constraints command to remove the constraints and reset the settings based on the report."}
{"instruction": "How do I Exploring the Detailed Comparison Data", "input": "", "output": "When you launch the QORsum report, the application opens the QOR Summary table, which summarizes high-level timing, power, and congestion metrics for each of your runs. This and other summary views help you sort and filter the data to pinpoint the runs you want to explore further. Detailed table panels provide deeper insight into your data than can be found on the summary tables. For example, a summary table might give a high-level overview of design timing (WNS, TNS, NVE) at each major stage in the flow. A detailed table might show more in-depth path-group based timing information, showing the timing numbers for each separate scenario and path group in the design. This is only one example. There are many detailed table panels in the QORsum report, that shows information like statistics about each library cell instantiated in the design (number of instances, type of cell, total, area), or information about how much wirelength is on each routed metal layer. A detailed table lets you view this information for up to six different datasets at once. A dataset is a set of data captured for a specific run and stage/label in the flow. For example, you might view the route_opt command results for three different runs at once. Or you might view one run, but looking at the progression of results across different stages in the design flow (place_opt, clock_opt, route_opt), as shown in the following figure. 279 Performing Design Analysis Feedback Figure 43 Path Group Details The flows are shown side by side as columns under each metric. For example, the WNS column group (and the column group of each metric) shows the same six columns labeled 1, 2, 5, 6, 9, 10. These columns represent the results of each flow, and are given a flow ID number, rather than showing the full flow name, to prevent the columns from being too wide. The first column under each metric is the baseline, and the other five are the test flows being compared to that baseline. A legend is shown above the table with the flow ID number in a gold box (for the baseline) or a blue box (for the test flows), followed by the flow name. You can expand or collapse the legend by clicking the Legend button. You can also see the flow ID numbers in the \"Choose Baseline and Visible Runs\" dialog box, which is opened by clicking the Runs button. The detailed table views can display up to six runs at one time (your baseline run, plus the first five other runs selected in the Choose Baseline and Visible Runs dialog box). To change the runs that are displayed, 1. Click the Runs button to open the Choose Baseline and Visible Runs dialog box. 2. From the Visible Runs (Summary) column, select or deselect the runs accordingly. This selects and deselects those runs from the Visible flows (Detailed) column. Because a detailed table may show hundreds or even thousands of lines of data, it is not possible to view more than six datasets at a time. But if you want to see more details about these metrics across all runs and all flow stages/labels loaded into the QORsum report, there is an alternate view that shows this. This is called the Focused View. It can be accessed either by clicking the Focused View toggle button at the top of the report (see Figure 1), or by clicking on the frozen columns on the left side of the detailed table. In the focused view, you can see the results for all runs and all flow stages for a specific row of data from a detailed table. For example, in a path-group based timing detailed table, you might want to focus on the information only for path_group1 in scenarioA. To see this, click on the row in the detailed table for that path group and scenario. The Focused View for it opens. 280 Performing Design Analysis Feedback Using the same path-group timing example, the focused view shows one path group at a time. You can change the focus to a different path group by selecting a different scenario or path group name in the drop-down menus at the top of the report. See Figure 44 Figure 44 Focused View Drop-down Menu Filtering the Detailed Data Detailed views offer filters to focus on specific data. Some views have default filters that are shown automatically. For example, the following detailed views have default scenario and path group filters: Path Type Details, Path Group Details, and Logic Level Details. You can modify the default filters by Removing the filter by clicking the X symbol before the filter name Changing the filter value Enable and disable the filter by clicking anywhere on the filter but the X symbol or value field You can also apply custom filters to the detailed data. To create a custom filter, 1. Click the Filter button to display the Add Filter fields, which are shown in the following figure: 2. Define the filter by defining the filter criteria and selecting the datasets to include in the results. 281 Performing Design Analysis Feedback To define the filter, select the column and comparison type, and then specify the comparison value. To perform a numeric comparison, select one of the following comparison types:!= <=, or >= and specify a numeric value in the Value field. To perform a string comparison, select the contains comparison type and specify a string value in the Value field. To perform a regular expression comparison, select the regexp comparison type and specify a regular expression in the Value field. To filter based on the available values of the selected column, select the enum comparison type, which populates the Value field with a drop-down menu that contains the available values, and then enable one or more of the displayed values. When a value is enabled, a check mark is displayed before the value. To enable or disable a value, highlight the value by clicking it or navigating to it by using the Up and Down arrows, and then press Enter, which toggles the value status. You can also type a string in the Value field to filter the available values in the drop-down menu. To dismiss selected values, click the X symbol. 3. Apply the filter by clicking the green check mark. For example, to filter the Path Group Details view by displaying the path groups in the func@cworst scenario, define the filter as shown in the following figure:"}
{"instruction": "How do I Missing Via and Unconnected Pin Checking", "input": "", "output": "Note: Missing via and unconnected pin checking is supported in both RedHawk Fusion and RedHawk-SC Fusion analysis flows. Before you check for missing vias and unconnected pins, make sure you have the required input files as described in Preparing Design and Input Data for Rail Analysis Check for missing vias or unconnected pins in the block during voltage drop analysis or in a separate run. For example, you can perform the checking after completing the power 890 Missing Via and Unconnected Pin Checking Feedback structure and before running the place_opt command. This allows you to find power network errors in the design before rail analysis. By default, RedHawk/RedHawk-SC Fusion detects the following types of power network errors: Unconnected pin shapes: Pin shapes that are not contiguously and physically connected to an ideal voltage source. Missing vias: If two overlapping metal shapes do not contain a via within their overlapping area, it is considered a potential missing via error. To check for and fix missing vias or unconnected pins, 1. Define configuration options by using the set_missing_via_check_options command, as described in Setting Checking Options 2. Save the block by using the save_block command. 3. Perform the checking by using the analyze_rail -check_missing_via command, as described in Checking Missing Vias and Unconnected Pins. In the RedHawk-SC Fusion flow, you must specify the -check_missing_via option together with the -voltage_drop option. 4. Examine the checking results by opening the generated error files in the error browser or writing the checking results to an output file, as described in Viewing Error Data and Writing Analysis and Checking Reports 5. Insert PG vias to fix the reported missing vias, as described in Fixing Missing Vias"}
{"instruction": "How do I Introduction to Physical Datapath With Relative Placement", "input": "", "output": "Relative placement is usually applied to datapaths and registers, but you can apply it to any cell in your design, controlling the exact relative placement topology of gate-level logic groups and defining the circuit layout. You can use relative placement to explore QoR benefits, such as shorter wire lengths, reduced congestion, better timing, skew control, fewer vias, better yield, and lower dynamic and leakage power. 781 Introduction to Physical Datapath With Relative Placement Feedback The relative placement constraints that you create and annotate implicitly generate a matrix structure of the instances and control the placement of the instances. You use the resulting annotated netlist for physical optimization, during which the tool preserves the structure and places it as a single entity or group, as shown in Figure 166 Figure 166 Relative Placement in a Floorplan Relative placement groups can be floating or fixed. Obstructions Relative placement cells Macro Relative placement groups Standard cells"}
{"instruction": "How do I Using Automatic Floorplanning", "input": "", "output": "During early design stages, a design often undergoes many iterations due to changes such as adding features and macros; as a result, the floorplan contains limited or no physical information. Automatic floorplanning can generate high-quality floorplans and create missing physical information early in the design cycle, which allows you to Achieve better correlation between the results of RTL synthesis and design implementation Identify and fix design issues early in the design cycle Generate a better starting point for place and route, eliminating costly iterations During automatic floorplanning, the compile_fusion command performs the following tasks: Creates the die, rows, and tracks Shapes and places voltage areas Places macros Places pins and I/Os By default, the top-level floorplan is created with a core utilization of 0.7. For information about setting constraints for automatic floorplanning, see Creating Constraints for Auto Floorplanning 110 Importing the Floorplan Information Feedback"}
{"instruction": "How do I Inserting Metal Shapes in the Preferred Direction", "input": "", "output": "To insert rectangular metal shapes along the preferred-direction edges of the current block, use the derive_perimeter_constraint_objects command with the -perimeter_objects metal_preferred option. When you specify this object type, the command creates one or more rectangular metal shapes parallel to each preferred-direction boundary edge. The metal shapes are floating; they are not connected to any logical nets. If your technology does not specify a maximum area for these floating shapes, you can insert continuous metal shapes along the preferred-direction boundary edges, as described in Inserting Continuous Metal Shapes Parallel to Preferred-Direction Edges If your technology specifies a maximum area for these floating shapes or you need more flexibility in placing the metal shapes, insert multiple metal shapes, called metal stubs, along the preferred-direction boundary edges, as described in Inserting Metal Stubs Parallel to Preferred-Direction Edges In addition to inserting metal shapes along the preferred-direction edges, you can insert short metal shapes perpendicular to the nonpreferred-direction edges, as described in Inserting Short Metal Shapes Perpendicular to Nonpreferred-Direction Edges 482 Routing Constraints Feedback Inserting Continuous Metal Shapes Parallel to Preferred-Direction Edges To insert continuous rectangular metal shapes along the preferred-direction edges of the current block, use the derive_perimeter_constraint_objects command with the -perimeter_objects metal_preferred option. When you specify this option, the command creates a single rectangular metal shape parallel to each preferred-direction boundary edge. By default, The metal shapes are inserted only in the top-level block To insert metal shapes in all soft macros in a hierarchical block, use the -hierarchical option. The metal shapes are inserted on all routing layers To insert the metal shapes only on specific routing layers, use the -layers option. The metal shapes have the default metal width specified for the routing layer in the technology file For information about specifying the default metal width for a layer, see the \"Default Width Rule\" topic in the Synopsys Technology File and Routing Rules Reference Manual The metal shapes abut the nonpreferred-direction edges To specify an offset from the nonpreferred-direction edges, use the -spacing_from_boundary option. Use the following format to specify the offset for each layer: {{ layer_name offset_value }...} The offset value must be a positive value. The metal shapes are placed on the closest wire track to the preferred-direction edge Figure 101 shows the metal shapes inserted for an L-shaped block on a layer whose preferred direction is horizontal. Each metal shape is placed on the closest track to the edge. W is the default width for the layer and S is the spacing specified for the layer by the -spacing_from_boundary option. 483 Routing Constraints Feedback Figure 101 Continuous Metal Shape Perimeter Constraint Objects Inserting Metal Stubs Parallel to Preferred-Direction Edges To insert metal stubs along the preferred-direction edges of the current block, use the derive_perimeter_constraint_objects command with the -perimeter_objects metal_preferred and -stub options. When you specify both of these options, the command creates rectangular metal shapes parallel to each preferred-direction boundary edge based on the parameters you specify with the -stub option. Use the following format to specify the shape parameters in microns: offset_value start_value length_value spacing_value By default, The metal shapes are offset from the preferred-direction edge by the value specified in the offset_value argument The offset value is measured from the block edge to the center of the metal shape. It can be a positive value, zero, or a negative value. The absolute value of a negative value must be greater than the stub width. A positive value must be less than half of the smaller of the width or height of the block boundary. The first metal shape is offset from the nonpreferred-direction edge by the value specified in the start_value argument The start value must be greater than or equal to 0 and less than the smaller of the width or height of the block boundary. For horizontal shapes, the metal shapes start at the left edge. For vertical shapes, the metal shapes start at the bottom edge. Note: When you use the -stub option, the command uses the specified start_value and ignores the -spacing_from_boundary option. 484 Routing Constraints Feedback The metal shapes have the length specified by the length_value argument The length value must be greater than 0 and less than or equal to the smaller of the width or height of the block boundary. The metal shapes have the default metal width specified for the routing layer in the technology file For information about specifying the default metal width for a layer, see the \"Default Width Rule\" topic in the Synopsys Technology File and Routing Rules Reference Manual The metal shapes are separated the space specified by the spacing_value argument The spacing value must be greater than or equal to 0. The metal shapes are inserted only in the top-level block To insert metal shapes in all soft macros in a hierarchical block, use the -hierarchical option. The metal shapes are inserted on all routing layers To insert the metal shapes only on specific routing layers, use the -layers option. Figure 102 shows the metal stubs inserted for an L-shaped block on a layer whose preferred direction is horizontal. Each metal shape is placed at the specified offset, O, from the horizontal (preferred-direction) edge, where O is measured from the boundary to the center of the shape. The first metal stub is placed at the specified offset, S, from the vertical (nonpreferred-direction) edge. Each metal shape has a width of W, the default width for the layer and the specified length, L. The spacing between metal stubs is the specified spacing, SP. Figure 102 Metal Stub Perimeter Constraint Objects SP SP SP SP SP SP SP SP 485 Routing Constraints Feedback Inserting Short Metal Shapes Perpendicular to Nonpreferred-Direction Edges To insert additional short metal shapes in the preferred direction perpendicular to the nonpreferred-direction boundary edges, Specify the length of the metal shapes by using the -short_metal_length option Specify the distance between the metal shapes by using the -metal_spacing option For both of these options, you use the following format to specify the value for each layer: {{ layer_name value }...} Figure 103 shows the short metal shapes inserted for an L-shaped block on a layer whose preferred direction is horizontal. Each metal shape has a width of W, which is the default width for the layer, and a length of L, which is the length specified for the layer by the -short_metal_length option. The offset from the nonpreferred-direction edge is S, which is the spacing specified for the layer by the -spacing_from_boundary option. The distance between short metal shapes is SS, which is specified for the layer by the -metal_spacing option. Figure 103 Metal Shape Perimeter Constraint Objects With Additional Short Shapes SS"}
{"instruction": "How do I Setting Options for Signoff Metal Fill Insertion", "input": "", "output": "Before you run the signoff_create_metal_fill command, configure the run by setting the application options shown in Table 49. To set the application options, use the set_app_options command. To see the current settings, use the report_app_options command. Table 49 Application Options for Signoff Metal Fill Insertion Application option Default Description Options that apply to all flows signoff.create_metal_fill. apply_nondefault_rules false Controls whether metal fill insertion honors nondefault routing rules. signoff.create_metal_fill. auto_eco_threshold_value 20 Specifies the maximum percentage of change to the block to perform incremental metal fill insertion using the -auto_eco true option. signoff.create_metal_fill. flat false Controls whether the IC Validator tool uses the metal fill mode specified in the runset file ( false or uses the flat metal fill mode ( true ). signoff.create_metal_fill. read_design_views {} Specifies the reference cells for which the IC Validator tool reads the design view instead of the frame view. Using the design view can expose problems that are masked by the frame view abstraction. signoff.create_metal_fill. read_layout_views {} Specifies the reference cells for which the IC Validator tool reads the layout view instead of the frame view. Using the layout view can expose problems that are masked by the frame view abstraction. 708 Inserting Metal Fill With IC Validator In-Design Feedback Table 49 Application Options for Signoff Metal Fill Insertion (Continued) Application option Default Description signoff.create_metal_fill. run_dir signoff_fill_run Specifies the run directory, which contains the files generated by the signoff_create_metal_fill command. You can specify either a relative path, in which case the directory is created under the current working directory, or an absolute path. signoff.create_metal_fill. user_defined_options (none) Specifies additional options for the IC Validator command line. The string that you specify in this option is added to the command line used to invoke the IC Validator tool. The Fusion Compiler tool does not perform any checking on the specified string. signoff.physical. merge_exclude_libraries (none) Specifies the cell libraries whose cells are excluded from replacement with the cell data in the stream files specified in the signoff.physical. merge_stream_files application option. signoff.physical. merge_stream_files (none) Specifies the stream (GDSII or OASIS) files to merge into the current block for metal fill insertion. When you use this option, the GDSII or OASIS data replaces the cell library data for the cells defined in the specified stream files. Options that apply only to pattern-based metal fill insertion signoff.create_metal_fill. runset N/A Specifies the foundry runset to use for pattern-based metal fill insertion. This application option is not used for track-based metal fill insertion signoff.physical. layer_map_file (none) Specifies the name of the layer mapping file. In general, the technology file and the foundry runset file used by the IC Validator tool use the same layer numbers. If they do not, you must supply a layer mapping file to map the technology layers to the layers used in the runset file (for details about the format of the layer mapping file, see Defining the Layer Mapping for IC Validator In-Design Commands Options that apply only to track-based metal fill insertion 709 Inserting Metal Fill With IC Validator In-Design Feedback Table 49 Application Options for Signoff Metal Fill Insertion (Continued) Application option Default Description signoff.create_metal_fill. max_density_threshold (none) Specifies the maximum density threshold value for a track fill layer. Use the following format to specify this information for each layer: layer_name max_density This application option applies only to track-based metal fill insertion and does not apply when you use the -mode add option. Options that apply only to timing-driven metal fill insertion (pattern-based or track-based) signoff.create_metal_fill. fill_over_net_on_adjacent_la yer false Controls whether the IC Validator tool inserts metal fill within the minimum spacing in the vertical extension of the net on the adjacent layers when performing timing-driven metal fill insertion. signoff.create_metal_fill. fill_shielded_clock false Controls whether the IC Validator tool inserts metal fill for shielded clock nets when performing timing-driven metal fill insertion. signoff.create_metal_fill. fix_density_errors false Controls whether the IC Validator tool performs density error fixing during timing-driven metal fill insertion. signoff.create_metal_fill. space_to_clock_nets Two times the minimum spacing specified in the technology file Specifies the minimum spacing between metal fill and a clock net on the same layer. Note that you must specify clock nets by using the -nets option. Any unspecified layers use the default spacing. signoff.create_metal_fill. space_to_nets Two times the minimum spacing specified in the technology file Specifies the minimum spacing between metal fill and a timing-critical net on the same layer. Any unspecified layers use the default spacing. signoff.create_metal_fill. space_to_nets_on_adjacent_la yer Two times the minimum spacing specified in the technology file Specifies the minimum spacing between metal fill and a timing-critical net on an adjacent layer. Any unspecified layers use the default spacing. 710 Inserting Metal Fill With IC Validator In-Design Feedback"}
{"instruction": "How do I Specifying Optimization Targets at the Preroute Stage", "input": "", "output": "When performing concurrent clock and data optimization using the place_opt or clock_opt command, you can give a higher priority to the WNS optimization of Certain path groups by specifying them by using the ccd.targeted_ccd_path_groups application option, as shown in the following example: fc_shell> set_app_options -name ccd.targeted_ccd_path_groups \\ -value {PG1 PG2} 380 Implementing Clock Trees and Performing Post-CTS Optimization Feedback If a path group you specify with this application option is also specified as a path group to skip with the ccd.skip_path_groups application option, the path group is skipped during concurrent clock and data optimization. Certain endpoints by specifying a file containing the endpoints by using the ccd.targeted_ccd_end_points_file application option, as shown in the following example: fc_shell> set_app_options -name ccd.targeted_ccd_end_points_file \\ -value endpoint_targets.tcl If you specify both path groups and endpoints, the tool optimizes only the specified endpoints that are in the specified paths groups. The worst 300 timing paths by setting the ccd.enable_top_wns_optimization application option to true"}
{"instruction": "How do I Reading Via Definitions from a LEF File", "input": "", "output": "To read via definitions specified by via rule GENERATE statements in a LEF file, use the read_tech_lef command. This command supports the following LEF syntax: via_rule_name GENERATE [DEFAULT] LAYER lower_layer_name ENCLOSURE lower_overhang1 lower_overhang2 LAYER upper_layer_name ENCLOSURE upper_overhang1 upper_overhang2 LAYER cut_layer_name RECT llx lly urx ury SPACING x_spacing BY y_spacing The WIDTH and RESISTANCE statements are not supported."}
{"instruction": "How do I Implementing Clock Trees and Performing Post-CTS Optimization", "input": "", "output": "Before you perform clock tree synthesis, you should save the block. This allows you to refine the clock tree synthesis goals and rerun clock tree synthesis with the same starting point, if necessary. The following topics describe the different methods available for implementing clock trees: Performing Standalone Clock Trees Synthesis Synthesizing, Optimizing, and Routing Clock Trees With the clock_opt Command Controlling Concurrent Clock and Data Optimization 370 Implementing Clock Trees and Performing Post-CTS Optimization Feedback Splitting Clock Cells Balancing Skew Between Different Clock Trees Performing Global-Route-Based Optimization Using Machine Learning Data Routing Clock Trees Inserting Via Ladders During Clock Tree Synthesis, Optimization, and Clock Routing Marking Clocks as Propagated After Clock Tree Synthesis Performing Postroute Clock Tree Optimization Performing Voltage Optimization Marking Clock Trees as Synthesized Removing Clock Trees"}
{"instruction": "How do I Activity-Based Optimization", "input": "", "output": "If you load a SAIF file, the Fusion Compiler tool analyzes the switching activity to evaluate whether to expand a tool-inserted clock gate. This analysis prevents the insertion of unnecessary clock gates. For example, in Figure 58, clock gates A1 and A2 are each common to two paths and are therefore candidates for multilevel expansion. Figure 58 Before Clock-Gate Level Expansion 312 Merging Clock Gates Feedback However, if clock gate A2 is always enabled, it has a toggle rate of 0 and a static probability of 1. Adding another clock-gate level does not provide any benefit in this case. The final configuration is shown in Figure 59 Figure 59 After Clock-Gate Level Expansion If clock-gate level expansion is enabled, the Fusion Compiler tool performs activity- driven analysis by default. If a SAIF file is not available, disable this feature by setting the compile.clockgate.enable_activity_drivel_level_expansion application option to false (the default is true ). If clock-gate level expansion is disabled, the tool ignores the compile.clockgate.enable_activity_driven_level_expansion application option."}
{"instruction": "How do I Example Script of Hierarchical Synthesis Using ETMs", "input": "", "output": "The following script shows an example of the hierarchical synthesis flow: # Specify reference libraries set REF_LIBS ${std_cell}.ndm lappend REF_LIBS ${block_design}_etm.ndm create_lib -tech ${TECH_FILE} -ref_libs $REF_LIBS ${DESIGN_NAME} # Read the RTL design analyze -format verilog [list $rtl_list] elaborate ${DESIGN_NAME} #ETM.ndm in ref_lib is used to link cell instances set_top_module ${DESIGN_NAME} # Load UPF for ETM cell instance load_upf ${block_design}.upf -scope cell_instance # Read test model for ETM cell instance read_test_model ${block_design}.mapped.ctl... compile_fusion -to initial_opto # Query commands # List all macro cell instances get_cells -hierarchical -filter \"is_hard_macro == true\" # ref view name is \"timing\" for cell instances bound to ETM get_attribute ${CELL} is_etm_moded_cell"}
{"instruction": "How do I Corner Type", "input": "", "output": "The custom.route.bus_corner_type application option specifies how the tool routes the bus trunks at corners. Valid values are: Valid Value Description auto (Default) Automatically determines the optimal corner type for the bit or pin alignment to reduce routing congestion. 766 Using Custom Routing Application Options Feedback Valid Value Description cross Routes the bits so that they overlap at the corner. river Routes the bits so that they do not overlap at the corner."}
{"instruction": "How do I Clock Gating Flows", "input": "", "output": "The Fusion Compiler tool inserts clock-gating cells during the compile_fusion command. The following topics describe clock-gating flows: Inserting Clock Gates in Multivoltage Designs Inserting Clock Gates in an RTL Design 301 Clock Gating Flows Feedback"}
{"instruction": "How do I Inserting Clock Gates in an RTL Design", "input": "", "output": "To insert clock gating logic in an RTL design and to synthesize the design with the clock- gating logic, follow these steps: 1. Read the RTL design. 2. (Optional) Use the insert_dft command to insert test cells into the design. 3. Use the compile_fusion command to compile the design. During the compile process, the tool inserts clock gates on the registers qualified for clock-gating. By default, during clock-gate insertion, the compile_fusion command uses the clock gating default settings and also honors the setup, hold, and other constraints specified in the logic libraries. To override the setup and hold values specified in the library, use the set_clock_gating_check command before compiling the design. The default settings are suitable for most designs. The compile_fusion command automatically connects the scan enable and test ports or pins of the integrated clock-gating cells, as needed. 4. Use the report_clock_gating command to report the registers and the clock-gating cells in the design. Use the report_power command to get information about the dynamic power used by the design after clock-gate insertion. The following example illustrates a typical command sequence for clock using default settings: fc_shell> read_verilog design.v fc_shell> create_clock -period 10 -name CLK fc_shell> compile_fusion fc_shell> insert_dft 302 Replacing Clock Gates Feedback fc_shell> report_clock_gating fc_shell> report_power"}
{"instruction": "How do I Specifying a Cell Name Prefix for Optimization", "input": "", "output": "You can specify a name prefix for the cells added on the data nets during optimization by using the opt.common.user_instance_name_prefix application option. The following example specifies a name prefix of CF_ for the cells added on the data nets during the compile_fusion command CO_ for the cells added on the data nets during the clock_opt command RO_ for the cells added on the data nets during the route_opt command fc_shell> set_app_options \\ -name opt.common.user_instance_name_prefix -value \"CF_\" fc_shell> compile_fusion fc_shell> set_app_options \\ -name opt.common.user_instance_name_prefix -value \"CO_\" fc_shell> clock_opt fc_shell> set_app_options \\ -name opt.common.user_instance_name_prefix -value \"PO_\" fc_shell> route_opt To specify a name prefix for the cells added on the clock network during clock tree synthesis, use the cts.common.user_instance_name_prefix application option, as described in Defining a Name Prefix for Clock Cells"}
{"instruction": "How do I Running Rail Analysis Using RedHawk-SC Fusion", "input": "", "output": "Similar to the RedHawk Fusion capability, RedHawk-SC Fusion supports gate-level rail analysis and checking capabilities in the Fusion Compiler environment. To enable the RedHawk-SC Fusion capability, you need to enable the rail.enable_redhawk_sc application option and disable the rail.enable_redhawk application option at the same time. For more information about RedHawk-SC Fusion, see Setting Up the Executables and Specifying RedHawk and RedHawk-SC Working Directories RedHawk Fusion and RedHawk-SC share the same set of analysis and checking commands for rail analysis, and the same GUI for examining the analysis results, except for some limitations. Table 65 compares the analyze_rail options that are supported in either or both of RedHawk Fusion and RedHawk-SC Fusion. Table 65 Comparing Analysis Features Between RedHawk Fusion and RedHawk-SC Fusion RedHawk Fusion RedHawk-SC Fusion -redhawk_script_file Supported Supported -voltage_drop Supported Supported -switching_activity Supported Supported 868 Running Rail Analysis Using RedHawk-SC Fusion Feedback Table 65 Comparing Analysis Features Between RedHawk Fusion and RedHawk-SC Fusion (Continued) RedHawk Fusion RedHawk-SC Fusion -electromigration Supported Supported -power_analysis Supported Supported -result_name Supported Supported -script_only Supported Supported -bg Supported Supported -min_path_resistance Supported Supported together with the -voltage_drop option only -effective_resistance Supported Supported together with the -voltage_drop -option only -check_missing_via Supported Supported together with the -voltage_drop option only Displaying missing via check results does not honor the IR threshold setting. -extra_gsr_option_file Supported Not supported -multiple_script_files Supported Not supported -submit_to_other_machines Supported Not supported Before performing rail analysis using the RedHawk-SC Fusion capability, you must specify the location of the libraries and the required input files as described in Preparing Design and Input Data for Rail Analysis. The following two application options are available only in RedHawk-SC Fusion: rail.toggle_rate Specify toggle rates for different cell types for rail analysis. For example: fc_shell> set_app_options -name rail.toggle_rate \\ -value {clock 2.0 data 0.2 combinational 0.15 \\ sequential 0.15} 869 An Overview for RedHawk Fusion and RedHawk-SC Fusion Feedback rail.em_only_tech_file Specify the electromigration rule file for performing PG electromigration analysis. Use this option when the electromigration rule information is defined in a separate technology file other than the one specified by the rail.tech_file application option. For example, fc_shell> set_app_options -name rail.em_only_tech_file \\ -value EM_ONLY.rule"}
{"instruction": "How do I Groups", "input": "", "output": "The following topics provide information related to the placement and legalization of relative placement groups: Relative Placement in a Design Containing Obstructions Legalizing Relative Placement Groups in a Placed Design Creating New Relative Placement Groups in a Placed Design"}
{"instruction": "How do I Track Assignment", "input": "", "output": "Before you run track assignment, Define the common routing application options For information about the common routing application options, see the route.common_options man page. Define the global routing application options For information about the track assignment application options, see the route.track_options man page. Complete global routing To perform standalone track assignment, run the route_track command. 531 Routing Signal Nets Feedback The main task of track assignment is to assign routing tracks for each global route. During track assignment, Zroute performs the following tasks: Assigns tracks in horizontal partitions. Assigns tracks in vertical partitions. Reroutes overlapping wires. After track assignment finishes, all nets are routed but not very carefully. There are many violations, particularly where the routing connects to pins. Detail routing works to correct those violations. Note: Because track assignment replaces the global routes with actual metal shapes, the block no longer contains global routes after track assignment completes. By default, the route_track command is not timing-driven or crosstalk-driven. To enable timing-driven mode, set the route.track.timing_driven application option. To enable crosstalk-driven mode, set the route.track.crosstalk_driven and time.si_enable_analysis application options to true At the end of track assignment, Zroute reports a summary of the wire length and via count. Example 20 shows a track assignment report. Example 20 Track Assignment Report Wire length and via report: Number of M1 wires: 215327 : 0 Number of M2 wires: 1124740 VIA12SQ_C: 1067462... Total number of wires: 2508734 vias: 2769482 Total M1 wire length: 924480.9 Total M2 wire length: 4147032.0... Total wire length: 21281278.0 Longest M1 wire length: 1541.7 Longest M2 wire length: 926.0... 532 Routing Signal Nets Feedback"}
{"instruction": "How do I Marking Clock Trees as Synthesized", "input": "", "output": "To prevent the Fusion Compiler tool from modifying them, you can mark existing clock trees in your design as synthesized clock tree by using the mark_clock_trees command as shown in Table 27 Table 27 Using the mark_clock_trees Command To do this Use this option Mark only the clock trees of specific clocks By default, the command marks all clocks defined by the create_clock and create_generated_clock commands in all modes of all active scenarios -clocks clock_list Mark the clock tree as synthesized This is the default behavior -synthesized Remove the synthesized attribute settings from the clock trees -clear Apply the dont_touch attribute setting on the clock trees -dont_touch Remove the dont_touch attribute settings from the clock trees -clear -dont_touch Propagate the nondefault clock routing rules specified by the set_clock_routing_rules command -routing_rules Propagate the clock cell spacing rules specified by the set_clock_cell_spacing command -clock_cell_spacing Mark the clock sinks as fixed -fix_sinks Freeze the routing of the clock nets -freeze_routing The tool traverses the clock trees and marks the clock trees as specified. Clock tree traversal continues until it finds an exception pin or a default sink pin."}
{"instruction": "How do I Adding Voltage Area Aware Group Repeaters", "input": "", "output": "Voltage area aware group repeaters choose legal library cells for repeaters based on the corresponding voltage area and updates supply nets for repeaters to meet multivoltage constraints. You can use the add_group_repeaters command with specific options to add voltage area aware group repeaters in three different ways, depending on the design methodology: When the design is single-rail buffer only, use the -va_aware option fc_shell> add_group_repeaters -lib_cell <lib_cell> -va_aware When the design is single-rail buffer based on voltage area, use the -voltage_area_specific_lib_cell option 983 Adding a Group of Repeaters Feedback fc_shell> add_group_repeaters -lib_cell <default_lib_cell> \\ -voltage_area_specific_lb_cell {{VA1 libcell1}} {{VA2 libcell2}} When the design is single- and dual-rail buffers, use the -select_mv_buffer option fc_shell> add_group_repeaters -lib_cell <default_lib_cell> \\ -select_mv_buffer {{VA1 SingleRail1 DualRail1}} \\ {{VA1 SingleRail2 DualRail2}} Voltage area aware group repeaters help resolve multivoltage violations by choosing the library cell based on voltage area and repeater location."}
{"instruction": "How do I Placing Group Repeaters For Multibit Registers", "input": "", "output": "To place group repeaters for multibit registers, use the create_repeater_groups command with the -multi_bit option with the following command options: create_repeater_groups -cells | -supernet_bundles | -supernets -multi_bit -pin_mapping {{lib_cell1 {inp1 outp1} {inp2 outp2}\u2026} The -multi_bit option determines the order of a multibit repeater based on the path driver and creates the repeater groups for the multibit repeaters. In a design, when a net has no route defined, this option places the group repeaters based on their location. To verify the support for multibit register placement, use the following command: fc_shell> preplace_group_repeater -repeater_group_locations repeater_group_location_list The format for the repeater_group_location_list argument is 985 Adding a Group of Repeaters Feedback { {cell_collection, layer, location, potential routing direction, placing order}...} or { {group_id, layer, location, potential routing direction, placing order}...}."}
{"instruction": "How do I Routing to Clock Straps", "input": "", "output": "After you create clock straps for a clock net by using the create_clock_straps command, you can route the drivers and loads of the clock net to the clock straps by using the route_clock_straps command and specify the clock net name by using the -nets option. The tool connects the drivers and the loads only to clock straps with the shape_use attribute setting of stripe. It does not connect to clock straps with the shape_use attribute setting of user_route 419 Implementing Multisource Clock Trees Feedback To specify a topology for connecting the clock drivers and sinks to the clock straps, use the -topology option as follows: To create a fishbone routing topology, the default topology, use the -topology fishbone option. In a fishbone topology, each driver pin is individually connected to the nearest stripe. To minimize wire length, multiple load pins are connected using comb routing to a single finger, which is connected to the stripe, as shown in Figure 91 Figure 91 Fishbone Topology Fanout Clock mesh strap ( shape_use user_route Clock mesh strap ( shape_use stripe Comb route Driver pins Load pins Finger route If you are using a fishbone topology, you can specify A maximum fanout for the loads of a finger, as shown in Figure 92, by using -fishbone_fanout option. Figure 92 Fanout of a Finger of the Fishbone Topology Finger Fanout A maximum span between any two loads connected to a finger, as shown in Figure 93, by using -fishbone_span option. 420 Implementing Multisource Clock Trees Feedback The span is measured orthogonal to the direction of the finger. Figure 93 Span and Subspan of the Fishbone Topology Subspan Span Subfinger Finger A maximum subspan between any two loads connected to a subfinger, as shown in Figure 93, by using -fishbone_sub_span option. The subspan is measured orthogonal to the direction of the subfinger. The layers to use for routing the fingers and subfingers by using the -fishbone_layers option. To create a comb routing topology, use the -topology comb option. In a comb topology, each driver and load pin is directly routed to the nearest stripe. However, if the Manhattan distance from a pin to the nearest stripe is more than the comb distance, the tool routes the pin to the nearest net shape using a Steiner topology, as shown in Figure 94. The default comb distance is two global routing cells. To change the comb distance, use the route.common.comb_distance application option. 421 Implementing Multisource Clock Trees Feedback Figure 94 Comb Topology Load pins Driver pins Clock mesh strap ( shape_use stripe Clock mesh strap ( shape_use user_route Comb route Pin that is further than the comb distance Comb routing is suitable when there are a large number of driver and load pins directly under the clock-mesh stripes. The tool uses stacked vias to connect the pins to the stripes, which are usually in the higher routing layers. However, this can contribute to physical DRC violations due to many adjacent stacked vias, as shown in Figure 95 Figure 95 Vias in the Comb Topology Driver and load pins Clock mesh strap on Stacked vias higher routing layer To create a substrap routing topology, use the -topology sub_strap option. In a substrap topology, additional straps that are parallel to the stripes are created on intermediate routing layers. This reduces the number of stacked vias, as compared to the comb topology. 422 Implementing Multisource Clock Trees Feedback Figure 96 Vias in the Substrap Topology Driver and load pins Clock mesh stripe on Substrap on intermediate higher routing layer routing layers For the substrap topology, you Must specify the layers in which to create the substrap by using the -sub_strap_layers option Can specify the maximum RC delay allowed for the substrap by using the -sub_strap_max_delay option The default is 2 ps. This delay constrains the length and the number of loads connected to the substrap."}
{"instruction": "How do I Fixing Diodes", "input": "", "output": "The -diode option of the fix_mv_design command fixes mismatches between power domains and voltage areas for diodes throughout the design. The fix_mv_design -diode command examines all diodes, including diodes inserted by the create_cell create_diodes, and add_port_protection_diodes commands, as well as several routing commands that insert diodes to fix antenna violations. If a power domain and voltage area mismatch for a diode is found, the tool uses the voltage area to explicitly assign a corresponding power domain. If multiple power domains exist in a single voltage area, the tool picks one of the available power domains. Any of the available power domains is acceptable because all diode cells are single-rail cells and all power domains in the same voltage area have the same primary supply. 1008 Fixing Multivoltage Violations Feedback To obtain a report of the changes that the tool recommends without making any netlist changes, use the -report_only option. To obtain detailed information in the report, use the -verbose option. These are the only two options that you can use with the -diode option. 1009"}
{"instruction": "How do I Deriving Mask Colors", "input": "", "output": "At advanced technology nodes, mask colors must be assigned to wires and vias to ensure correct processing of the net shapes during mask synthesis. The route_detail command and other routing commands in the tool usually add the necessary mask colors during routing. For net shapes that do not have a color assignment, use the derive_mask_constraint command to derive the color mask for the specified wires and vias from the nearest underlying tracks. In case of wide wires that occupy multiple tracks, the command takes the mask color opposite to the next unoccupied track. The following example derives the mask color for the net shapes of the net1 net. fc_shell> derive_mask_constraint \\ [get_shapes -of_objects [get_nets net1]] 578 Inserting and Removing Cut Metal Shapes Feedback Use options to the derive_mask_constraint command to control how the mask colors are derived. Derive cut mask constraints for the specified nets or vias. fc_shell> derive_mask_constraint -derive_cut_mask \\ [get_vias -within {{600 600} {700 700}}] Derive mask constraints from overlapping or touching pins or ports. fc_shell> derive_mask_constraint -follow_pin_mask \\ [get_shapes -of_objects [get_nets net1]] Derive the mask constraint from the wider overlapping or touching object rather than the wire track. fc_shell> derive_mask_constraint -follow_wider_object_mask \\ [get_shapes -of_objects [get_nets net1]] See Also Multiple-Patterning Concepts"}
{"instruction": "How do I Scan Synthesis Flow", "input": "", "output": "Specifying synthesis constraints specific to DFT insertion for certain registers must be mapped to non-scan versions and the core wrapper reuse threshold. To specify the DFT configurations: 1. Execute compile_fusion -from initial_map -to logic_opto 2. Specify the DFT configurations such as DFT signals, chain counts, test modes, and so on. 3. Complete the DFT insertion. For more information about DFT insertion, see the TestMAX DFT User Guide. 4. Execute compile_fusion -from initial_place Note: You must create scan test and scan in and scan out ports before importing floorplan information. In addition, the floorplan must contain the physical locations of the test and scan ports. Scan-Only Script Example # Set up the library... # Read the design... # Specify any registers that should not be mapped to scan equivalent, and also to be excluded from any scan chains set_scan_element false <registers that should not be mapped to scan equivalent> # Run compile_fusion to logic_opto step compile_fusion -to logic_opto # DFT Specifications: # Scan chain setup set_scan_configuration -chain_count sc # DFT signals # Clocks and asynchronous resets 259 Performing Test Insertion and Scan Synthesis Feedback set_dft_signal -view existing -type ScanClock \\ -port clk -timing [list 45 55] set_dft_signal -view existing -type Reset \\ -port reset_n -active_state0 # Scan in, scan out, scan enable set_dft_signal -view spec -type ScanDataIn -port SI set_dft_signal -view spec -type ScanDataOut -port SO set_dft_signal -view spec -type ScanEnable -port SE # Scan Synthesis steps create_test_protocol dft_drc preview_dft insert_dft # Continue from initial_place step compile_fusion -from initial_place -to initial_opto # Perform post dft_drc dft_drc -test_mode Internal_scan # Generate post dft_drc verbose report report_dft_drc_violations -test_mode Internal_scan -rule all # Write out Scandef write_scan_def design.scan.def # Write out test model write_test_model -output design.ctl # Save output for TetraMAX write_test_protocol -output design.scan.spf -test_mode Internal_scan write_verilog -hierarchy all design.v"}
{"instruction": "How do I Running RedHawk Fusion Commands in the Background", "input": "", "output": "By default, when you execute the analyze_rail command to perform rail analysis, the RedHawk or RedHawk-SC tool is invoked to perform the specified analysis types with the input data and then load the analysis results back to the rail database when rail analysis is finished. You cannot run any Fusion Compiler commands unless the RedHawk Fusion or RedHawk-SC Fusion process is finished. To perform layout editing tasks while the tool is running in the background, run the analyze_rail -bg command. When analysis is completed, run the open_rail_result -back_annotate command to upload the analysis results to the rail database. By default, RedHawk or RedHawk-SC loads the analysis results back to the rail database when analysis is completed. However, when you specify the -bg option with the analyze_rail command, you need to run the open_rail_result -back_annotate command to reconstruct rail database and create the new RAIL_DATABASE file from the latest analysis results. 874 Setting Up the Executables Feedback Note: When back-annotating the analysis results from the previous run after moving nets in the design, the instance-based map reflects the updated instance location change, but the parasitic map does not. When opening rail results, the tool does not detect if the result is generated with or without the -bg option. The command might not work correctly if you run the open_rail_result -back_annotate command to open the rail result that is generated without the -bg option, or vice versa. Reporting and Checking the Status of the Background Process When the RedHawk or RedHawk-SC Fusion process is finished, the tool issues the following message: Info: Running REDHAWK_BINARY in background with log file: LOG_FILE The LOG_FILE file is saved in the PWD directory. To check if the background analyze_rail process is active, use the report_background_jobs command."}
{"instruction": "How do I Library Configuration", "input": "", "output": "Library configuration allows you to specify which vendor libraries to use as reference libraries for the current design. You specify the technology file, physical libraries, and logic libraries by using the search_path and link_library variables, and then you use the create_lib or set_ref_libs command to assemble the cell libraries. 76 Setting Up Libraries Feedback During library configuration, The Fusion Compiler tool automatically calls the Library Manager tool without user intervention to generate cell libraries, as shown in the following figure:.frame files ASCII technology file.db files Cell libraries Synthesis The tool saves the generated cell libraries to disk and adds them to the reference library list of the design library. These cell libraries are the same as when the cell libraries are created during library preparation in the Library Manager tool. For more information, see the Configuring Cell Libraries topic in the Fusion Compiler Data Model User Guide"}
{"instruction": "How do I Identification of Shift Registers", "input": "", "output": "During compile, the tool can automatically identify shift registers in the design. The compile_fusion -to initial_opto command maps the first register to a scan cell and the other cells to nonscan cells, as shown in this figure. ___ RST SI SE CLK SO This capability improves the sequential design area and reduces congestion because of fewer scan-signals for routing. To disable this capability, set the compile.seqmap.identify_shift_registers application option to false. The default is true 237 Controlling Mapping and Optimization Feedback"}
{"instruction": "How do I Creating ETMs in the PrimeTime Tool", "input": "", "output": "You can create an ETM for design by using the extract_model command in the PrimeTime tool. For multicorner-multimode designs, you must create an ETM for each scenario by applying the appropriate corner and mode constraints for each scenario. The following PrimeTime script creates an ETM for the S3 scenario, which consists of the m1 mode and c3 corner, of the AMS_BLK design: #Read in the design read_verilog./AMS_BLK.v link # Apply parasitics read_parasitics./AMS_BLK.spef 856 Creating ETMs and ETM Cell Libraries Feedback #For multivoltage designs, apply UPF data and settings load_upf./AMD_BLK.upf set extract_model_include_upf_data true # Apply the mode (m1) and corner (c3) constraints for the scenario (S3) source m1_constraints.tcl source c3_constraints.tcl # Enable clock latencies for designs with synthesized clock trees set extract_model_with_clock_latency_arcs true set extract_model_clock_latency_arcs_include_all_registers false # Create the ETM extract_model -library_cell -format db -output AMS_BLK_m1_c3 For more information about creating ETMs in the PrimeTime tool, see the Extracted Timing Models chapter in the PrimeTime User Guide 857 Creating ETMs and ETM Cell Libraries Feedback"}
{"instruction": "How do I Deriving Routing Guides", "input": "", "output": "Routing guides provides routing directives for specific areas of a block. Some types of routing guides are user-defined; others are derived from the block data. This topic described how to derive the following types of routing guides: Deriving Pin Access Routing Guides Deriving Metal Cut Routing Guides See Also Defining Routing Guides 479 Routing Constraints Feedback"}
{"instruction": "How do I Defining Checkpoint Behaviors", "input": "", "output": "You can define two types of checkpoint behaviors: reports and actions. Define a checkpoint report to generate one or more reports supported by the tool or custom reports you create yourself. Define a checkpoint action to execute any kind of flow change before, 54 Adding Changes to a Script With Checkpoints Feedback after, or in place of the code block enwrapped by a checkpoint. For example, you might set an application option to a specific value before a particular checkpoint. Define these behaviors in your checkpoint.config.tcl file, which is automatically sourced by the checkpoint system. Defining Checkpoint Reports To define a checkpoint report, use the create_checkpoint_report command in your checkpoint.config.tcl file. Specify a unique name for the report and define the Tcl commands to generate the report. The following example defines a checkpoint report named timing, which writes the output of the report_qor and report_timing commands to disk: create_checkpoint_report timing { set name [get_current_checkpoint -name] set pos [get_current_checkpoint -position] report_qor -nosplit >./checkpoint/$name.$pos.qor.rpt report_qor -summary -nosplit >>./checkpoint/$name.$pos.qor.rpt report_timing -nosplit -max_paths 10 \\ >./checkpoint/$name.$pos.path.rpt Notice the use of the get_current_checkpoint command with the -name and -position options to give the generated reports a meaningful name. When these reports are generated, their names reflect the checkpoint that triggered them get_current_checkpoint -name ), as well as whether they were generated before or after the checkpoint ( get_current_checkpoint -position ). For example, if this checkpoint report is executed after a checkpoint named checkpoint_A, the generated reports are saved to the checkpoint directory, and the name of the QoR report is checkpoint_A.after.qor.rpt. The next example defines a checkpoint report named app_options, which writes all your non-default application options to disk: create_checkpoint_report app_options { set name [get_current_checkpoint -name] set pos [get_current_checkpoint -position] report_app_options -non_default \\ >./checkpoint/$name.$pos.app_options.rpt Defining Checkpoint Actions To define a checkpoint action, use the create_checkpoint_action command in your checkpoint.config.tcl file. Specify a unique name for the action and define the Tcl commands that constitute the action. 55 Adding Changes to a Script With Checkpoints Feedback The following example defines a checkpoint action named gropto, which enables global- route based buffering: create_checkpoint_action gropto { set_app_options -name place_opt.initial_drc.global_route_based \\ -value true The next example defines a checkpoint action named placer_high_effort_cong, which runs high-effort congestion reduction: create_checkpoint_action placer_high_effort_cong { set placer_command [get_current_checkpoint -script] set cong_option \"-congestion_effort high\" eval $placer_command $cong_option Notice the use of the get_current_checkpoint -script command and option, which retrieves the command originally enwrapped by the checkpoint and sets its congestion effort to high ( -congestion_effort high ). The -script option is typically used to define actions that replace the contents of a command. In this example, the action modifies the -congestion_effort option of the command that is enwrapped by the checkpoint associated with this action."}
{"instruction": "How do I Anchoring Relative Placement Groups", "input": "", "output": "By default, the Fusion Compiler tool can place a relative placement group anywhere within the core area. You can control the placement of a top-level relative placement group by anchoring it. To anchor a relative placement group, use the set_rp_group_options command with the -x_offset and -y_offset options. The offset values are float values, in microns, relative to the lower-left corner in the core area. If you specify both the x- and y-coordinates, the group is anchored at that location. If you specify only one coordinate, the Fusion Compiler tool determines the placement by maintaining the specified coordinate and sliding the group along the line passing through the unspecified coordinate. To specify a corner of relative placement group to anchor it by, use the -anchor_corner option. The tool places the relative placement group such that the corner specified by this option is placed on the anchor point specified by the -x_offset and -y_offset options. The settings for the -anchor_corner option are as follows, and are shown in Figure 172 bottom_left The anchor point of the relative placement group is set to its bottom-left corner. The default is the bottom-left corner. bottom_right The anchor point of the relative placement group is set to its bottom-right corner. 793 Specifying Options for Relative Placement Groups Feedback top_left The anchor point of the relative placement group is set to its top-left corner. top_right The anchor point of the relative placement group is set to its top-right corner. rp_location The anchor point of the relative placement group is the element in the relative placement group at the position specified by the -anchor_row and -anchor_column options. When you use the -anchor_corner rp_location setting, the position specified with the -anchor_row and -anchor_column options must contain a cell, keepout, or a relative placement hierarchy. Figure 172 Bottom-Left, Bottom-Right, Top-Left and Top-Right Anchor Corners Bottom-left anchor corner Bottom-right anchor corner Top-left anchor corner Top-right anchor corner For example, to anchor a relative placement by its bottom let corner at location (100, 100), as shown Figure 173, use the following command: fc_shell> set_rp_group_options misc1 -anchor_corner bottom_left \\ -x_offset 100 -y_offset 100 794 Specifying Options for Relative Placement Groups Feedback Figure 173 Anchored Relative Placement Group I33 I32 I34 misc1 I30 I31 I35 I43 I42 I44 I40 I41 I45 I53 I52 I54 I50 I51 I55 (100,100)"}
{"instruction": "How do I Displaying ECO Shapes in the GUI", "input": "", "output": "When you use the RedHawk mesh add command to add virtual PG meshes in the top block for the current subblock, by default the virtual PG meshes created by the RedHawk mesh add command are not shown as layout objects in the GUI. Therefore, these GUI shapes cannot be queried using layout object collection commands (such as, get_shapes ), and are not saved to the design library when you save the block. To save ECO shapes along with rail results and display them in the GUI, enable the rail.display_eco_shapes application option, like set_app_options -name rail.display_eco_shapes -value true Note: The mesh add command is available only in RedHawk, not in RedHawk SC. Therefore, the tool issues an error message when you enable both the rail.enable_redhawk_sc and rail.display_eco_shapes application options. To display ECO shapes in GUI, you must first enable the RedHawk signoff license key by setting the rail.allow_redhawk_license_checkout application option to true. Otherwise, an error message is issued. To add virtual PG meshes and display the created ECO shapes in the GUI, 1. Prepare a script file (such as, mesh.tcl) that contains the mesh add command. 2. Run design setup with the mesh.tcl script file. fc_shell> set_rail_command_options -script_file mesh.tcl \\ -command setup_design -order after_the_command The tool generates the RedHawk script file and sources the mesh.tcl file after design setup. 3. Perform rail analysis using the following command: fc_shell> analyze_rail -nets -voltage_drop 4. Run the open_rail_result command to load the design data and analysis results. 5. Run the gui_start command to open the Fusion Compiler GUI. In the GUI layout window, choose View > Map and select the map to display. You can now display and query the ECO shapes that are created by the RedHawk mesh add command in the GUI. Script Examples 938 Voltage Hotspot Analysis Feedback The following script displays ECO shapes in the GUI by using the set_rail_command_option command. ## Open design ## open_block link_block ## Specify taps ## create_taps ## Specify RedHawk Fusion input files or variables ## set_app_options -name rail.enable_redhawk -value 1 set_app_options -name rail.redhawk_path -value set_app_options -name rail.disable_timestamps -value true set_app_options -name rail.display_eco_shapes -value true set_rail_command_options -script_file mesh.tcl -command \\ setup_design... ## Analyze## analyze_rail -voltage_drop... -nets {VDD VSS} ## Check GUI ## open_rail_result The following script displays ECO shapes in the GUI by using a RedHawk script. ## Open design ## open_block link_block ## Specify taps ## create_taps ## Specify RedHawk Fusion input files or variables ## set_app_options -name rail.enable_redhawk -value 1 set_app_options -name rail.redhawk_path -value set_app_options -name rail.disable_timestamps -value true set_app_options -name rail.display_eco_shapes -value true ## Analyze ## analyze_rail -voltage_drop... -nets {VDD VSS} -script_only ## Modify the script.tcl containing mesh add command ## analyze_rail -redhawk_script_file ## Check GUI ## open_rail_result"}
{"instruction": "How do I Setting Options for Fixing Isolated Vias", "input": "", "output": "Before you run the signoff_fix_isolated_via command, configure the run by setting the application options shown in Table 51. To set the application options, use the set_app_options command. To see the current settings, use the report_app_options command. 742 Automatically Fixing Isolated Vias Feedback Table 51 Application Options for Signoff Isolated Via Fixing Application option Default Description signoff. fix_isolated_via. isolated_via_max_range (required) N/A Specifies the distance in microns within which a neighboring via must exist on each via layer. If a neighboring via is not found within this distance, a via is considered an isolated via and the command tries to add a fixing via within the specified distance. signoff. fix_isolated_via. avoid_net_types {clock pg} Specifies the types of nets to avoid when fixing isolated vias. Specify a list that contains one or more of the following values: clock pg, and none signoff. fix_isolated_via. run_dir signoff_fix_isolated_via_run Specifies the run directory, which contains the files generated by the signoff_fix_isolated_via command. You can specify either a relative path, in which case the directory is created under the current working directory, or an absolute path. signoff. fix_isolated_via. user_defined_options (none) Specifies additional options for the IC Validator command line. The string that you specify in this option is added to the command line used to invoke the IC Validator tool. The Fusion Compiler tool does not perform any checking on the specified string."}
{"instruction": "How do I Removing the Threshold-Voltage Filler Cell Information", "input": "", "output": "To remove the filler cell insertion rules and the threshold-voltage type annotations, use the -clear_vt_information option with the create_vtcell_fillers command."}
{"instruction": "How do I Controlling the Tiling Within Relative Placement Groups", "input": "", "output": "To control the tiling of objects within a relative placement group, use the set_rp_group_options -tiling_type command with the settings shown in the following table. Table 58 Controlling Placement With the set_rp_group_options -tiling_type Command To do this Use this setting Tile objects in a bit-slice pattern and preserve both the row and column alignment. The height of a row is determined by the tallest object in the row The width of a column is determined by the widest object in the column bit_slice (Default) Horizontally compress the objects in each row and maintain row alignment. horizontal_compression Vertically compress the objects in each column and preserve the column alignment vertical_compression 800 Specifying Options for Relative Placement Groups Feedback Figure 180 Bit-Slice Placement Versus Horizontal or Vertical Compression Bit-slice placement Vertical compression Horizontal compression The setting of the -tiling_type option is not propagated from a parent group to child groups."}
{"instruction": "How do I Specifying Logical Design Rule Constraints", "input": "", "output": "Minimum capacitance, maximum capacitance, and maximum transition are logical design rule constraints that your design must meet to function as intended. They are technology- specific restrictions that are specified in the logic libraries. However, you can specify more restrictive design rule constraints by using the constraint commands given in Table 7 During optimization, the Fusion Compiler tries to meet the design rule constraints, even if it means violating optimization constraints such as timing, power, and area goals; these design rule constraints have a higher priority. After optimization, you can use the reporting commands given in Table 7 to identify design rule constraint violations in a block. Table 7 Design Rule Commands To do this Use this command Specify the minimum allowed capacitance for input ports, library cell pins, leaf cell pins, clocks, or blocks set_min_capacitance Specify the maximum allowed capacitance for input ports, library cell pins, leaf cell pins, clocks, or blocks set_max_capacitance Specify the maximum allowed signal transition time for input ports, library cell pins, leaf cell pins, clocks, or blocks set_max_transition Remove a user-specified minimum capacitance constraint remove_min_capacitance 134 Specifying Clock Gating Constraints Feedback Table 7 Design Rule Commands (Continued) To do this Use this command Remove a user-specified maximum capacitance constraint remove_max_capacitance Remove a user-specified maximum transition constraint remove_max_transition Report minimum capacitance constraint violations report_constraints -min_capacitance Report maximum capacitance constraint violations report_constraints -max_capacitance Report maximum transition constraint violations report_constraints -max_transition Specify the connection requirements for the network that is connected to the specified ports or library cell pins For ports: set_connection_class For pins: set_attribute \\ -name connection_class Note: The maximum fanout design rule constraint is not honored by the Fusion Compiler tool. However, you can specify a maximum fanout for the data paths in a block by using the opt.common.max_fanout application option. This is a soft optimization constraint. During optimization the tool tries to ensure that data path cells do not drive more than the specified maximum fanout."}
{"instruction": "How do I Performing Real Metal Fill Extraction", "input": "", "output": "To enable metal fil extractionreal real metal fill extraction, 1. Associate non-emulation TLUPlus files with the timing corners by using the set_parasitic_parameters command, as described in the Fusion Compiler Timing Analysis User Guide 2. Enable real metal fill extraction by using the following command: fc_shell> set_extraction_options \\ -real_metalfill_extraction floating For more information about performing extraction in the Fusion Compiler tool, see the Fusion Compiler Timing Analysis User Guide 741 Automatically Fixing Isolated Vias Feedback"}
{"instruction": "How do I Viewing PG Electromigration Analysis Results", "input": "", "output": "When PG electromigration analysis is complete, you can check for current violations by displaying a PG electromigration map or checking the generated errors in the error browser. Displaying the PG Electromigration Map Checking PG Electromigration Violations"}
{"instruction": "How do I Trunk Splitting", "input": "", "output": "The following Custom Router application options determine whether bus trunks will be split when routing through obstacles and how the bits will be split. custom.route.bus_split_ignore_width custom.route.bus_split_even_bits The custom.route.bus_split_ignore_width application option specifies the wire width threshold of any obstructing power grid or route that triggers the bus trunk to be split into more than one section. The custom.route.bus_split_even_bits application option requires that you set the custom.route.bus_split_ignore_width application option. If the custom.route.bus_split_ignore_width requirement is met, you can use the custom.route.bus_split_even_bits application option to control whether automatic bus splitting routes an even number of nets between pre-routes (power stripes). In the following example, the bus trunk consists of four bits and the custom.route.bus_split_ignore_width application option is set. The spacing between the power and ground rails can accommodate three bits only. Figure 163 a shows the two possible results when the custom.route.bus_split_even_bits application option is turned off. Figure 163 b shows the result when the custom.route.bus_split_even_bits application option is turned on. Figure 163 Splitting Bus Trunk to Route Through Power and Ground Rails 768 Using Custom Routing Application Options Feedback"}
{"instruction": "How do I Hierarchical Synthesis Flow When Floorplans are Available", "input": "", "output": "To partition and plan the top-level design and create the lower-level blocks for subsequent bottom-up synthesis, when the floorplans of subblock and top-level design are available, perform the following steps: Figure 188 Hierarchical Synthesis Flow When Floorplans are Available 1. Read in the full chip design and apply constraints as shown in the following example: fc_shell> set REF_LIBS \"stdcell.ndm macro.ndm\" fc_shell> create_lib TOP -technology techfile \\ -ref_libs $REF_LIBS fc_shell> analyze -format verilog $rtl_files fc_shell> elaborate TOP fc_shell> set_top_module TOP fc_shell> load_upf fullchip.upf fc_shell> read_sdc fullchip.sdc 2. For the design partitions, split the constraints as shown in the following example: fc_shell> set_budget_options -add_blocks {BLOCK1 BLOCK2} fc_shell> split_constraints 3. Create the subblock design libraries with design information and enable block-specific reference library setup as shown in the following example: fc_shell> copy_lib -to_lib BLOCK1.nlib -no_design fc_shell> copy_lib -to_lib BLOCK2.nlib -no_design fc_shell> set_attribute -objects BLOCK1.nlib \\ 821 Performing Hierarchical Synthesis Using Abstracts Feedback -name use_hier_ref_libs -value true fc_shell> set_attribute -objects BLOCK2.nlib \\ -name use_hier_ref_libs -value true fc_shell> save_lib -all 4. Create the subblock design partitions as shown in the following example: fc_shell> commit_block -library BLOCK1.nlib BLOCK1 fc_shell> commit_block -library BLOCK2.nlib BLOCK2 fc_shell> save_lib -all 5. Load the UPF and SDC constraints for the unmapped subblocks as well as the top- level, which are generated by the split_constraints command earlier as shown in the following example: fc_shell> set_constraint_mapping_file./split/mapfile fc_shell> load_block_constraints -all_blocks -type SDC \\ -type UPF -type CLKNET fc_shell> save_lib -all 6. Load the floorplan for the subblocks and top-level design. 7. Run the compile_fusion command until logic optimization for the subblocks and top- level design is complete as shown in the following example: fc_shell> compile_fusion -to logic_opto 8. Perform standard cell placement followed by the pin assignment, timing estimation and budgeting. 9. After completing the design planning operations, rebuild the subblock and top-level design by opening the elaborated RTL NDM, loading floorplan, feedthroughs and budgets. Note: For details about each of the design planning operation, see the Design Planning User Guide"}
{"instruction": "How do I Controlling Clock Latencies, Path Groups, and Boundary Paths", "input": "", "output": "To specify a maximum delayed latency for useful skew computation, set the ccd.max_postpone application option to a specific value, as shown in the following example: fc_shell> set_app_options \\ ccd.max_postpone 50 256 Running Concurrent Clock and Data Optimization Feedback To specify a maximum advanced latency for useful skew computation, set the ccd.max_prepone application option to a specific value, as shown in the following example: fc_shell> set_app_options \\ ccd.max_prepone 100 To omit useful skew computation for specific path groups, specify one or more path groups with the ccd.skip_path_groups application option as follows: fc_shell> set_app_options ccd.skip_path_groups path_group_list To disable concurrent clock and data optimization for boundary timing paths, set the ccd.optimize_boundary_timing application to false, changing it from its default of true. All optimization on I/O paths and latencies for boundary registers will not be adjusted to improve register to register timing. fc_shell> set_app_options ccd.optimize_boundary_timing false"}
{"instruction": "How do I Defining Voltage Areas", "input": "", "output": "A voltage area is a physical placement area for the cells associated with a power domain. For multivoltage designs, the power domains are defined in the UPF specification. For single-voltage designs, the tool creates a default power domain when you read the Verilog netlist and associates it with a default voltage area, which comprises the core area of the block. The placer treats a voltage area the same as an exclusive move bound; it must place the cells in a voltage area within a specified region and it must place all other cells outside of the voltage area. Voltage areas can be rectangular or rectilinear. In addition, they can be disjoint, nested, or overlapping. For overlapping voltage areas, the effective shape of each voltage area is determined by the stacking order of the voltage area shapes. To define a voltage area, use the create_voltage_area command. When you define a voltage area, at a minimum, you must specify the power domains associated with the voltage area. To specify the power domains, use the -power_domains option. You can specify one or more power domains; however, all specified power domains must have the same primary supply net. If you specify a single power domain, the name of the voltage area is derived from the name of the power domain. If you specify multiple power domains, you must specify a name for the voltage area by using the -name option. A voltage area consists of one or more rectangular or rectilinear shapes, which can be abutted, disjoint, or overlapping. To define the boundaries of these shapes, use the -region option with the create_voltage_area command (if you are creating a new voltage area) or the create_voltage_area_shape command (if you are adding shapes to an existing voltage area). Note that you can specify one or more shapes when using the create_voltage_area command, but only a single shape in each create_voltage_area_shape command. To specify the boundary of a rectangle shape, use the following format to specify its lower-left and upper-right corners: {{ llx lly } { urx ury }} To specify the boundary of a rectilinear shape, use the following format to specify the coordinates of its vertices: {{ x1 y1 } { x2 y2 } { x3 y3 } { x4 y4 }...} If a voltage area consists of multiple abutting or overlapping shapes, you can merge the shapes into a minimum set of disjoint shapes based on the stacking order of the shapes. For information about how to merge the voltage area shapes, see Merging Voltage Area Shapes The tool also uses the stacking order to resolve overlapping shapes from different voltage areas. For information about resolving overlapping voltage areas, see Resolving Overlapping Voltage Areas 120 Setting Up Multivoltage Designs Feedback To ensure that no shorts occur at the boundaries of the voltage areas, you can define guard bands for the voltage areas, which act as hard keepout margins surrounding the voltage areas. If you define guard bands for a voltage area shape, the guard bands are included in the effective boundary of the shape; however, they are not included in the effective placement area of the voltage area. For information about defining guard bands, see Defining Guard Bands To modify an existing voltage area, use the set_voltage_area command, as described in Modifying Voltage Areas Multivoltage designs typically have power domains that are shut down and powered up during the operation of the chip while other power domains remain powered up. When dealing with shutdown domains, there can be some situations in which certain cells in the shutdown portion need to continuously stay active, such as for implementing retention registers, isolation cells, retention control paths, and isolation enable paths. These cells are referred to as always-on cells. To define a special placement area for always-on cells (an always-on well) within a voltage area, define an exclusive move bound within the boundary of the voltage area. For information about defining exclusive move bounds, see Defining Move Bounds After creating the voltage areas, run the check_mv_design command to verify that the design does not have any multivoltage violations."}
{"instruction": "How do I Displaying Block-Level Rail Results", "input": "", "output": "After you perform rail analysis on the top-level design, the tool saves the analysis results in the top-level rail database. To locate issues that are reported in a block-level design, run the open_rail_result command with the -top_design and -block_instance options to excerpt block-level instance data from the top-level rail database. The tool then displays maps for the specified block instances based on the extracted block-level rail analysis data. Note: The excerpt of the block-level rail results is saved in memory and is deleted when you exit the current session. The following example opens the rail result named REDHAWK_RESULT in the./ RAIL_DATABASE directory; the result is the rail analysis result for the top design named bit_coin. The example then creates an excerpt of rail analysis data for the block instance slice_5. Note that in this example, the block design of instance slice_5 has to be opened, not the top-level design. fc_shell> open_lib block.nlib fc_shell> open_block block fc_shell> set_app_options -name rail.database -value RAIL_DATABASE fc_shell> open_rail_result REDHAWK_RESULT \\ -top_design bit_coin \\ -block_instance slice_5 fc_shell> report_rail_result"}
{"instruction": "How do I Getting Information About Commands", "input": "", "output": "The following online information resources are available while you are using the Fusion Compiler tool: Command help, which is information about an Fusion Compiler command Man pages See Also Viewing Man Pages"}
{"instruction": "How do I Routing Secondary Power and Ground Pins", "input": "", "output": "To use Zroute to perform secondary power and ground pin routing, 1. Verify that the secondary power and ground pins have the appropriate attributes in the standard cell frame views. 2. Set the routing constraints for secondary power and ground pin routing. 3. Perform secondary power and ground pin routing by using the route_group command. The following topics describe these steps."}
{"instruction": "How do I Performing Power or Area Recovery on the Clock Network", "input": "", "output": "If you enable concurrent clock and data optimization for the clock_opt command, the tool performs clock power recovery on clock cells and registers during the final_opt stage. 374 Implementing Clock Trees and Performing Post-CTS Optimization Feedback If you do not enable concurrent clock and data optimization, you can enable clock power recovery by using the following application option setting: fc_shell> set_app_options \\ -name clock_opt.flow.enable_clock_power_recovery \\ -value power Before you perform power recovery using this technique, you must 1. Enable scenarios for dynamic, leakage, or total power optimization by using the -dynamic_power and - leakage_power options of the set_scenario_status command 2. (Optional) Provide a switching activity by using the read_saif command If you do not provide switching activity, the tool uses default switching activity for dynamic power recovery. Instead of power recovery, you can enable area recovery on the clock cells and registers during the final_opt stage clock_opt command by using the following application option setting: fc_shell> set_app_options \\ -name clock_opt.flow.enable_clock_power_recovery \\ -value area"}
{"instruction": "How do I Considering the Effects of Cell Pins During Placement", "input": "", "output": "When you specify a technology node setting of 7+ s5, or s4 by using the set_technology -node command, you can specify that the tool uses a technology- specific pin-cost model during placement by setting the place.coarse.pin_cost_aware application option to true. The default is false. When you enable this feature, during placement, the tool tries to improve pin accessibility by using a technology-specific model to predict the routing resources required to access each pin. For all other technology nodes, you can control the maximum local pin density during placement by setting the place.coarse.pin_density_aware application option to true The default is false Table 11 Settings for Controlling the Effects of Pins During Placement set_technology -node place.coarse. pin_cost_aware place.coarse. pin_density_aware The tool does this 7+ s5, or s4 true true or false Performs technology-specific pin-cost-aware placement 7+ s5, or s4 false true Performs pin-density-aware placement 7+ s5, or s4 false false Does not consider the effects of cell pins during placement Any other setting true or false true Performs pin-density-aware placement 157 Specifying Placement Settings Feedback Table 11 Settings for Controlling the Effects of Pins During Placement (Continued) set_technology -node place.coarse. pin_cost_aware place.coarse. pin_density_aware The tool does this Any other setting true or false false Does not consider the effects of cell pins during placement"}
{"instruction": "How do I Contents", "input": "", "output": ".....................131 Inserting Isolation Cells....................................... 131 Associating Power Strategies With Existing Multivoltage Cells......... 132 Controlling the Placement of Multivoltage Cells........................132 Enabling Improved Buffering for Multivoltage Nets..................... 132 Analyzing Multivoltage Information..................................132 Specifying Timing Constraints and Settings.............................. 133 Specifying Logical Design Rule Constraints.............................. 134 Specifying Clock Gating Constraints....................................135 Specifying Physical Constraints for Placement and Legalization.............. 137 Defining Keepout Margins........................................ 137 Defining an Outer Keepout Margin.............................. 138 Contents Feedback Defining an Inner Keepout Margin...............................139 Defining Area-Based Placement Blockages...........................139 Defining a Hard Placement Blockage............................ 140 Defining a Hard Macro Placement Blockage....................... 141 Defining a Soft Placement Blockage............................. 141 Defining a Partial Placement Blockage........................... 142 Define a Blockage of a Predefined Category.......................142 Defining Blockages That Exclude Registers....................... 143 Defining Blockages That Exclude Relative Placement Groups......... 144 Defining Blockages That Allow Relative Placement Cells Only......... 144 Defining Blockages That Allow Buffers Only....................... 144 Querying Placement Blockages................................. 145 Removing Placement Blockages................................ 145 Defining Placement Bounds....................................... 145 Defining Move Bounds........................................146 Defining Group Bounds....................................... 148 Querying Placement Bounds................................... 148 Removing Placement Bounds.................................. 149 Defining Placement Attractions.....................................149 Specifying Locations for Unmapped Cells............................ 150 Defining Cell Spacing Constraints for Legalization..................... 151 Reporting Cell Spacing Constraints.............................. 153 Removing Cell Spacing Constraints............................. 153 Specifying Placement Settings........................................ 153 Performing Placement With Inaccurate Constraints at Early Stages........ 154 Generating Automatic Group Bounds for Clock Gating Cells..............154 Controlling the Placement Density.................................. 155 Controlling Congestion-Driven Restructuring During Placement........... 156 Reducing Congestion............................................ 156 Considering Wide Cell Density During Placement...................... 157 Considering the Effects of Cell Pins During Placement.................. 157 Considering the Congestion Effects Due to the Nondefault Routing Rules of Clock Nets.....................................................158 Considering the Effects of Clock Gating Cells of Sequential Arrays During Placement..................................................... 158 Considering Legalization Effects During Placement.....................158 Considering DFT Connections During Placement...................... 159 Considering the Dynamic Power QoR During Placement................ 159 Performing IR-Drop-Aware Placement............................... 159 Controlling IR-Drop-Aware Placement............................ 160 Spreading Repeater Cells During Placement..........................162 Contents Feedback Specifying Legalization Settings....................................... 162 Minimizing Large Displacements During Legalization................... 163 Optimizing Pin Access During Legalization........................... 163 Enabling Advanced PG Net Checks................"}
{"instruction": "How do I Using a Hybrid Routing Flow", "input": "", "output": "In the hybrid flow, Custom Router is used to perform trunk routing without completing some pin connections, and then Zroute is used to complete the pin connections. This flow enables the use of Custom Router for prerouting while avoiding or reducing inconsistency and DRC violations associated with differences in the pin connection behavior between the two tools. To enable the hybrid routing flow, set the custom.route.skip_connect_pin_type application option to one or more of the following values, depending on your routing requirements. By default, this application option is set to none, which disables the hybrid routing flow. auto Custom Router identifies the routability of the pins in the block, and then completes the pin connections for the pins that can be connected. all Custom Router does not complete the pin connections for all pins in the block. stdcell Custom Router completes the pin connections for all pins in the block, except for standard cell pins. io Custom Router completes the pin connections for all pins in the block, except for I/O cell pins. macro Custom Router completes the pin connections for all pins in the block, except for macro pins. By default, when the hybrid flow is enabled, Custom Router determines how much space to leave between a route and an unconnected pin. To specify the maximum distance, 775 Using a DDR Routing Flow Feedback use the custom.route.distance_to_net_pin application option. Set the value in the following format: net_name distance The following script uses Custom Router for trunk routing and Zroute for all pin connections. set_app_options -name custom.route.skip_connect_pin_type -value all route_custom -nets {net1 net2} route_eco -nets {net1 net2} remove_redundant_shapes -nets {net1 net2} route_detail -incremental true The following script uses Custom Router for trunk routing and pin connections except standard cell pins, and then uses Zroute for standard cell pin connections. set_routing_rule -min_routing_layer m3 \\ -max_routing_layer m9 \\ -min_layer_mode allow_pin_connection \\ -max_layer_mode hard {net1 net2} set_app_options -name custom.route.skip_connect_pin_type \\ -value stdcell set_app_options -name custom.route.distance_to_net_pin \\ -value {{{net1 5.0} {net2 3.0}}} route_custom -nets {net1 net2} route_eco -nets {net1 net2} remove_redundant_shapes -nets {net1 net2} route_detail -incremental true"}
{"instruction": "How do I Removing Voltage Areas", "input": "", "output": "To remove voltage areas from a block, use the remove_placement_blockage comandcomandsremove_placement_blockage remove_voltage_areas command. To remove all voltage areas from a block, use the -all option. To remove specific voltage areas from a block, specify the voltage area names. 130 Setting Up Multivoltage Designs Feedback"}
{"instruction": "How do I Using Routing Guides to Control the Routing Direction", "input": "", "output": "You can use a routing guide to control the routing direction within the routing guide boundary, either by requiring routes to be in the preferred direction within the routing guide boundary or by switching the preferred direction within the routing guide boundary. To force the router to route all nets in the preferred direction within the routing guide boundary, use the -preferred_direction_only option with the create_routing_guide command. You can use this type of routing guide to prevent wrong-way jog wires on specific layers. By default, this routing guide applies to all layers within the routing guide boundary. To require preferred direction routing only for specific layers, use the -layers option to specify the affected layers. 475 Routing Constraints Feedback For example, to force the router to use only the preferred direction on the M4 layer within the rectangle with its lower-left corner at (0, 0) and its upper-right corner at (100, 100), use the following command: fc_shell> create_routing_guide -boundary {{0.0 0.0} {100.0 100.0}} \\ -layers {M4} -preferred_direction_only To switch the preferred routing direction within the routing guide boundary, use the -switch_preferred_direction option with the create_routing_guide command. You can use this type of routing guide to allow routing over macros, which might reduce congestion for a block that contains much detour routing. By default, this routing guide applies to all layers within the routing guide boundary. To switch the preferred routing direction only for specific layers, use the -layers option to specify the affected layers. For example, to switch the preferred routing direction for the M1 and M2 layers within the rectangle with its lower-left corner at (0, 0) and its upper-right corner at (100, 100), use the following command: fc_shell> create_routing_guide -boundary {{0.0 0.0} {100.0 100.0}} \\ -layers {M1 M2} -switch_preferred_direction Note: If a switch-preferred-direction routing guide overlaps with a preferred- direction-only routing guide, the switch-preferred-direction routing guide takes precedence."}
{"instruction": "How do I Setting Up Clock Gating", "input": "", "output": "The clock gating feature only supports latch-based integrated clock-gating cells. Tool- inserted clock-gating cells do not have a wrapper hierarchy. 293 Setting Up Clock Gating Feedback Clock-gating optimization uses the following defaults: The maximum fanout is infinite. The minimum bitwidth is three. A latch-based precontrol cell for both positive-edge and negative-edge triggered flip- flops is used as a clock-gating cell. If only positive-edge or negative-edge clock-gating cells are available, the tool inserts inverters on both sides of the clock-gating cell. You must load a design and libraries before you can set up clock-gating constraints. To set up clock gating, follow these steps: 1. Load the design and libraries 2. Set the style by using the set_clock_gate_style command 3. Set the options by using the set_clock_gating_options command 4. Specify objects to be included or excluded from clock gating by using the set_clock_gating_objects command 5. Allow other clock-gating cell types for optimization by using the following command: fc_shell> set_lib_cell_purpose -include cts [get_lib_cells...] For more information, see the following topics: Setting the Clock-Gating Style Setting Clock-Gating Options Enabling or Disabling Clock Gating on Design Objects Clock-Gating Enable Source Selection User-Driven Enable Exclusion Report Clock Gating Options"}
{"instruction": "How do I Merging Voltage Area Shapes", "input": "", "output": "To merge the voltage area shapes into a minimum set of disjoint shapes, use the -merge_regions option with the create_voltage_area create_voltage_area_shape or set_voltage_area command. When you use the create_voltage_area -merge_regions command, the merges the shapes specified with the -region option. When you use the create_voltage_area_shape -merge_regions command, the merges the shape specified with the -region option and the existing shapes of the specified voltage area. When you use the set_voltage_area -merge_regions command, the tool merges all existing shapes of the specified voltage area. The tool merges the voltage area shapes based on their stacking order. By default, the stacking order is the order in which you define the shapes, with the last shape defined on top. The merged shape replaces the top shape of a set of abutting or overlapping shapes; the other shapes in the set are removed and are no longer associated with the voltage area. 121 Setting Up Multivoltage Designs Feedback For example, assume that you use the following command to create a voltage area comprising three rectangle shapes, as shown on the left side of Figure 14 fc_shell> create_voltage_area -power_domains {PD1} \\ -region { {{0 0} {10 10}} {{10 0} {30 10}} {{15 5} {35 15}} } {PD1} fc_shell> get_voltage_area_shapes -of_objects PD1 {VOLTAGE_AREA_SHAPE_1 VOLTAGE_AREA_SHAPE_2 VOLTAGE_AREA_SHAPE_3} After you use the -merge_regions option to merge these shapes, the voltage area consists of a single rectilinear shape, as shown on the right side of Figure 14. The merged voltage area shape is named VOLTAGE_AREA_SHAPE_3, which was the last voltage area shape defined when the voltage area was created. fc_shell> set_voltage_area PD1 -merge_regions Information: Merging abutted and overlapping shapes in voltage_area 'PD1'. (NDMUI-154) fc_shell> get_voltage_area_shapes -of_objects PD1 {VOLTAGE_AREA_SHAPE_3} Figure 14 Merging Voltage Area Shapes To report the stacking order of the voltage area shapes, use the report_voltage_areas -verbose command. To modify the stacking order of the voltage area shapes, use the set_voltage_area_shape command, as described in Modifying the Stacking Order"}
{"instruction": "How do I Removing Repeater Groups", "input": "", "output": "To remove a group of repeaters, use the remove_eco_repeater command. The nets are restored to their original names and routes shapes."}
{"instruction": "How do I Minimizing Large Displacements During Legalization", "input": "", "output": "To minimize large displacements of cells during legalization, enable Orientation optimization by setting the place.legalize.optimize_orientations application option to true When you do so, the tool considers flipping the orientations of cells to reduce the displacements during legalization. Stream placement by setting the place.legalize.stream_place application option to true When you do so, the tool moves many cells a small distance, to avoid moving a single cell a large distance during legalization. You can further control stream placement by using the place.legalize.stream_effort and place.legalize.stream_effort_limit application options."}
{"instruction": "How do I Generating Interclock Delay Balancing Constraints Automatically", "input": "", "output": "The Fusion Compiler tool can automatically generate the interclock delay balancing constraints based on the timing relationships between the clocks. To automatically generate the interclock delay balancing constraints, use the following command: fc_shell> derive_clock_balance_constraints This command identifies clocks that have interclock timing paths and places them in the same balance group. After running this command, use the report_clock_balance_groups command to report the generated interclock delay balancing constraints, as described in Reporting Clock Balance Groups. If necessary, you can modify the clock balance groups as described in Defining the Interclock Delay Balancing Constraints By default, the tool considers all timing paths when identifying the timing relationships between the clocks. To consider only those timing paths with slack less than a specified value, use the -slack_less_than option with the derive_clock_balance_constraints command. For example, to generate interclock balancing constraints only for paths with slack less than -0.2 ns, use the following command: fc_shell> derive_clock_balance_constraints -slack_less_than -0.2 Assume you run this command on a block for which clock A has a timing relationship only with clock B and the worst negative slack (WNS) of this group of timing paths is -0.1 ns and clock C has a timing relationship only to clock D and the WNS of this group of timing paths is -0.3 ns. The command considers only those timing paths with slack less than -0.2 ns, so it defines a single balance group that contains clocks C and D. Clocks A and B are not constrained because the timing paths between them have slack greater than -0.2 ns."}
{"instruction": "How do I Routing Rules of Clock Nets", "input": "", "output": "To improve timing and reduce crosstalk, nondefault routing rules are used extensively for routing clock nets. However, these nondefault routing rules require additional space, which can increase the congestion after clock routing. To consider the effects of the nondefault routing rules of the clock nets during placement, set the place.coarse.ndr_area_aware application option to true"}
{"instruction": "How do I Excluding Boundary Paths", "input": "", "output": "By default, the tool performs concurrent clock and data optimization on all paths in a block. However, you might want to exclude paths that are connected to boundary registers, which are registers in the transitive fanout of input ports and transitive fanin of output ports. To exclude boundary paths from concurrent clock and data optimization, set the ccd.optimize_boundary_timing application option to false When you do so, you can selectively ignore the boundary paths of some ports during boundary path exclusion by using the ccd.ignore_ports_for_boundary_identification application option. The following example disables concurrent clock and data optimization for all boundary paths except for those connected to the ports named IN_A and OUT_A: fc_shell> set_app_options -name ccd.optimize_boundary_timing \\ -value false fc_shell> set_app_options \\ -name ccd.ignore_ports_for_boundary_identification \\ -value {IN_A OUT_A} Even when you disable concurrent clock and data optimization on boundary registers, the tool can still optimize the clock tree fanin cone of these boundary registers, when doing so improves the timing QoR of other internal registers that share the same clock paths. To prevent the clock tree fanin of boundary registers from changing, set the ccd.optimize_boundary_timing_upstream application option to false. However, doing so heavily restricts the scope of concurrent clock and data optimization. These application option settings affect concurrent clock and data optimization performed during the place_opt clock_opt, and route_opt commands. 377 Implementing Clock Trees and Performing Post-CTS Optimization Feedback"}
{"instruction": "How do I Tapoffs", "input": "", "output": "Two Custom Router application options allow you to control tapoff operations: custom.route.bus_tap_off_enable custom.route.bus_tap_off_shielding The custom.route.bus_tap_off_enable application option connects pins to the bus trunk. If the custom.route.bus_tap_off_enable application option is turned on, you can use the custom.route.bus_tap_off_shielding application option to add shielding to the bus tapoffs."}
{"instruction": "How do I Mask Constraints", "input": "", "output": "Mask constraints indicate the mask requirements for the metal shapes of the physical pins and nets in a block that uses multiple-patterning technology. These mask requirements drive placement and routing to ensure that the resulting layout is multiple-patterning compliant. Note: Mask constraints are used only for the precolored flow; they are not necessary in the uncolored flow. You can set mask constraints on timing-critical nets (net shapes, routing rules, and routing blockages) and vias. For nets, the mask constraint is defined in the mask_constraint attribute. For vias, the mask constraints are defined in the lower_mask upper_mask, and cut_mask attributes. Table 1 shows the supported values for these attributes. Table 1 Mask Constraint Values Attribute value Description same_mask This constraint means that the mask color is not yet been determined. Shapes with this attribute must be at least the multiple-patterning minimum spacing distance from any other colored metal shape. 43 Working With the 3DIC Compiler User Interfaces Feedback Table 1 Mask Constraint Values (Continued) Attribute value Description mask_one This constraint means that the shape has the mask1 color. Shapes with this attribute must be at least the multiple-patterning minimum spacing distance from other mask1-colored metal shapes. mask_two This constraint means that the shape has the mask2 color. Shapes with this attribute must be at least the multiple-patterning minimum spacing distance from other mask2-colored metal shapes. mask_three This constraint means that the shape has the mask3 color. Shapes with this attribute must be at least the multiple-patterning minimum spacing distance from other mask3-colored metal shapes. any_mask This constraint means that the shape is not colored. Shapes with this attribute must be at least the standard minimum spacing distance from other metal shapes; the multiple-patterning minimum spacing rules do not apply to these shapes."}
{"instruction": "How do I Defining Nondefault Routing Rules", "input": "", "output": "To define a nondefault routing rule, use the create_routing_rule command. When you define a nondefault routing rule, you must specify a name for the nondefault routing rule. You use the name to assign the nondefault routing rule to nets or clocks. The following topics describe how to create nondefault routing rules for various purposes: Defining Minimum Wire Width Rules Defining Minimum Wire Spacing Rules Defining Minimum Via Spacing Rules Specifying Nondefault Vias Specifying Mask Constraints Defining Shielding Rules Reporting Nondefault Routing Rule Definitions Removing Nondefault Routing Rules Modifying Nondefault Routing Rules You can create a single routing rule that serves multiple purposes. In addition, you can assign multiple nondefault routing rules to a net. Defining Minimum Wire Width Rules You can define nondefault minimum wire width rules that are stricter than the minimum width rules defined in the technology file. Nondefault minimum width rules are hard constraints, which must be met during routing. Note: If you specify a nondefault width that violates the signalRouteMaxWidth setting in the technology file, the tool ignores the nondefault width. 495 Routing Constraints Feedback The minimum width defined in a nondefault routing rule applies to all metal segments, including via enclosures. To avoid DRC violations, ensure that the enclosures for nondefault vias meet the minimum width rule. To define a minimum wire width rule, use the create_routing_rule command. You can specify the minimum width by specifying a multiplier that is applied to the default width for each layer, by specifying the minimum width in microns for each layer, or both. To use a multiplier to specify the minimum width, use the following syntax: create_routing_rule rule_name [-default_reference_rule | -reference_rule_name ref_rule -multiplier_width multiplier The multiplier value must be between 0.001 and 2000. The default width for each layer is determined from the reference rule, which is either the default routing rule or the reference rule specified in the -reference_rule_name option. For example, to define a nondefault routing rule named new_width_rule that uses the default routing rule as the reference rule and defines the nondefault width as two times the default width, use the following command: fc_shell> create_routing_rule new_width_rule -multiplier_width 2.0 To specify the minimum width values for each layer, use the following syntax: create_routing_rule rule_name [-default_reference_rule | -reference_rule_name ref_rule -widths { layer width layer width layer width Specify the routing layers by using the layer names from the technology file. You can specify a single width value per layer. Zroute uses the wire width from the reference rule, which is either the default routing rule or the reference rule specified in the -reference_rule_name option, for any layers not specified in the -widths option. For example, to define a nondefault routing rule named new_width_rule2 that uses the default routing rule as the reference rule and defines nondefault width rules for the M1 and M4 layers, use the following command: fc_shell> create_routing_rule new_width_rule2 \\ -widths {M1 0.8 M4 0.9} If you specify both with -multiplier_width option and the -widths option, the tool uses the -widths option to determine the base width, and then applies the multiplier to that value to determine the minimum width requirement. For example, to define a nondefault routing rule named new_width_rule3 that uses the default routing rule as the reference rule and defines the nondefault width as 0.8 for the 496 Routing Constraints Feedback M1 layer, 0.9 for the M4 layer, and two times the default width for all other layers, use the following command: fc_shell> create_routing_rule new_width_rule3 \\ -multiplier_width 2.0 -widths {M1 0.4 M4 0.45} Defining Minimum Wire Spacing Rules You can define nondefault minimum wire spacing rules that are stricter than the rules defined in the technology file. Nondefault wire spacing rules can be defined as hard constraints, which must be met, or as soft constraints, which Zroute tries to meet. Note: The spacing rules defined in the technology file are always considered hard constraints. By default, Zroute checks the nondefault spacing rules between signal nets and other signal nets, PG nets, and blockages, but not between shapes of the same signal net or between signal nets and shield wires for PG nets. For information about modifying these checks, see Configuring Nondefault Spacing Checks To define a minimum wire spacing rule, use the create_routing_rule command. You can specify the minimum spacing by specifying a multiplier that is applied to the default spacing for each layer, by specifying the minimum spacings in microns for each layer, or both. To use a multiplier to specify the minimum spacing, use the following syntax: create_routing_rule rule_name [-default_reference_rule | -reference_rule_name ref_rule -multiplier_spacing multiplier The multiplier value must be between 0.001 and 2000. The default wire spacing for each layer is determined from the reference rule, which is either the default routing rule or the reference rule specified in the -reference_rule_name option. For example, to define a nondefault routing rule named new_spacing_rule that uses the default routing rule as the reference rule and defines the nondefault spacing as two times the default spacing, use the following command: fc_shell> create_routing_rule new_spacing_rule \\ -multiplier_spacing 2.0 To specify the minimum spacing values for each layer, use the following syntax: create_routing_rule rule_name -spacings { layer spacing 11 spacing 12... spacing 1n layer spacing 21 spacing 22... spacing 2n... layer spacing n1 spacing n2...spacing nn } } -spacing_weight_levels { layer weight 11 weight 12... weight 1n 497 Routing Constraints Feedback layer weight 21 weight 22... weight 2n... layer weight n1 weight n2... weight nn } } Specify the routing layers by using the layer names from the technology file. You can define multiple spacing values per layer. Zroute uses the spacing values from the reference rule, which is either the default routing rule or the reference rule specified in the -reference_rule_name option, for any layers not specified in the -spacings option. If you specify more than one spacing value per layer, you must assign a weight to each spacing value by using the -spacing_weight_levels option. The valid weight values are low medium high, and hard. When you assign a weight level other than hard, the spacing rule is a soft spacing rule. By default, Zroute does not fix soft routing rule violations. To fix soft routing rules, you must map the weight levels to routing effort levels, as described in Specifying the Routing Effort for Soft Spacing Violations For example, to define a nondefault routing rule named new_spacing_rule2 that uses the default routing rule as the reference rule and defines nondefault spacing rules for the M1 and M4 layers, use the following command: fc_shell> create_routing_rule new_spacing_rule2 \\ -spacings { M1 {0.12 0.24} M4 {0.14 0.28} } \\ -spacing_weight_levels { M1 {hard medium} M4 {hard medium} } If you specify both with -multiplier_spacing option and the -spacings option, the tool uses the -spacings option to determine the base spacing, and then applies the multiplier to that value to determine the minimum wire spacing requirement. To limit spacing to one side of the net, use the -single_side_spacing option with the create_routing_rule command. For example, the following command creates single-side spacing rules on the M2, M3, and M4 metal layers METAL2, METAL3, and METAL4: fc_shell> create_routing_rule new_spacing_rule3 \\ -spacings {M2 1.300 M3 1.400 M4 1.500 } \\ -single_side_spacing \\ -widths {M1 0.230 M2 0.280 M3 0.280 M4 0.280 M5 0.280 M6 0.440} 498 Routing Constraints Feedback Configuring Nondefault Spacing Checks You can configure the checking of nondefault spacing rules by enabling or disabling checks between signal nets and other objects. In addition, you can ignore violations of nondefault spacing rules for short parallel distances. To honor nondefault spacing rules between shapes of the same signal net, set the route.detail.var_spacing_to_same_net application option to true To honor nondefault spacing rules between signal nets and shield wires for PG nets For all signal nets, set the route.common.ignore_var_spacing_to_shield application option to false For specific signal nets, use the -ignore_spacing_to_shield false option when you define the nondefault spacing rule with the create_routing_rule command To ignore nondefault spacing rules between signal nets and PG nets For all signal nets,"}
{"instruction": "How do I Recording the Changes Made to a Layout", "input": "", "output": "You can record the changes you make to a layout and generate a Tcl file containing the changes by using the record_layout_editing command, as shown in the following example: fc_shell> record_layout_editing -start fc_shell> remove_shapes RECT_32_0 fc_shell> record_layout_editing -stop -output layout_changes1.tcl You can make the following layout changes: Create or remove layout objects by using Tcl commands Set attributes by using the set_attribute command Move or resize objects by using the GUI With this feature, multiple users can make ECO changes to different parts of a layout in parallel. Each user can output a Tcl file that contains the layout changes they make by using the record_layout_editing command, and all the Tcl files can be applied to the original layout."}
{"instruction": "How do I Finding Substitute Locations for Invalid Taps", "input": "", "output": "If the specified location for a tap is invalid, use the -snap_distance option of the create_taps command to find a substitute location for the tap. The command searches the nearby layout shapes within the specified snap distance both horizontally and vertically on the same layer as defined by the -layer option. The tap is reinserted at the corner of a valid shape which is within the minimum distance to the specified location. Note: You can search for a substitute location only for the invalid taps that are specified by the -point and -layer options. For example, fc_shell> create_taps -point {50,50} -layer {M1} \\ -snap_distance 100 Snap tap point from original location (50.000, 50.000) to new location (90.000, 65.910) As shown in Figure 201, the specified tap location does not touch any layout shape. The red rectangle is the shape closest to the specified location and its lower-right corner has 889 Missing Via and Unconnected Pin Checking Feedback the minimum distance among all the other rectangles. The tool reinserts the tap at the lower-right corner of the red rectangle. Figure 201 Finding a Substitute Location for an Invalid Tap Original {x,y} 100 100 100 100 Snapped tap"}
{"instruction": "How do I Analyzing and Fixing Antenna Violations", "input": "", "output": "antena rulescheckingenabling If the design library contains antenna rules, Zroute automatically analyzes and antena violationsenablingfixing fixes antenna violations. antena violationsfixingdisablingantena rulescheckingdisabling To disable the analysis and correction of antenna rules during detail routing, set the route.detail.antenna application option to false Just like other design rules, antenna rules are checked and corrected during detail routing. This concurrent antenna rule correction architecture reduces total runtime by minimizing the iterations. By default, Zroute Checks antenna rules and corrects violations for all clock and signal nets To disable fixing of antenna violations on specific nets, set the route.detail.skip_antenna_fixing_for_nets application option. Note that Zroute analyzes the antenna rules and reports the antenna violations on these nets, but does not fix the violations. Does not check or correct antenna rules for power and ground nets To check and correct antenna rules for power and ground nets, set the route.detail.check_antenna_on_pg application option to true Starts fixing antenna violations in the second iteration, after initial routing is complete and the basic DRC violations have been fixed To change the iteration in which Zroute starts fixing antenna violations, set the route.detail.antenna_on_iteration application option. 617 Finding and Fixing Antenna Violations Feedback Performs layer hopping to fix antenna violations Layer hopping decreases the antenna ratio by splitting a large metal polygon into several upper-level polygons. Zroute performs the following types of layer hopping: Breaking the antenna with a higher-level metal segment Zroute uses this technique to fix most antenna violations. For antenna violations that happen at metal-N, inserting a small segment of metal-(N+1) close to the gate reduces the ratio between the remaining metal-N, making the ratio much lower. This approach is not suitable for fixing top-metal layer antenna violations when the output pin can provide only limited protection because there is no way for the router to break antenna violations at the topmost metal layer. Moving down to a lower-level metal Zroute uses this technique to fix only topmost layer antenna violations when output pins provide only limited protection. For antenna violations that happen at metal-N, replace part of the metal-N with metal-(N-1 or lower) to reduce the ratio. However, splitting the metal layer into many pieces might have a negative impact on RC and timing delay. Zroute can also insert diodes to fix antenna violations. To enable the insertion of diodes to fix antenna violations, set the route.detail.insert_diodes_during_routing application option to true. To force Zroute to fix antenna violations by inserting diodes, disable layer hopping by setting the route.detail.hop_layers_to_fix_antenna application option to false. For information about inserting diodes to fix antenna violations, see Inserting Diodes During Detail Routing If both layer hopping and diode insertion are enabled, by default, Zroute first tries to use layer hopping to fix the antenna violation. To change the preference to diode insertion, set the route.detail.antenna_fixing_preference application option to use_diodes To delete the redundant diodes that are not needed to fix antenna violations, set the route.detail.delete_redundant_diodes_during_routing application option to true Spare diodes are not deleted as they do not connect to any nets. Port protection diodes that are inserted by detail route are not deleted. As with other design rule violations, antenna violations are reported at the end of each detail routing iteration. For example, DRC-SUMMARY: @@@@@@@ TOTAL VIOLATIONS = 506 @@@@ Total number of instance ports with antenna violations = 1107 antena ruleschecking To check for antenna violations, use the check_routes -antenna true command. 618 Finding and Fixing Antenna Violations Feedback"}
{"instruction": "How do I Performing THO During route_opt or hyper_route_opt", "input": "", "output": "By performing THO at the end of the implementation flow, you have the best optimization potential because you optimize the complete design. The route_opt and hyper_route_opt commands perform postroute optimization on the top and blocks together. ECO routing after optimization is performed on all subblocks that are open for editing. 865 Transparent Hierarchy Optimization Feedback THO optimization is completely integrated with the route_opt and hyper_route_opt commands. Follow this example to use the hyper_route_opt or route_opt command on a single host: fc_shell> init_hier_optimization -flow post_route fc_shell> route_opt or hyper_route_opt fc_shell> commit_hier_optimization When using the route_opt command, it is possible to perform the ECO routing operations, which have to occur after each route_opt command in parallel, reducing overall runtime. You must set up the host options as shown in the Setting up Transparent Hierarchy Optimization section. The hier_route_eco command performs the ECO routing in the blocks as shown in the following example. fc_shell> init_hier_optimization -flow post_route -detached_hier_route_eco fc_shell> route_opt fc_shell> hier_route_eco fc_shell> commit_hier_optimization Note: When the hyper_route_opt command is used in this way, the tool ignores the setting and does not distribute the ECO routing. 866 Feedback"}
