{"instruction": "How do I Viewing PG Electromigration Analysis Results", "input": "", "output": "When PG electromigration analysis is complete, you can check for current violations by displaying a PG electromigration map or checking the generated errors in the error browser. Displaying the PG Electromigration Map Checking PG Electromigration Violations"}
{"instruction": "How do I Specifying the Clock Tree References", "input": "", "output": "The buffer and inverter cells that can be used to build a clock tree and the reference cells of the preexisting gates of the clock tree are referred to as clock tree references To specify the clock tree references, use the set_lib_cell_purpose -include cts command. Ensure that the list of cells you specify as clock tree references meets the following criteria: The list contains at least one buffer or one inverter The list contains the library cells of the preexisting gates If they are not included in the list, the tool is unable to resize these preexisting gates during clock tree synthesis and optimization. You can automatically derive equivalent cells for all the preexisting clock tree cells that are not buffers or inverters and specify them as clock references by using the derive_clock_cell_references command, as described in Deriving Clock Tree References for Preexisting Gates For multivoltage designs with always-on buffering requirements, the list contains always-on cells The library cells in the reference list do not have a dont_touch attribute If library cells have the dont_touch attribute set on them, they are not used by clock tree synthesis even if you specify them as clock tree references. To ensure that clock tree synthesis uses only the specified set of cells and that these cells are not used by any optimization step other than clock tree synthesis, run the following commands: fc_shell> set cts_cells list_of_cells fc_shell> set_lib_cell_purpose -exclude cts [get_lib_cells] fc_shell> set_lib_cell_purpose -include none [get_lib_cells $cts_cells] fc_shell> set_lib_cell_purpose -include cts [get_lib_cells $cts_cells]"}
{"instruction": "How do I Using Routing Guides to Encourage River Routing", "input": "", "output": "River routing is a special routing topology that tries to minimize the space taken by the router by compressing the routes to follow a particular contour. River routing is useful if there are tight routing channels or you need to minimize the space taken by routing. You can use a routing guide to encourage river routing within the routing guide boundary. To create this type of routing guide, use the -river_routing option with the create_routing_guide command. You must also use the -layers option to specify the affected layers. 478 Routing Constraints Feedback For example, to encourage river routing on the M2 layer within the rectangle with its lower- left corner at (0, 0) and its upper-right corner at (100, 100), use the following command: fc_shell> create_routing_guide -boundary {{0.0 0.0} {100.0 100.0}} \\ -river_routing -layers {M2}"}
{"instruction": "How do I Voltage-Drop-Aware Placement", "input": "", "output": "To manually enable Dynamic power shaping for the compile_fusion command, use the following settings: fc_shell> set_app_option -name opt.common.power_integrity \\ -value false fc_shell> set_app_option -name compile.flow.enable_dps \\ -value true Voltage-drop-aware placement for the compile_fusion command, use the following settings: fc_shell> set_app_option -name opt.common.power_integrity \\ -value false fc_shell> set_app_option -name compile.flow.enable_irap \\ -value true Voltage-drop-aware placement for the clock_opt command, use the following settings: fc_shell> set_app_option -name opt.common.power_integrity \\ -value false fc_shell> set_app_option -name clock_opt.flow.enable_irap \\ -value true 198 Specifying the Routing Resources Feedback"}
{"instruction": "How do I Querying Specific Message IDs", "input": "", "output": "To query specific information, warning, or error message IDs that occurred during the previous command step, you can use the check_error command. Follow these steps to set up and query the message IDs: 1. Specify the message IDs to query by using the global scope application option, shell.common.check_error_list fc_shell> set_app_options -name shell.common.check_error_list \\ -value {DES-001 CMD-005} shell.common.check_error_list {DES-001 CMD-005} 2. Use the link command as an example for the previous command step. fc_shell> link Error: Current block is not defined. (DES-001) 3. Query the specified message IDs that were issued during the link command step by using the check_error command. fc_shell> check_error -verbose {DES-001} The result shows that the DES-001 message ID was issued during the link command step. If none of the specified message IDs was issued, the check_error command returns 0. 284 Feedback"}
{"instruction": "How do I Deriving Pin Access Routing Guides", "input": "", "output": "When you reuse hard macros, such as IP blocks, at a smaller technology node, it can cause routability issues to the macro pins. You can use routing guides and blockages to enable access to the hard macro pins. To create these routing guides, which are referred to as pin access routing guides, and the associated blockages, use the derive_pin_access_routing_guides command. You must specify the following information: The hard macros around which to create the routing guides and routing blockages (the -cells option) The metal layers for which to create the routing guides and routing blockages (the -layers option) The width of the routing guides and blockages in the x- and y-directions (the -x_width and -y_width options) For each specified hard macro, the command creates routing guides to enable routing to the pins on the specified layers. In addition, the command creates metal blockages that surround the macro on the specified layers, with cutouts to allow pin access, and via blockages that cover the macro on the via layers adjacent to the specified metal layers. Vertical routing guides and blockages have the specified x-width. Horizontal routing guides and blockages have the specified y-width. By default, the command creates pin cutouts only in the preferred routing direction. To also create pin cutouts in the nonpreferred direction, use the -nonpreferred_direction option. To extend the pin cutouts beyond the metal blockages, use the -pin_extension option to specify the extension distance in microns. To enable proper routing to pins of different sizes, the command sets the is_rectangle_only_rule_waived attribute on the macro pins to true to waive the rectangle-only rule. For example, the following command creates the routing guides and blockages shown in Figure 100 fc_shell> derive_pin_access_routing_guides -cells myMacro \\ -layers {M2 M3} -x_width 0.6 -y_width 0.7 In the figure, the two red pins are on M2 and the green pin is on M3. The figure shows the routing guides created on both the M2 and M3 layers, the metal blockages created on the M3 layer, and the via blockage created on the V2 and V3 layers. The tool also creates metal blockages on the M2 layer, which have cutouts for the M2 pins, and via blockages on the V1 and V2 layers. 480 Routing Constraints Feedback Figure 100 Pin Access Routing Guides and Blockages If a hard macro already has pin access routing guides and their associated blockages, the command removes these existing objects and creates new routing guides and blockages. If you move a hard macro after deriving the pin access routing guides, you must regenerate the pin access routing guides. You cannot manually modify pin access routing guides."}
{"instruction": "How do I Supporting RedHawk-SC Customized Python Script Files", "input": "", "output": "RedHawk-SC Fusion provides application options and commands to read in user- customized python script files. The tool generates all design collaterals (including DEF, LEF, SPEF, TWF and PLOC) from the design library and adds them to the user-customized python script to run voltage drop analysis in a single iteration of analyze_rail. The user-customized python script file is supported in rail analysis with multiple rail scenarios, as well as other IR-driven features, such as IR-driven placement or IR-driven concurrent clock and data optimization. To use a customized python script file for RedHawk-SC Fusion rail analysis, 1. Set the type of script file to python fc_shell> set_app_options -name rail.generate_file_type -value python 2. Set the rail.generate_file_variables application option to specify the variables for generating the input files (including DEF, LEF, SPEF, TWF and PLOC files) to add to the user-customized python script file. You do not need to set this application option if the customized python script file uses the same values as in RedHawk-SC Fusion. DEF File LEF File SPEF File TWF File PLOC File Default name in fc_shell DEF LEF SPEF TWF PLOC Default variable name in RedHawk-SC Fusion def_files lef_files spef_files tw_files ploc For example, if you specify a test_def_file for the DEF variable to match with the DEF file specified in the customized python script file, set the following: fc_shell> set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files} 3. Create and specify rail scenarios for generating the necessary input files to add to the customized python script. Run the create_rail_scenario command to create a rail scenario and associate it with a design scenario in the current design. You can create multiple rail scenarios and associate them with the same scenario in the current design. Then run the set_rail_scenario -generate_file {LEF | TWF | DEF | SPEF | PLOC} command to specify the rail scenario and the type of input files to generate from the design library. 881 Preparing Design and Input Data for Rail Analysis Feedback Note: When running rail analysis using multicorner-multimode technology, you must create rail scenarios using the create_rail_scenario command before the set_rail_scenario command. The following example creates the T_low and T_high rail scenarios and generates input files for them: fc_shell> create_rail_scenario -name T_low -scenario func_cbest fc_shell> set_rail_scenario -name T_low -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py fc_shell> create_rail_scenario -name T_high -scenario func_cbest fc_shell> set_rail_scenario -name T_high -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py You can then use the customized.py file for multi-rail-scenario rail analysis or other IR- driven features, such as IR-driven placement or IR-driven concurrent clock and data optimization. Examples The following example uses a customized python script for multi-rail-scenario rail analysis on a grid system. #Required. Specify the below options to enable multi-rail-scenario rail analysis. set_app_options -list { rail.enable_new_rail_scenario true rail.enable_parallel_run_rail_scenario true #Required. Set the type of the script file to python. set_app_options -name rail.generate_file_type -value python #Use user-defined test_def_files for DEF variable to match #with customized python. set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files } create_rail_scenario -name func.ss_125c -scenario func.ss_125c set_rail_scenario -name func.ss_125c -voltage_drop dynamic create_rail_scenario -name func.ff_125c_ -scenario func.ff_125c set_rail_scenario -name func.ff_125c \\ -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py 882 Preparing Design and Input Data for Rail Analysis Feedback set_host_options -submit_protocol sge \\ -submit_command {qsub -V -notify -b y \\ -cwd -j y -P bnormal -l mfree=16G} analyze_rail -rail_scenario {func.ss_125c func.ff_125c} \\ -submit_to_other_machine The following example uses a customized python script for multi-rail-scenario rail analysis on a local machine. #Required. Specify the below options to enable multi-rail-scenario rail analysis. set_app_options -list { rail.enable_new_rail_scenario true rail.enable_parallel_run_rail_scenario true #Required. Set the type of the script file to python. set_app_options -name rail.generate_file_type -value python #Use user-defined test_def_files for DEF variable to match #with customized python. set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files } create_rail_scenario -name func.ss_125c -scenario func.ss_125c set_rail_scenario -name func.ss_125c -voltage_drop dynamic create_rail_scenario -name func.ff_125c_ -scenario func.ff_125c set_rail_scenario -name func.ff_125c \\ -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py set_host_options -submit_command {local} analyze_rail -rail_scenario {func.ss_125c func.ff_125c} The following example uses a customized python script for single-scenario rail analysis on a grid system. Required. Specify the below options to enable multi-rail-scenario rail analysis. set_app_options -list { rail.enable_new_rail_scenario true rail.enable_parallel_run_rail_scenario true #Required. Set the type of the script file to python. set_app_options -name rail.generate_file_type -value python #Use user-defined test_def_files for DEF variable to match #with customized python. 883 Preparing Design and Input Data for Rail Analysis Feedback set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files } create_rail_scenario -name func.ff_125c_ -scenario func.ff_125c set_rail_scenario -name func.ff_125c \\ -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py set_host_options -submit_protocol sge \\ -submit_command {qsub -V -notify -b y \\ -cwd -j y -P bnormal -l mfree=16G} analyze_rail -rail_scenario {func.ff_125c} \\ -submit_to_other_machine The following example uses a customized python script for IR-driven placement on a grid system. Required. Specify the below options to enable multi-rail-scenario rail analysis. set_app_options -list { rail.enable_new_rail_scenario true rail.enable_parallel_run_rail_scenario true #Required. Set the type of the script file to python. set_app_options -name rail.generate_file_type -value python #Use user-defined test_def_files for DEF variable to match #with customized python. set_app_options -name rail.generate_file_variables \\ -value {DEF test_def_files } create_rail_scenario -name func.ss_125c -scenario func.ss_125c set_rail_scenario -name func.ss_125c -voltage_drop dynamic create_rail_scenario -name func.ff_125c_ -scenario func.ff_125c set_rail_scenario -name func.ff_125c \\ -generate_file {PLOC DEF SPEF TWF LEF} \\ -custom_script_file./customized.py set_host_options -submit_protocol sge \\ -submit_command {qsub -V -notify -b y \\ -cwd -j y -P bnormal -l mfree=16G} # Enable IR-driven placement before running clock_opt -from final_opto set_app_options -name opt.common.power_integrity -value true clock_opt -from final_opto The following example uses a customized python script for concurrent clock and data optimization on a multicorner and"}
{"instruction": "How do I Synthesis", "input": "", "output": "By default, the clock_opt command does not consider voltage drop information when inserting clock buffers. Therefore, the tool might place clock buffers in locations with high PG resistance, which increases the voltage drop. To prevent this, you can use the 372 Implementing Clock Trees and Performing Post-CTS Optimization Feedback RedHawk Fusion feature to analyze the PG network and use this information with the clock_opt command, as shown in the following flow: 1. Use the RedHawk Fusion feature to analyze the PG network by using the analyze_rail -min_path_resistance command. 2. Load the RedHawk Fusion results by using the open_rail_result command. 3. Enable voltage-drop-aware clock tree synthesis by setting the clock_opt.flow.enable_voltage_drop_aware application option to true 4. Run the clock_opt command."}
{"instruction": "How do I Running the signoff_fix_isolated_via Command", "input": "", "output": "You can use the signoff_fix_isolated_via command either to check for isolated vias only, or to check for and fix the isolated vias."}
{"instruction": "How do I Creating Abstracts With Power Information", "input": "", "output": "To create an abstract that contains power information of the corresponding block, use the following steps at the block level: 1. Activate the scenarios for which you want to perform power analysis by using the -active true option of the set_scenario_status command and enable them for power analysis by using the following options: -dynamic_power true for dynamic power analysis -leakage_power true for leakage power analysis Power information is stored only for active scenarios that are enabled for dynamic or leakage power. 2. (Optional) Apply switching activity by either reading in a SAIF file with the read_saif command or annotating the switching activity information on the nets with the set_switching_activity command. For more information about applying switching activity, see Annotating the Switching Activity 834 Creating Abstract Views Feedback 3. Store the power information in the abstract by setting the abstract.annotate_power application option to true 4. Create the abstract for the block by using the create_abstract command. When you create an abstract with power information, the tool stores the power information only for the logic that is removed. When you instantiate such an abstract and perform power analysis at the top level, the tool Recomputes the power for the interface logic in the abstract, in context, based on the switching activity and loading seen at the top level Uses the stored power in the abstract for the logic that was removed when the abstract was created To report the power information in an abstract instantiated at the top level, use the report_power -blocks command. If there are multiple levels of physical hierarchy, to specify the number of level for which you want to report, use the -levels option."}
{"instruction": "How do I Defining Blockages That Allow Buffers Only", "input": "", "output": "To define a partial blockage that allows buffers only, specify the boundary, type ( -type allow_buffer_only option), blockage percentage ( -blocked_percentage option), and optionally the name for the placement blockage. For example, to define a partial blockage that allows only the placement of buffers and inverters, with a cell density of 30 percent, use the following commands: create_placement_blockage -boundary {{10 20} {100 200}} \\ -type allow_buffer_only -blocked_percentage 70 144 Specifying Physical Constraints for Placement and Legalization Feedback Note: Buffer-only blockages are honored during placement, but not during legalization, optimization, or clock tree synthesis."}
{"instruction": "How do I Marking Clock Trees as Synthesized", "input": "", "output": "To prevent the Fusion Compiler tool from modifying them, you can mark existing clock trees in your design as synthesized clock tree by using the mark_clock_trees command as shown in Table 27 Table 27 Using the mark_clock_trees Command To do this Use this option Mark only the clock trees of specific clocks By default, the command marks all clocks defined by the create_clock and create_generated_clock commands in all modes of all active scenarios -clocks clock_list Mark the clock tree as synthesized This is the default behavior -synthesized Remove the synthesized attribute settings from the clock trees -clear Apply the dont_touch attribute setting on the clock trees -dont_touch Remove the dont_touch attribute settings from the clock trees -clear -dont_touch Propagate the nondefault clock routing rules specified by the set_clock_routing_rules command -routing_rules Propagate the clock cell spacing rules specified by the set_clock_cell_spacing command -clock_cell_spacing Mark the clock sinks as fixed -fix_sinks Freeze the routing of the clock nets -freeze_routing The tool traverses the clock trees and marks the clock trees as specified. Clock tree traversal continues until it finds an exception pin or a default sink pin."}
{"instruction": "How do I Inserting Tap Meshes", "input": "", "output": "tap mesh is a two-dimensional array of tap cells with a tap cell in each mesh window. A tap mesh is typically inserted outside of a place and route block, but you can insert one in any area that is either completely inside or completely outside the core area. To insert a tap mesh, use the create_tap_meshes command. You must specify the following information: The tap cell used in the tap mesh (the -lib_cell option) By default, the command inserts the tap cells with R0 orientation. To place the cells with a different orientation, use the -orientation option. By default, the tool uses the following naming convention for inserted tap cells: headerfooter__ library_cell_name _R _C number To identify the tap cells inserted in a specific run, use the -prefix option to specify a prefix string. When you use this option, the tool uses the following naming convention: prefix __ library_cell_name _R _C number The tap insertion region (the -bbox option) You specify the tap insertion region by specifying the lower-left and upper-right corners of its bounding box: -bbox {{ llx lly } { urx ury }} The mesh window (the -mesh_window option) You specify the size of the mesh window by specifying an integer value for the pitch in the x- and y-directions. -mesh_window { x_pitch y_pitch The mesh window is aligned with the lower-left corner of the tap insertion region. When inserting the tap mesh, the command does not honor the standard cell rows or sites. It places a tap cell in the lower-left corner of each mesh window. If that location is blocked, the command uses the closest available location, which is measured as the Manhattan distance to the lower-left corner of the mesh window. If there is no available location, the command issues a warning and does not place a tap cell in that mesh window. After insertion, the command fixes the placement of the inserted tap cells. 591 Inserting Tap Cells Feedback"}
{"instruction": "How do I Clock-Gating Setup Condition", "input": "", "output": "To perform clock gating, the tool requires that the enable signal of the register bank is synchronous with its clock. This is the setup condition. For latch-based or integrated clock gating, the tool can insert clock gating irrespective of the enable signal's and the clock's clock domains. If the enable signal and the register bank reside in different clock domains, you must ensure that the two clock domains are synchronous and that the setup and hold times for the clock-gating cell meet the timing requirements. An exception exists for primary input ports that use a clock specified with the set_input_delay command. In this case, the input port is synchronous with the clock and the setup condition is true."}
{"instruction": "How do I Enabling the Power Integrity Features", "input": "", "output": "The Fusion Compiler tool provides the following techniques for ensuring power integrity of the design: Dynamic power shaping (DPS), which reduces transient power by utilizing concurrent clock and data optimization (useful skew) techniques. Voltage-drop-aware placement, which use the voltage (IR) drop values of cells to identify areas of high power density and spread the cells with high voltage drop values to reduce the power density of such areas. 195 Setting Up for Power-Related Features Feedback To set up for the recommended power integrity flow, perform the following steps: 1. Enable the power integrity flow by setting the opt.common.power_integrity application option to true When you do so, the Fusion Compiler uses the following techniques during the different stages of the design flow: a. Dynamic power shaping (DPS) during the final_opto stage of the compile_fusion command b. Voltage-drop-aware placement during the clock_opt command 2. (Optional) Specify that the tool should not reduce the voltage drop at the expense of the timing QoR by reducing the power integrity effort level by setting the opt.common.power_integrity_effort application option to low The default is high, and by default the tool tries to reduce the voltage drop to less than eight percent of the supply voltage at the expense of the timing QoR. 3. (Optional) Specify a maximum voltage drop threshold by using the opt.common.ir_drop_threshold application option. The default is eight percent of the supply voltage. If you change the default effort level by setting the opt.common.power.integrity_effort application option to low the tool ignores the threshold specified with the opt.common.ir_drop_threshold application option. 4. Specify settings for dynamic power shaping as described in Setting Up for Dynamic Power Shaping 5. Specify settings for voltage-drop-aware placement as described in Setting Up for Voltage-Drop-Aware Placement 6. (Optional) Enable IR-driven sizing, which uses the RedHawk dynamic voltage drop analysis results to identify cells involved in voltage drop violations, and then tries to replace those cells with cells having smaller leakage current. To enable this feature, set the clock_opt.flow.enable_irdrivenopt application option to true, in addition to setting the opt.common.power_integrity application option to true Instead of using the recommended power integrity flow setting, you can manually enable dynamic power shaping or voltage-drop-aware placement for the compile_fusion or clock_opt commands as described in Manually Enabling Dynamic Power Shaping and Voltage-Drop-Aware Placement 196 Setting Up for Power-Related Features Feedback"}
{"instruction": "How do I Allowing Nonrelative Placement Cells", "input": "", "output": "By default, nonrelative placement cells are Not allowed within relative placement groups during coarse placement Allowed within relative placement groups during optimization and legalization To reduce congestion and improve QoR, you can allow the tool to place nonrelative placement cells within the unused areas of a specific relative placement group by using the -allow_non_rp_cells option with the set_rp_group_options command. You can add blockages to relative placement group by using the -blockage option with the add_to_rp_group command. By default, no cells are allowed within these blockages during placement, optimization, and legalization. To allow nonrelative placement cells within relative placement blockages and unused areas of a specific relative placement group, use the -allow_non_rp_cells_on_blockages option with the set_rp_group_options command. The following example allows nonrelative placement cells within the unused areas of the RP1 relative placement group: fc_shell> set_rp_group_options rp1 \\ -allow_non_rp_cells The following example allows nonrelative placement cells within the blockages and unused areas of the RP2 relative placement group: fc_shell> set_rp_group_options rp2 \\ -allow_non_rp_cells_on_blockages"}
{"instruction": "How do I Using Routing Guides to Control the Routing Direction", "input": "", "output": "You can use a routing guide to control the routing direction within the routing guide boundary, either by requiring routes to be in the preferred direction within the routing guide boundary or by switching the preferred direction within the routing guide boundary. To force the router to route all nets in the preferred direction within the routing guide boundary, use the -preferred_direction_only option with the create_routing_guide command. You can use this type of routing guide to prevent wrong-way jog wires on specific layers. By default, this routing guide applies to all layers within the routing guide boundary. To require preferred direction routing only for specific layers, use the -layers option to specify the affected layers. 475 Routing Constraints Feedback For example, to force the router to use only the preferred direction on the M4 layer within the rectangle with its lower-left corner at (0, 0) and its upper-right corner at (100, 100), use the following command: fc_shell> create_routing_guide -boundary {{0.0 0.0} {100.0 100.0}} \\ -layers {M4} -preferred_direction_only To switch the preferred routing direction within the routing guide boundary, use the -switch_preferred_direction option with the create_routing_guide command. You can use this type of routing guide to allow routing over macros, which might reduce congestion for a block that contains much detour routing. By default, this routing guide applies to all layers within the routing guide boundary. To switch the preferred routing direction only for specific layers, use the -layers option to specify the affected layers. For example, to switch the preferred routing direction for the M1 and M2 layers within the rectangle with its lower-left corner at (0, 0) and its upper-right corner at (100, 100), use the following command: fc_shell> create_routing_guide -boundary {{0.0 0.0} {100.0 100.0}} \\ -layers {M1 M2} -switch_preferred_direction Note: If a switch-preferred-direction routing guide overlaps with a preferred- direction-only routing guide, the switch-preferred-direction routing guide takes precedence."}
{"instruction": "How do I Defining Gas Stations", "input": "", "output": "Gas stations are small voltage areas that are created for the purpose of minimizing the use of dual-rail buffers on physical feedthrough paths. Only single-rail repeaters are allowed in gas stations, and only optimization steps can add cells to gas stations. You create gas stations by using the create_voltage_area command during the design planning stage. The tool recognizes gas stations automatically and uses them by trading off the cost of a routing detour with the cost of using a dual-rail cell. Use the -nwell and -pwell options of the create_voltage_area command to specify n-well and p-well supply nets for a voltage area. Defining well supplies for gas station voltage areas provides flexibility for using gas stations for different design styles. If you do not use these options for a voltage area, the well bias values are assumed to be the same as the domain supply values. The report_voltage_areas command lists the n-well and p-well supply nets regardless of whether they are explicitly set."}
{"instruction": "How do I Inserting Metal Fill", "input": "", "output": "After routing, you can fill the empty spaces in the block with metal wires to meet the metal density rules required by most fabrication processes. Before inserting metal fill, the block should be close to meeting timing and have very few or no DRC violations. To insert metal fill, run the signoff_create_metal_fill command, as described in Inserting Metal Fill With IC Validator In-Design Note: An IC Validator license is required to run the signoff_create_metal_fill command. 659 Feedback"}
{"instruction": "How do I Performing Design Analysis", "input": "", "output": "Use the reports generated by Fusion Compiler to analyze and debug your design. You can generate reports before and after you compile your design. Generate reports before compile to check that you have set attributes, constraints, and design rules properly. Generate reports after compile to analyze the results and debug your design. This section includes the following topics: Reporting Commands and Examples Measuring Quality of Results Comparing QoR Data Reporting Logic Levels in Batch Mode Querying Specific Message IDs"}
{"instruction": "How do I Applying Required Settings for Improving Specific QoR Metrics", "input": "", "output": "To apply tool settings required for improving specific QoR metrics, use the set_qor_strategy -stage synthesis command. To specify the QoR metrics to improve, use the -metric option. To optimize the block for the best Timing, use the timing setting Leakage power and timing, use the leakage_power setting Total power and timing, use the total_power setting. To further improve total power, at the expense of runtime, you can use the -mode extreme_power option, with the -metric total_power option. To specify a target mode for the design flow, use the -mode option. The supported values for this option are: balanced, which is the default mode that optimizes the design for the target metrics specified with the -metric option. early_design, which is suitable for the early stages of the design flow, when the emphasis is on short turnaround time for prototyping purposes. With this mode, you can reduce runtime at the expense of QoR. extreme_power, which is recommended for further improvement of total power at the expense of runtime. This mode should only be specified along with the -metric leakage_power or -metric total_power option. If you specify this mode with the -metric timing option, the tool ignores the specified mode setting and uses the balanced mode. 210 Applying Mega-Switch Command Settings Feedback When you use this command, the tool applies application option settings that affect synthesis, optimization, placement, legalization, clock tree synthesis, routing, extraction, and timing analysis. To review the required setting, use one of the following methods: Generate a Tcl script that contains the settings by using the -output option Report the settings by using the -report_only option Report only the settings that are not set to their required values by using the -diff_only option 211 Feedback"}
{"instruction": "How do I Merging Voltage Area Shapes", "input": "", "output": "To merge the voltage area shapes into a minimum set of disjoint shapes, use the -merge_regions option with the create_voltage_area create_voltage_area_shape or set_voltage_area command. When you use the create_voltage_area -merge_regions command, the merges the shapes specified with the -region option. When you use the create_voltage_area_shape -merge_regions command, the merges the shape specified with the -region option and the existing shapes of the specified voltage area. When you use the set_voltage_area -merge_regions command, the tool merges all existing shapes of the specified voltage area. The tool merges the voltage area shapes based on their stacking order. By default, the stacking order is the order in which you define the shapes, with the last shape defined on top. The merged shape replaces the top shape of a set of abutting or overlapping shapes; the other shapes in the set are removed and are no longer associated with the voltage area. 121 Setting Up Multivoltage Designs Feedback For example, assume that you use the following command to create a voltage area comprising three rectangle shapes, as shown on the left side of Figure 14 fc_shell> create_voltage_area -power_domains {PD1} \\ -region { {{0 0} {10 10}} {{10 0} {30 10}} {{15 5} {35 15}} } {PD1} fc_shell> get_voltage_area_shapes -of_objects PD1 {VOLTAGE_AREA_SHAPE_1 VOLTAGE_AREA_SHAPE_2 VOLTAGE_AREA_SHAPE_3} After you use the -merge_regions option to merge these shapes, the voltage area consists of a single rectilinear shape, as shown on the right side of Figure 14. The merged voltage area shape is named VOLTAGE_AREA_SHAPE_3, which was the last voltage area shape defined when the voltage area was created. fc_shell> set_voltage_area PD1 -merge_regions Information: Merging abutted and overlapping shapes in voltage_area 'PD1'. (NDMUI-154) fc_shell> get_voltage_area_shapes -of_objects PD1 {VOLTAGE_AREA_SHAPE_3} Figure 14 Merging Voltage Area Shapes To report the stacking order of the voltage area shapes, use the report_voltage_areas -verbose command. To modify the stacking order of the voltage area shapes, use the set_voltage_area_shape command, as described in Modifying the Stacking Order"}
{"instruction": "How do I Querying Routing Blockages", "input": "", "output": "To find routing blockages, use the get_routing_blockages command. For example, to get all the routing blockages in a block, use the following command: fc_shell> get_routing_blockages * To find the routing blockages for specific nets, use the -of_objects option to specify the nets of interest. For example, to find the routing blockages for the n1 net, use the following command: fc_shell> get_routing_blockages -of_objects [get_nets n1] To find the routing blockages in a specific location, use the get_objects_by_location -classes routing_blockage command."}
{"instruction": "How do I RedHawk Fusion and RedHawk-SC Fusion Data Flow", "input": "", "output": "The RedHawk/RedHawk-SC Fusion feature allows you to perform rail analysis during the implementation stage. With the required input files, the Fusion Compiler tool creates the RedHawk run script and the Global System Requirements (GSR) configuration file for invoking the RedHawk tool (or the RedHawk-SC Python script for invoking the RedHawk-SC tool) to run PG net extraction, power analysis, voltage drop analysis, and PG electromigration analysis. When analysis is complete, the Fusion Compiler tool generates analysis reports and maps using the results calculated by the RedHawk or RedHawk-SC tool. You can then check for hotspots graphically in the Fusion Compiler GUI. Error data and ASCII reports are also available to check for locations where limits are violated. Figure 199 illustrates the data flow when using RedHawk Fusion or RedHawk-SC Fusion to perform rail analysis in the Fusion Compiler environment. 872 An Overview for RedHawk Fusion and RedHawk-SC Fusion Feedback Figure 199 RedHawk Fusion and RedHawk-SC Fusion Data Flow"}
{"instruction": "How do I Command", "input": "", "output": "By default, the tool performs leakage power optimization during compile. To produce optimal leakage power optimization, use libraries with multithreshold voltage group cells. To set up leakage optimization, 1. Enable at least one scenario for leakage power by using the set_scenario_status -leakage_power true command. For example, fc_shell> set_scenario_status -leakage_power true SC1 If the block has multiple scenarios enabled for leakage power, the tool uses the worst- case leakage value of all the specified scenarios. 2. Set the threshold_voltage_group attribute on the reference library cells. For example, fc_shell> set_attribute [get_lib_cells -quiet lib1_name/*] \\ threshold_voltage_group HVT 3. Set the threshold_voltage_group attribute to one of the three built-in threshold voltage group types: high, normal, or low threshold voltage. 189 Setting Up for Power-Related Features Feedback If there are more than three threshold-voltage groups, you should group them into the three voltage group types as follows: fc_shell> set_threshold_voltage_group_type \\ -type high_vt {HVT HVTX} fc_shell> set_threshold_voltage_group_type \\ -type low_vt {LVT LVTX} fc_shell> set_threshold_voltage_group_type \\ -type normal_vt {RVT RVTX}"}
{"instruction": "How do I Reporting Cell Spacing Constraints", "input": "", "output": "To report the cell spacing rules, use the report_spacing_rules comandcomandsreport_spacing_rules report_placement_spacing_rules command. This command reports the cell spacing labels defined in the current session, the library cells (and their sides) to which they apply, and the rules defined for them."}
{"instruction": "How do I Inserting Routing Blockages Along the Boundary Edges", "input": "", "output": "You can insert routing blockages along the preferred-direction edges, the nonpreferred- direction edges, or all edges. To insert routing blockages along the preferred-direction edges of the current block, use the derive_perimeter_constraint_objects command with the -perimeter_objects route_blockage_preferred option. To insert routing blockages along the preferred-direction edges of the current block, use the derive_perimeter_constraint_objects command with the -perimeter_objects route_blockage_nonpreferred option. To insert routing blockages along all edges of the current block, use the derive_perimeter_constraint_objects command with the -perimeter_objects {route_blockage_preferred route_blockage_nonpreferred} option. When you specify this object type, the command creates routing blockages parallel to the boundary edges in the specified directions. 488 Routing Constraints Feedback By default, The routing blockages are inserted only in the top-level block To insert routing blockages in all soft macros in a hierarchical block, use the -hierarchical option. The routing blockages are inserted on all routing layers To insert the routing blockages only on specific routing layers, use the -layers option. The routing blockages have the default metal width specified for the routing layer in the technology file To specify a different width in microns for preferred-direction routing blockages, use the -width_preferred option. To specify a different width in microns for nonpreferred- direction routing blockages, use the -width_nonpreferred option. For information about specifying the default metal width for a layer, see the \"Default Width Rule\" topic in the Synopsys Technology File and Routing Rules Reference Manual The routing blockages are offset from the boundary edges by the minimum spacing specified for the routing layer in the technology file To specify a different offset in microns tor preferred-direction routing blockages, use the -spacing_preferred option. To specify a different offset in microns tor nonpreferred- direction routing blockages, use the -spacing_nonpreferred option. For information about specifying the minimum spacing for a layer, see the \"Minimum Spacing Rule\" topic in the Synopsys Technology File and Routing Rules Reference Manual The routing blockages do not have pin cutouts To generate pin cutouts, use the -pin_cutout option. Cut layer routing blockages are not created To create via blockages, specify the via layers in the -layers option. By default, the width of the cut layer routing blockages is the maximum width for the preferred-direction and nonpreferred-direction routing blockages. To specify the width for cut layer routing blockages along the horizontal edges, use the -width_cut_layer_horizontal option. To specify the width for cut layer routing blockages along the vertical edges, use the -width_cut_layer_vertical option. 489 Routing Constraints Feedback By default, the cut layer routing blockages are offset from the boundary edges by the is the maximum spacing for the preferred-direction and nonpreferred-direction routing blockages To specify the spacing for cut layer routing blockages along the horizontal edges, use the -spacing_cut_layer_horizontal option. To specify the spacing for cut layer routing blockages along the vertical edges, use the -spacing_cut_layer_vertical option."}
{"instruction": "How do I Removing the Threshold-Voltage Filler Cell Information", "input": "", "output": "To remove the filler cell insertion rules and the threshold-voltage type annotations, use the -clear_vt_information option with the create_vtcell_fillers command."}
{"instruction": "How do I Optimizing Pin Access During Legalization", "input": "", "output": "For advanced technology nodes, to improve the routability of areas with high pin densities by redistributing the cells, enable pin optimization during legalization by setting the place.legalize.optimize_pin_access_using_cell_spacing application option to true"}
{"instruction": "How do I Reading Designs Using the -autoread Option", "input": "", "output": "To enable the tool to automatically read a list of RTL files, specify the -autoread option with the analyze command, as shown in the following example. When this option is specified, the RTL language used to analyze the RTL files is automatically determined by the file name extension. To control the file name extensions, use the following application options: hdlin.autoread.verilog_extensions hdlin.autoread.sverilog_extensions hdlin.autoread.vhdl_extensions, and hdlin.autoread.exclude_extensions set DESIGN_NAME top analyze -autoread -top ${DESIGN_NAME} ${RTL_FILE_LIST} elaborate ${DESIGN_NAME} elaborate -hdl_library TOP_HDL_LIB top set_top_module ${DESIGN_NAME} 100 Reading the Design Feedback"}
{"instruction": "How do I Performing Prechecks", "input": "", "output": "Fusion Compiler can perform compile prechecks to prevent compile failures and allow the compile_fusion command to quickly exit with error messages when incomplete (or inconsistent) setup or constraint issues are encountered. This capability is on by default, but these checks can also be enabled by the compile_fusion -check_only command. The compile_fusion command and the compile_fusion -check_only command perform the prechecks listed in the following table and issue error messages accordingly. A check mark (X) indicates the precheck is performed. Table 19 Prechecks Performed During the Compile Flow Code Message Default compile prechecks compile_fusion -check_only OPT-3000 Design is not linked or has link issues. OPT-3001 Cell is not resolved after linking. OPT-3002 Cell is physical hierarchy and not allowed in compile. OPT-3003 Cell is logical hierarchy and not allowed in compile. OPT-3005 Design is not present. OPT-3006 Current instance hierarchy is not the top. OPT-2001 Could not initialize scenario settings. OPT-2002 Missing parasitic information for corners or missing TLUPlus information. OPT-4000 Design does not have a floorplan or a valid floorplan. OPT-4001 Design does not have a valid die area. OPT-4002 Macro does not have placement. information. OPT-4004 Design port does not have placement information. OPT-4010 Pad connected to port does not have placement information. OPT-4008 Design has no site rows defined. OPT-4009 Design has no tracks defined. OPT-1008 Layer does not have a preferred direction. 215 Performing Unified Physical Synthesis Feedback Table 19 Prechecks Performed During the Compile Flow (Continued) Code Message Default compile prechecks compile_fusion -check_only OPT-1006 Library analysis failure - cannot find buffers and inverters. OPT-1007 Library analysis failure - No technology data. OPT-4012 Design has 1 duplicate. Run check_duplicates for more details. Compile Precheck Examples The following two examples show the compile logs with and without compile prechecks. When the -check_only option is set, the compile_fusion command issues error messages for any failed precheck condition. Example 14 Compile Log With Compile Prechecks  Begin compile flow  (FLW-3001) ->Compile in progress: 1.0% (FLW-3778) Error: Layer M1 does not have a preferred direction (OPT-1008)... Error: Layer MRDL does not have a preferred direction (OPT-1008)... Warning: Technology layer 'M1' setting 'routing-direction' is not valid (NEX-001)... Warning: Technology layer 'MRDL' setting 'routing-direction' is not valid (NEX-001) Example 15 Compile Log Without Compile Prechecks  End logic optimization  (FLW-3001) ->Compile in progress: 27.0% (FLW-3778) ->Compile in progress: 28.0% (FLW-3778) ->Compile in progress: 28.5% (FLW-3778) Information: Corner max_corner: no PVT mismatches. (PVT-032) Warning: Technology layer 'M1' setting 'routing-direction' is not valid (NEX-001)... Warning: Technology layer 'MRDL' setting 'routing-direction' is not valid (NEX-001) Information: Design Average RC for design top (NEX-011) 216 Controlling Mapping and Optimization Feedback"}
{"instruction": "How do I Constraint-Based Via Ladder Insertion", "input": "", "output": "To use the constraint-based method to insert via ladders, 1. Ensure that the via ladder rules are defined, as described in Defining Via Ladder Rules 2. Define the via ladder constraints by using the set_via_ladder_rules command, as described in Defining Via Ladder Constraints 3. Insert the via ladders by using the insert_via_ladders command, as described in Inserting Via Ladders 4. Verify the via ladders by using the verify_via_ladders command, as described in Verifying Via Ladders 454 Inserting Via Ladders Feedback"}
{"instruction": "How do I Reducing Signal Integrity Effects on Clock Nets", "input": "", "output": "The timing of a design can be improved by reducing signal integrity issues on clock nets. To do so, the tool can derive nondefault routing rules with larger spacing requirements and assign them to the clock nets in regions without routing congestion. 368 Specifying the Clock Tree Synthesis Settings Feedback To enable this feature, use the following application option setting: fc_shell> set_app_options \\ -name cts.optimize.enable_congestion_aware_ndr_promotion -value true When the tool derives a new nondefault routing rule for a clock net, the new spacing requirement is dependent on the spacing requirement of the existing routing rule of that net. If the existing routing rule is A nondefault routing rule with a spacing requirement of less than or equal to two times the default spacing, the spacing requirement is doubled The name of this new nondefault rule is the original name with an _ext_spacing postfix. A nondefault routing rule with a spacing requirement of more than two times the default spacing, the spacing requirement is increased by one default spacing The name of this new nondefault rule is the original name with an _ext_spacing postfix. The default routing rule, the spacing requirement is doubled The name of this new nondefault rule is default_rule_equivalent_ndr_double_spacing."}
{"instruction": "How do I Creating a Via Definition", "input": "", "output": "To create a via definition, use the create_via_def command. After it is created, the via definition can be used anywhere in the design, similar to a ContactCode definition in the technology file. The user-specified via definition is stored in the design library, so it can be used only in that design. The create_via_def command can define simple vias, simple via arrays, and custom vias. The following topics describe how to define these types of vias. Defining Simple Vias Defining Custom Vias"}
{"instruction": "How do I Mapping Sequential Elements Exactly as Described in RTL", "input": "", "output": "To specify that the tool maps sequential elements exactly as described in the RTL, set the compile.seqmap.exact_map application option to true. When this feature is enabled, the tool disables mapping to sequential library cells with inverted outputs or unused ports."}
{"instruction": "How do I Clock-Gate Multilevel Expansion", "input": "", "output": "It is difficult to determine the optimum number of clock-gate levels manually. The Fusion Compiler tool can analyze all clock gates and insert additional clock gates to take advantage of shared enable signals. Inserting additional clock gates might improve power, area, or other metrics, depending on the design. If six or more clock gates share an enable signal, the tool inserts an additional level of clock gates. The new clock gates are then considered for further level expansion. As a result, the tool might insert multiple levels of clock gates during this operation. To allow the tool to expand the number of clock-gate levels, set the compile.clockgate.enable_level_expansion application option to true (the default is false ) and set the compile.clockgate.max_number_of_levels application option to a nonzero value (the default is 0). In this case, the tool adds clock gates until either of the following conditions is met: All common enable signals are identified and used for multilevel clock-gate expansion. The user-specified maximum number of clock-gate levels is reached. The tool names a newly-inserted clock gate as follows, based on the status of the set of clock gates whose enable functions are modified by the new clock gate: If at least one of the clock gates is a tool-inserted clock gate, the base name is clock_gate_ml. The name is appended with the register base name, similar to the naming convention for other tool-inserted clock gates. If all of the clock gates are preexisting clock gates, the tool uses the name of the preexisting clock gate with the largest fanout and appends _ml_pe The compile.clockgate.max_number_of_levels application option specifies the maximum number of allowed clock-gate levels. The default is 0, which allows an infinite number of levels. However, to use the clock-gate level expansion capability, you must set this application option to a nonzero value (in addition to setting the compile.clockgate.enable_level_expansion application option to true ). If you specify clock-gate level expansion, but the maximum number of allowed levels is low, the expansion operation cannot take full advantage of the tool's ability to analyze common enable signals. To enable or disable clock-gate level expansion for specific clock gates, use the set_clock_gate_transformations -expand_levels command. 310 Controlling the Number of Clock-Gate Levels Feedback The following usage notes apply: New clock gates inherit the constraints set by the set_clock_gate_transformations set_clock_gate_style set_dont_touch set_size_only set_lib_cell_purpose and set_boundary_optimization commands. Clock-gate latency estimations are updated after the insertion operation. When the insertion operation modifies the enable signal of a clock gate, the gate retains its original designation of being either preexisting or tool-inserted. Self-gating is restricted from adding another clock-gate level if the maximum number of levels is already reached. Integrated clock gates inside multibit cells are counted as part of the clock-gate level count. However, they are not candidates for clock-gate level expansion. New clock gates do not inherit timing exceptions."}
{"instruction": "How do I Soft Shielding Rules During Signal Routing", "input": "", "output": "Zroute considers shielding rules as soft rules during signal routing. If a net has a shielding rule and is not shielded before signal routing, by default, Zroute reserves shielding space during the whole routing process: global routing, track assignment, and detail routing. At the end of detail routing, it reports the shielding space violations and the locations where shielding wires cannot be established. The following log file example shows shielding soft spacing violations, which are highlighted in text: DRC-SUMMARY: @@@@@@@ TOTAL VIOLATIONS = 13 Diff net var rule spacing : 2 Same net spacing : 2 Less than minimum area : 4 Short : 1 Soft spacing (shielding) : 2 Signal routing only reserves space for the shielding; it does not actually insert it. You must run create_shields after signal routing to physically place the shielding wires. The reported soft rule violations help you to understand the shielding rate. Note that the router reserves space only for same-layer shielding and not for coaxial shielding; therefore, postroute coaxial shielding can produce a very low shielding rate. 544 Shielding Nets Feedback If you want to use power and ground nets for shielding, and do not want Zroute to reserve space for the shielding when power and grounds nets are available, set the route.common.allow_pg_as_shield application option to true before running signal routing."}
{"instruction": "How do I Reporting Leakage Power", "input": "", "output": "To check your leakage power, use the report_power command. By default, state- dependent leakage power is used to calculate leakage power. To change the leakage power calculation mode, set the power.leakage_mode application option. For example, to set the application option to average do the following: fc_shell> set_app_options -name power.leakage_mode -value average To report threshold voltage usage, use the report_threshold_voltage_groups command. Classification is based on the threshold_voltage_group attribute from the reference library cells or the default_threshold_voltage_group attribute on the library. You can also set the attributes on the objects by using the set_attribute command. You can generate several types of reports with the report_threshold_voltage_groups command. For example, the summary report (using the -summary option) lists the number, area, and percentage of cells in each threshold voltage group. The default report (without using any options) shows the cell count and area based on the following groups: repeater, combinational, register, sequential, clock network, and physical-only cells. For the repeater, register, and clock network cell groups, you can obtain additional information by using the -detailed option. The -hierarchy option of the report_threshold_voltage_groups command generates a report based on the design hierarchy. The report shows the cell count, area, and area ratio for a top-level block and its subblocks. The -hierarchy option is mutually exclusive with the other report types, but can be used with the -datapath_cells_only and -standard_cells_only options. You can restrict the hierarchy-based report to specific threshold voltage groups by using the -hier_vt_groups option. You can also specify to report only the top-level cells that contain more than a specified number of constituent cells by using the -hier_threshold option. These options must be used with the -hierarchy option. If you specify a cell list, a separate report is created for each top-level cell in the list. 190 Setting Up for Power-Related Features Feedback"}
{"instruction": "How do I Analyzing the Clock Tree Results", "input": "", "output": "After synthesizing the clock trees, analyze the results to verify that they meet your requirements. Typically the analysis process consists of the following tasks: Analyzing the clock tree QoR (as described in Generating Clock Tree QoR Reports Analyzing the clock tree timing (as described in Analyzing Clock Timing Verifying the placement of the clock instances, using the GUI (as described in Analyzing Clock Trees in the GUI"}
{"instruction": "How do I Learning Data", "input": "", "output": "For designs with poor timing correlation between the preroute and postroute stages, you can improve the correlation by performing optimization after clock tree synthesis using machine learning (ML) data derived after detail routing. The machine learning concept uses the following terminology: Labels, which are the outputs you are trying to predict Features, which are the inputs that affect the outputs Model, which is the relationship between the features (inputs) and the labels (outputs) Training, which is the process of learning the relationship between the features (inputs) and the labels (outputs), based on the data collected To perform global-route-based optimization using machine learning (ML) data derived from the postroute stage, 1. Collect machine learning features and labels, and train the model by performing the following steps in a specific iteration, iteration N: a. Perform clock tree synthesis and clock routing by completing the build_clock and route_clock stages of the clock_opt command. b. Specify the output directory for the machine learning data by using the new est_delay.ml_delay_opto_dir application option. fc_shell> set_application_option \\ -name est_delay.ml_delay_opto_dir -value./ML c. Enable integrated feature extraction by setting the new est_delay.ml_delay_gre_mode application option to feature fc_shell> set_application_option \\ -name est_delay.ml_delay_gre_mode -value feature d. Perform global-route-based optimization by using the clock_opt -from final_opt command. e. Perform detail routing. f. Collect labels associated with the features that were previously collected during the clock_opt -from final_opt command by using the estimate_delay -training_labels command, as shown in the following example: fc_shell> estimate_delay -training_labels \"label_1\" \\ -output_dir./ML 389 Implementing Clock Trees and Performing Post-CTS Optimization Feedback The labels must be collected after detail routing, but before postroute optimization. g. Train the machine learning model for the collected features and label by using the estimate_delay -train_model command as shown in the following example: fc_shell> estimate_delay -train_model \"features_1 label_1\" \\ -output_dir./ML h. Continue with postroute optimization and the rest of the steps in the implementation flow. 2. Use the machine learning data to improve correlation by performing the following steps in the subsequent iteration, iteration N+1: a. Perform clock tree synthesis and clock routing by completing the build_clock and route_clock stages of the clock_opt command. b. Specify the output directory for the machine learning data by using the new est_delay.ml_delay_opto_dir application option. fc_shell> set_application_option \\ -name est_delay.ml_delay_opto_dir -value./ML c. Enable the machine learning model, which was derived in the previous iteration, by setting the new est_delay.ml_delay_gre_mode application option to enable fc_shell> set_application_option \\ -name est_delay.ml_delay_gre_mode -value enable d. Perform global-route-based optimization with the machine learning data by using the clock_opt -from final_opto command. e. Perform detail routing. f. Disable the machine learning model after you complete all the detail routing steps by using the estimate_delay -disable_model command, as shown in the following example: fc_shell> estimate_delay -disable_model -output_dir./ML g. Continue with postroute optimization and the rest of the steps in the implementation flow. When using this feature, ensure that The same scenarios are active at each step and each iteration of the flow The machine learning model is re-created if there are changes to the design, its environment, or the flow 390 Implementing Clock Trees and Performing Post-CTS Optimization Feedback"}
{"instruction": "How do I Specifying Settings for Multivoltage Designs", "input": "", "output": "For multivoltage designs, to Ensure that primary and secondary voltage areas are honored and cells are added in logical hierarchies that are physically in the corresponding voltage areas, use the -respect_voltage_areas option with the add_buffer_on_route command. Specify different library cells for different voltage areas, use the -voltage_area_specific_lib_cells option and specify the list of library cells using the {va1 lib_cell1 va2 lib_cell2...} format. When you use this option, you must also use the -lib_cell option. Specify different single-rail and dual-rail library cells for different voltage areas, use the -select_mv_buffers option and specify the list of library cells by using the {va1 single_rail_lib_cell1 dual_rail_lib_cell1 va2 single_rail_lib_cell2 dual_rail_lib_cell2...} format. 970 Optimizing the Fanout of a Net Feedback When you use this option, you must also use the -lib_cell option. For voltage areas that you do not specify with this option, the tool uses library cells specified with the -lib_cell option. For the default voltage area, specify DEFAULT_VA as the voltage area name. Allow buffers on physical feedthrough nets of a voltage area, specify the voltage areas with the -allow_physical_feedthrough_buffer option. This option can only be used with the -respect_voltage_areas or -voltage_area_specific_lib_cells option, and the voltage area you specify must be a primary voltage area. After you run the add_buffer_on_route command with this option, update the supply net and power domain setting for the added buffers by using the set_eco_power_intention command. Add cells within gas stations of specified supply nets, use the -respect_gas_station option and specify the supply net. Gas stations are areas with a constant power supply. These areas used for buffering nets that go through power domains that are powered down. To specify the maximum allowed distance from the gas station to the added buffer, use the -max_distance_route_to_gas_station option."}
{"instruction": "How do I Standard Power Grid Augmentation", "input": "", "output": "Standard power grid augmentation inserts as many PG augmentation shapes as possible to lower the instance voltage drop. To perform standard power grid augmentation, 1. Ensure that the block is fully routed with very few or no DRC violations. 2. Run voltage drop analysis using RedHawk Fusion, as described in Performing Voltage Drop Analysis The IC Validator tool uses the results of this voltage drop analysis to drive the power grid augmentation. 3. Set up the IC Validator environment as described in Setting Up the IC Validator Environment 4. (Optional) Enable distributed processing by using the set_host_options command, as described in Enabling IC Validator Multicore Processing 5. Set the application options for performing power grid augmentation, as described in Setting Options for Power Grid Augmentation At a minimum, you must define the power and ground nets on which to perform PG augmentation. To specify the power net, set the signoff.create_pg_augmentation.power_net_name application option. To specify the ground net, set the signoff.create_pg_augmentation.ground_net_name application option. If your design contains more than one power net, you must perform PG augmentation once for each power net. 6. Save the block to disk. When you run the signoff_create_pg_augmentation command, the IC Validator tool uses the on-disk information for the block, not the information in memory. To ensure accurate information, use the save_block command to save the current state of the block before running the signoff_create_pg_augmentation command. 7. Perform power grid augmentation by using the signoff_create_pg_augmentation command. When you run this command, you must specify the technology node for which to perform the augmentation by using the -node option. 700 Improving Instance Voltage Drop by Augmenting the Power Grid Feedback If you must perform incremental PG augmentation because your design contains more than one power net, use the -mode add command on subsequent runs to append the PG augmentation shapes to the existing shapes. 8. Run voltage drop analysis using RedHawk Fusion, as described in Performing Voltage Drop Analysis This second voltage drop analysis run measures the voltage drop after power grid augmentation. During standard PG augmentation, the signoff_create_pg_augmentation command performs the following tasks: 1. Inserts PG augmentation shapes for the specified regions When the IC Validator tool inserts the PG augmentation shapes, it considers the routing design rules to ensure that it does not create design rule violations. By default, the command performs PG augmentation for the entire block. To specify the regions for PG augmentation, use one or more of the following options: -coordinates_ground This option restricts PG augmentation for the ground net to the specified regions. -excluded_coordinates_ground This option prevents PG augmentation for the ground net in the specified regions. If you specify this option with the -coordinates_ground option, the command does not perform PG augmentation in the overlapping regions. -coordinates_power This option restricts PG augmentation for the power net to the specified regions. -excluded_coordinates_power This option prevents PG augmentation for the power net in the specified regions. If you specify this option with the -coordinates_power option, the command does not perform PG augmentation in the overlapping regions. The shapes added during PG augmentation have a shape_use attribute of pg_augmentation. You can use this attribute to query the shapes added during PG augmentation. For example, fc_shell> get_shapes -filter {shape_use=~pg_augmentation} 701 Improving Instance Voltage Drop by Augmenting the Power Grid Feedback 2. Generates a summary report that shows the following information for each PG net: The distribution of power grid augmentation shapes added on each layer The total number of metal shapes added, the total number of via shapes added, and the total number of all shapes added 3. Saves the updated block to disk See Also Timing-Driven Power Grid Augmentation Guided Power Grid Augmentation Removing PG Augmentation Shapes"}
{"instruction": "How do I Allowing Repeater Groups Over Macros", "input": "", "output": "Use the -allow_insertion_over_block option to allow repeater groups to be added on top of soft or hard macros. Note: If the repeater cell is an inverter, you are responsible for ensuring logical correctness. 986 Adding a Group of Repeaters Feedback"}
{"instruction": "How do I Performing Wire Spreading", "input": "", "output": "After you have performed detail routing and redundant via insertion, you can perform wire spreading to increase the average spacing between wires, which reduces the critical area short faults and therefore improves yield. To perform wire spreading, use the spread_zrt_wires comandcomandspread_zrt_wires spread_wires command. By default, the spread_wires command uses the following settings to spread the signal wires on the same layer: To perform wire spreading, use the spread_zrt_wires comandcomandspread_zrt_wires spread_wires command. By default, the spread_wires command uses the following settings to spread the signal wires on the same layer: Spreads the wires by half a pitch in the preferred direction To modify the spread distance, use the -pitch option. You specify the spread distance as a multiplier for the layer pitch. For example, to specify a spread distance of 1.5 times the layer pitch, use the following command: fc_shell> spread_wires -pitch 1.5 Uses twice the layer pitch as the minimum jog length To modify the minimum jog length, use the -min_jog_length option. You specify the minimum jog length as an integer multiple of the layer pitch. Uses the minimum layer spacing plus one half the layer pitch as the minimum jog length To modify the minimum jog spacing, use the -min_jog_spacing_by_layer_name option. You specify the minimum jog spacing in microns for each layer. The tool uses the default jog spacing for any unspecified layers. Figure 126 shows how the jog length and jog spacing values are used in wire spreading. Figure 126 Wire Spreading Results 633 Reducing Critical Areas Feedback In the following example, the minimum jog length is set to three times the layer pitch, the minimum jog spacing for the M1 layer is set to 0.07 microns, and the minimum jog spacing for the M2 layer is 0.08 microns. All other metal layers use the default minimum jog spacing. fc_shell> spread_wires -min_jog_length 3 \\ -min_jog_spacing_by_layer_name {{M1 0.07} {M2 0.08}} After spreading, the spread_wires command performs detail routing iterations to fix any DRC violations caused as a result of spreading. When you change the layout, it can change the timing of your block. Wire spreading has a timing-preservation mode that allows you to perform wire spreading without affecting the block timing. To enable timing-preservation mode for wire spreading, define the timing preservation constraints by using the following options with the spread_wires command: -timing_preserve_setup_slack_threshold threshold -timing_preserve_hold_slack_threshold threshold -timing_preserve_nets nets The threshold values are floating-point numbers in library units. Wire spreading is performed only on nets with slack greater than or equal to the specified values or the nets specified in the -timing_preserve_nets option, as well as adjacent nets on the same layer within two routing pitches."}
{"instruction": "How do I Analyzing the Routing Results", "input": "", "output": "You can analyze the routing results by reporting on the cell placement and routing statistics. The following topics describe how to perform these tasks: Generating a Congestion Report Generating a Congestion Map Performing Design Rule Checking Using Zroute Performing Signoff Design Rule Checking Performing Design Rule Checking in an External Tool Performing Layout-Versus-Schematic Checking Reporting the Routing Results Reporting the Wire Length Using the DRC Query Commands"}
{"instruction": "How do I Multiple-Patterning Concepts", "input": "", "output": "At the 20-nm process node and below, printing the required geometries is extremely difficult with the existing photolithography tools. To address this issue, a new technique, multiple patterning, is used to partition the layout mask into two or more separate masks, each of which has an increased manufacturing pitch to enable higher resolution and better printability. Figure 4 shows an example of double-patterning, where the layout mask is partitioned into two separate masks, MASK A and MASK B. Figure 4 Double-Patterning Example To use multiple patterning, you must be able to decompose the layout into two or more masks, each of which meets the multiple-patterning spacing requirements. A multiple- patterning violation occurs if your layout contains a region with an odd number of neighboring shapes where the distance between each pair of shapes is smaller than the multiple-patterning minimum spacing. This type of violation, which is called an odd cycle is shown in Figure 5 41 Fusion Compiler Concepts Feedback Figure 5 Odd-Cycle Violation If the spacing between any pair in the loop is greater than the multiple-patterning minimum spacing, no violation occurs and the layout can be decomposed. For example, in Figure 6 if the spacing,, between segments B and C is greater than the multiple-patterning minimum spacing, there is no odd cycle and the layout can be decomposed. Figure 6 No Odd-Cycle Violation The Fusion Compiler tool ensures that the generated layout is conducive to double patterning by considering the multiple-patterning spacing requirements during placement and routing and preventing odd cycles. In general, double patterning is performed only on the bottom (lowest) metal layers, which are referred to as multiple-patterning layers. The metal shapes on the multiple-patterning layers must meet the multiple-patterning spacing requirements, whether they are routing shapes or metal within the standard cells and macros. The metal shapes on other layers do not need to meet the stricter multiple-patterning spacing requirements. 42 Fusion Compiler Concepts Feedback Multiple-patterning considerations affect all parts of the place and route flow. Depending on your standard cell library, you follow either an uncolored or precolored multiple- patterning flow. You use the uncolored flow if the cells in your standard cell library have sufficient spacing to the cell boundaries to ensure that multiple-patterning violations do not occur during placement. This type of library is referred to as a correct-by-construction library most multiple-patterning libraries are correct-by-construction libraries. In the uncolored flow, the tool determines the appropriate mask settings for the pins and net shapes. You use the precolored flow if the cells in your standard cell library have assigned masks on the metal shapes inside the cells. These assigned masks are often referred to as colors and this type of library is referred to as a precolored library In the precolored flow, the tool must consider these mask assignments to ensure that multiple-patterning violations do not occur during placement. The tool also uses the mask assignments to determine the appropriate mask settings for the pins and net shapes. The mask assignments are represented as mask constraints in the Fusion Compiler tool. You must ensure that the mask constraints are properly set before starting place and route. For information about the mask constraints, see Mask Constraints"}
{"instruction": "How do I Using Routing Guides to Control the Routing Density", "input": "", "output": "By default, the maximum track utilization is 100 percent. You can use a routing guide to control the routing density within the routing guide boundary. To set the maximum track utilization for layers with a horizontal preferred direction, use the -horizontal_track_utilization option with the create_routing_guide command. To set the maximum track utilization for layers with a vertical preferred direction, use the -vertical_track_utilization option with the create_routing_guide command. By default, when you create these routing guides, they apply to all layers within the routing guide boundary. To set the routing density only for specific layers, use the -layers option to specify the affected layers. For example, to set a maximum track utilization of 50 percent for all layers with a horizontal preferred direction and a maximum track utilization of 30 percent for all layers with a vertical preferred direction within the rectangle with its lower-left corner at (0, 0) and its upper-right corner at (100, 100), use the following command: fc_shell> create_routing_guide -boundary {{0.0 0.0} {100.0 100.0}} \\ -horizontal_track_utilization 50 -vertical_track_utilization 30"}
{"instruction": "How do I Improvement", "input": "", "output": "The following topics provide information settings you can use to improve performance, power, and area (PPA) of a design: Enabling High-Effort Timing Mode Enabling Enhanced Delay Optimization to Improve Total Negative Slack Enabling High-Effort Area Mode Enabling the Embedded Area Optimization Flow"}
{"instruction": "How do I Checking Relative Placement Groups Before Placement", "input": "", "output": "Before you run placement and optimization, you can check the relative placement constraints for issues that might lead to critical or noncritical failures after placement by using the check_rp_constraints command. The following example checks for possible relative placement constraint violation in the group named rp_volt1: fc_shell> check_rp_constraints rp_volt1 ********************************************************************** *** Report : Relative Placement Summary Total number of specified top level relative placement groups: 1 Total number of relative placement groups which may not honor its constraints: 1 ************************************************************************* RP Group: rp_volt1 Warning: The height of relative placement group 'rp_volt1' is more than the height of voltage area or exclusive move bound. (RPGP-018) 812 Analyzing Relative Placement Groups Feedback"}
{"instruction": "How do I Creating Routing Guides During Boundary Cell Insertion", "input": "", "output": "If your technology file defines metal cut allowed and forbidden preferred grid extension rules, you can create routing guides for these rules during boundary cell insertion by using the -add_metal_cut_allowed option with the set_boundary_cell_rules command. When you use this option, the compile_boundary_cells command creates the following routing guides: Metal cut allowed routing guides, which cover the area taken up by all the placeable site rows reduced by the vertical shrink factor, which is 50 percent of the smallest site row height Forbidden preferred grid extension routing guides, which cover the remaining area up to the block boundary Note: This feature is supported only by the compile_boundary_cells command; it is not supported by the compile_targeted_boundary_cells command. 597 Performing Boundary Cell Insertion Feedback"}
{"instruction": "How do I Adding Buffers at a Specified Interval", "input": "", "output": "To add buffers to one or more nets at a specified interval, specify A list of one or more library cells to select from by using the -lib_cell option The distance between the driver of the net and the first buffer by using the -first_distance option The distance between the load pin of the net and the last buffer by using the -last_distance option You must use the -last_distance option with the -repeater_distance option or the -repeater_distance_length_ratio option. You can also use the -last_distance option with the -first_distance option. However, you cannot use it with the following options: -location -user_specified_buffers -user_specified_bus_buffers Note: When you use the -last_distance option, the value of the eco.add_buffer_on_route.min_distance_buffer_to_load application option is ignored. The interval between the buffers by using the -repeater_distance option Optionally, you can scale the distance between the buffers by Specifying a different scaling factor for each layer using the -scaled_by_layer option Using the ratio between the default width for the layer and the actual route width as the scaling factor by specifying the -scaled_by_width option The following example adds the BUF1 library cell on the nets n2 and n5 at an interval of 150 microns. The distance between the driver and the first repeater cell is 100 microns. fc_shell> add_buffer_on_route {n2 n5} -lib_cell BUF1 \\ -first_distance 100 -repeater_distance 150 966 Adding Buffers on Routed Nets Feedback The following example adds the BUF2 library cell on the net n1 at an interval of 100 microns. The distance between the driver and the first repeater cell is 50 microns and the last distance is 20 microns. fc_shell> add_buffer_on_route -repeater_distance 100 \\ -first_distance 50 -last_distance 20 net1 -lib_cell BUF2 By default, the tool uses eco_cell and eco_net as the name prefix of all new cells and nets. To specify a name prefix for the new cells and nets, use the -cell_prefix and -net_prefix options, respectively."}
{"instruction": "How do I Defining a Name Prefix for Clock Cells", "input": "", "output": "You can specify a name prefix for the cells added on the clock network during clock tree synthesis by using the cts.common.user_instance_name_prefix application option. The following example specifies CTS_ as the name prefix for the cells added on the clock network during clock tree synthesis: fc_shell> set_app_options \\ -name cts.common.user_instance_name_prefix -value \"CTS_\" To specify a name prefix for the cells added on the data nets during optimization, including during the clock_opt command, use the opt.common.user_instance_name_prefix application option, as described in Specifying a Cell Name Prefix for Optimization"}
{"instruction": "How do I Formal Verification", "input": "", "output": "The Formality tool uses formal techniques to prove or disprove the functional equivalence of two designs. It performs RTL-to-RTL, RTL-to-gate, and gate-to-gate verifications. Functional equivalence checking does not take into account static timing verification. The 34 Place and Route Design Flow Overview Feedback following figure shows an overview of the design flow from the Fusion Compiler tool to the Formality tool: Synthesis RTL/ netlist Ref. lib (NDM) Tech. data TLU+ files UPF files DEF/Tcl (Optional) SDC files (Optional) SVF files Design (NDM) Verilog UPF files Formality"}
{"instruction": "How do I Analyzing Libraries", "input": "", "output": "The Fusion Compiler tool provides the following library analysis capabilities, which can help achieve the performance, power, and area goals of your design: Identify redundant, outlier, and equivalent cells in library cell families, which you can exclude from optimization during the subsequent steps in the implementation flow. Identify gaps in library cell families, which you can provide as feedback to your library vendor with the goal of improving the reference libraries. Compare the delay, power, area, and other characteristics of equivalent cells in different libraries or different versions of the same library, which can help you identify the appropriate libraries to use for design implementation. A family of library cells is a collection of cells that share some common properties. The tool can identify a family of library cells based on User-identified library cells properties, such function, threshold voltage, and so on User-defined library cells lexical attributes and settings User-specified custom library cell families The following figure shows the high-level flow for performing library analysis. 83 Analyzing Libraries Feedback Figure 8 Library Analysis Flow For more information about the different types of library analysis flows, see the following topics: Introduction to Redundancies, Outliers, Equivalences, and Gaps in Library Cell Families Identifying Redundancies, Outliers, Equivalences, and Gaps in Library Cell Families Comparing Libraries"}
{"instruction": "How do I Defining Clock Cell Spacing Rules", "input": "", "output": "To define clock cell spacing rules, use the set_clock_cell_spacing command. At a minimum, you must specify the minimum spacing in the x-direction or the y-direction; typically you would specify the minimum spacing in both directions. To specify the minimum spacing in microns in the X-direction, set the -x_spacing option to a nonzero value This value is usually dependent on the library cell's drive strength and clock frequency. 363 Specifying the Clock Tree Synthesis Settings Feedback Y-direction, set the -y_spacing option to a nonzero value This value is usually less than half a row height. Note: Using a large spacing value increases the skew because the cells are spaced further away from the intended clusters of sinks. By default, the specified cell spacing requirements apply to all clock cells. To restrict the clock cell spacing rules to specific Library cells, use the -lib_cells option Clocks, use the -clocks option If adjoining clock cells both have cell spacing rules for a given direction, the sum of the spacing values applies. For example, if two adjoining clock cells both have a minimum cell spacing of 5 microns in the x-direction, they are placed at least 10 microns apart in the x-direction. You can relax the adjoining cell spacing rule by setting the cts.placement.cell_spacing_rule_style application option to maximum, in which case the tool uses the larger of the spacing settings between two adjoining cells instead of the sum of the spacing settings. For example, the clock cells in the previous example are placed at least 5 microns apart in the x-direction, instead of 10 microns. The clock cell spacing rules defined by the set_clock_cell_spacing command are honored by the synthesize_clock_trees balance_clock_groups, and clock_opt commands. To report clock cell spacing rules, use the report_clock_cell_spacings command. To remove clock cell spacing rules, use the remove_clock_cell_spacings command. By default, this command removes all clock cell spacing rules. To remove specific clock cell spacing rules, use the -lib_cells option."}
{"instruction": "How do I Performing Total-Power Optimization", "input": "", "output": "Total power optimization considers the combined leakage- and dynamic-power cost during optimization. To setup for total-power optimization, 1. Setup for leakage-power optimization by performing the following steps: a. Ensure that at least one scenario is enabled for leakage-power optimization by using the set_scenario_status -leakage_power true command. 2. Setup for dynamic-power optimization by performing the following steps: a. Annotate switching activity on the design, as described in Annotating the Switching Activity b. Ensure that at least one scenario is enabled for dynamic-power optimization by using the set_scenario_status -dynamic_power true command. When you use this setting, the tool performs total-power optimization during the clock_opt command."}
{"instruction": "How do I Activity-Based Optimization", "input": "", "output": "If you load a SAIF file, the Fusion Compiler tool analyzes the switching activity to evaluate whether to expand a tool-inserted clock gate. This analysis prevents the insertion of unnecessary clock gates. For example, in Figure 58, clock gates A1 and A2 are each common to two paths and are therefore candidates for multilevel expansion. Figure 58 Before Clock-Gate Level Expansion 312 Merging Clock Gates Feedback However, if clock gate A2 is always enabled, it has a toggle rate of 0 and a static probability of 1. Adding another clock-gate level does not provide any benefit in this case. The final configuration is shown in Figure 59 Figure 59 After Clock-Gate Level Expansion If clock-gate level expansion is enabled, the Fusion Compiler tool performs activity- driven analysis by default. If a SAIF file is not available, disable this feature by setting the compile.clockgate.enable_activity_drivel_level_expansion application option to false (the default is true ). If clock-gate level expansion is disabled, the tool ignores the compile.clockgate.enable_activity_driven_level_expansion application option."}
{"instruction": "How do I Preparing to Run IC Validator In-Design Commands", "input": "", "output": "The following topics describe the tasks you must perform before you run the IC Validator In-Design commands: Setting Up the IC Validator Environment Enabling IC Validator Multicore Processing Defining the Layer Mapping for IC Validator In-Design Commands"}
{"instruction": "How do I Starting the CLI", "input": "", "output": "The CLI interface is a text-only environment in which you enter commands at the command-line prompt. It is typically used for scripts, batch mode, and push-button operations. Before you start the command-line interface, ensure that the path to the bin directory is included in your $PATH variable. To start fc_shell, Enter the fc_shell command in a Linux shell. fc_shell You can include other options on the command line when you start the shell. For example, you can use -file script_file_name to execute a script -x command to execute a command -output_log_file file_name to create a log file of your session -help to display a list of the available options (without starting the shell) At startup, the tool : 1. Creates a command log file. 2. Reads and executes the setup files. 3. Executes any script files or commands specified by the -file and -x options, respectively, on the command line. 4. Displays the program header and fc_shell> prompt in the shell. See Also Using the Command Log File Using Setup Files Using Tcl Scripts 45 Entering fc_shell Commands Feedback"}
{"instruction": "How do I Detail Routing", "input": "", "output": "based on total routed via count = 98.96% (2902130 / 2932706 vias) Layer VIA1 = 97.81% (1091973/ 1116367 vias) Weight 1 = 97.81% (1091973 vias) Un-optimized = 2.19% (24394 vias) Total number of nets = 255165 0 open nets, of which 0 are frozen Total number of excluded ports = 0 ports of 0 unplaced cells connected to 0 nets 0 ports without pins of 0 cells connected to 0 nets 0 ports of 0 cover cells connected to 0 non-pg nets Total number of DRCs = 7398 Total number of antenna violations = antenna checking not active Information: Routes in non-preferred voltage areas = 8170 (ZRT-559) Topology ECO iteration 1 ended with 0 qualifying violations."}
{"instruction": "How do I Specifying Optimization Targets at the Postroute Stage", "input": "", "output": "At the final stages of your design flow, you can use the route_opt command to perform concurrent clock and data optimization on specific critical path groups or endpoints by using the following steps: 1. Enable targeted concurrent clock and data optimization for the route_opt command by setting the route_opt.flow.enable_targeted_ccd_wns_optimization application option to true 2. Specify the optimization target by using one or both of the following settings: Specify the path groups to optimize by using the ccd.targeted_ccd_path_groups application option Note: If a path group you specify with this application option is also specified as a path group to skip by using the ccd.skip_path_groups application option, the path group is skipped during targeted concurrent clock and data optimization. Specify the endpoints to optimize by using the ccd.targeted_ccd_end_points_file application option You must specify at least one of these settings. If you specify both, the tool optimizes the specified endpoints of the specified paths groups. 3. (Optional) Specify the type of optimization to perform by using the ccd.targeted_ccd_select_optimization_moves application option. The valid values are 381 Implementing Clock Trees and Performing Post-CTS Optimization Feedback auto, the default, which enables all optimization types, including buffering size_only, which enables sizing only equal_or_smaller_sizing, which enables sizing only to cells that are the same size or smaller footprint_sizing, which enables sizing only to cells with the same footprint 4. (Optional) Specify an optimization effort by using the ccd.targeted_ccd_wns_optimization_effort application option. The valid values are high (default), medium, and low. The higher the effort, the more timing QoR improvement you will see in the targeted paths, but at the expense of the timing QoR of other paths. 5. (Optional) Specify a threshold beyond which the slack for the path groups that are not targeted can be degraded by using the ccd.targeted_ccd_threshold_for_nontargeted_path_groups application option. By default, if the path groups that are not targeted have positive slack, the tool can degrade this slack until it reaches zero. For the route_opt command, you can enable both regular concurrent clock and data optimization by using the route_opt.flow.enable_ccd application option and targeted concurrent clock and data optimization by using the route_opt.flow.enable_targeted_ccd_wns_optimization application option. If you enable both, the tool performs regular concurrent clock and data optimization first, followed by targeted concurrent clock and data optimization. The following script performs targeted concurrent clock and data optimization on a block that has already undergone routing and postroute optimization: open_lib design1 open_block blk.post_route #Disable regular CCD optimization, which was previously performed set_app_options \\ -name route_opt.flow.enable_ccd -value false #Enable targeted CCD optimization set_app_options \\ -name route_opt.flow.enable_targeted_ccd_wns_optimization \\ -value true #Specify the path group and endpoints to target set_app_options -name ccd.targeted_ccd_path_groups -value clkA set_app_options -name ccd.targeted_ccd_end_points_file \\ -value clkA_ep.txt 382 Implementing Clock Trees and Performing Post-CTS Optimization Feedback #Specify the optimization type and effort set_app_options \\ -name ccd.targeted_ccd_select_optimization_moves -value size_only set_app_options -name ccd.targeted_ccd_wns_optimization_effort \\ -value medium # Perform the targeted CCD optimization route_opt"}
{"instruction": "How do I Defining Insertion Delay Requirements", "input": "", "output": "To override the default phase delay of zero for sink pins (derived or user-specified), use the -delay option with the set_clock_balance_points command to specify the 345 Defining the Clock Trees Feedback insertion delay requirements. The tool adds the specified delay (positive or negative) to the calculated insertion delay up to the specified sink pin. The syntax to define the insertion delay requirement for one or more sink pins is set_clock_balance_points [-clock clock -delay delay [-rise] [-fall] [-early] [-late] -balance_points pins [-corners corners The -clock option is not required. If you do not use it, the insertion delay requirement applies to all clocks. Clock tree synthesis uses the specified delay value for the path delay calculations used to build the clock tree. By default, the specified delay value is used for both longest-path and shortest-path calculations for both rising-edge and falling-edge paths. To control when the specified delay value is used, use the -rise -fall -early, and -late options. When you define insertion delay requirements, by default, they apply to all corners. To apply the definition to specific corners, use the -corners option. For example, to specify that clock tree synthesis should use an insertion delay of 2.0 ns for rising-edge shortest-path calculations for the U2/CLK pin for the CLK clock in the current corner, use the following command: fc_shell> set_clock_balance_points -clock [get_clocks CLK] \\ -rise -early -delay 2.0 -balance_points [get_pins U2/CLK] To report the user-defined insertion delay for sink pins, use the report_clock_balance_points command. This command reports the user-defined sink pins, the derived sink pins with user-specified insertion delay, and the user-defined ignore pins."}
{"instruction": "How do I Using the create_tap_cells Command", "input": "", "output": "ad_tap_cel_aray comandcomandsad_tap_cel_aray To add a tap cell array based on the site rows, use the create_tap_cells command. You must specify the name of the library cell to use for tap cell insertion ( -lib_cell option) and the maximum distance, in microns, between tap cells ( -distance option). 582 Inserting Tap Cells Feedback For example, fc_shell> create_tap_cells -lib_cell myreflib/mytapcell -distance 30 Note: If the place.legalize.enable_pin_color_alignment_check application option is true (its default is false ), the command ensures that internal cell pins and metal of the tap cells align with a routing track of the appropriate color when inserting the tap cells and shifts the tap cells to avoid violating color alignment. To avoid signoff DRC errors due to this shifting, reduce the tap distance slightly when this application option is true By default, the create_tap_cells command inserts tap cells in every row for the entire block. The tool starts inserting the tap cells at the left edge of the row and uses the specified tap distance to determine the location of the subsequent tap cells. In addition, if a tap cell does not exist within the minimum tap distance (half the specified tap distance) from each row edge adjacent to the block's boundary, a hard macro, or a hard placement blockage, the tool inserts an additional tap cell. Figure 121 shows the default tap cell placement for a block that uses the every-row insertion pattern. Note that extra tap cells are added to the right of the hard macro to ensure that a tap cell exists within the minimum tap distance from the edge of the hard macro. Figure 121 Default Tap Cell Placement 583 Inserting Tap Cells Feedback You can modify the following aspects of the default behavior: The library cell used for tap cell insertion on rows with a mirrored (MX) orientation Use the -mirrored_row_lib_cell option to specify the library cell to use for mirrored rows. The pattern used to insert the tap cells Use the -pattern option to specify one of the following tap cell insertion patterns: every_row (the default) This pattern inserts tap cells in every row. For this pattern, the tap distance specified with the -distance option should be approximately twice the maximum diffusion-to-tap value specified in the technology design rules. every_other_row This pattern inserts tap cells only in the odd-numbered rows. For this pattern, the tap distance specified with the -distance option should be approximately twice the maximum diffusion-to-tap value specified in the technology design rules. stagger This pattern inserts tap cells in every row with the tap cells in even rows offset by half the offset value ( -offset option) relative to the odd rows, which produces a checkerboard-like pattern. For this pattern, the tap distance specified with the -distance option should be approximately four times the maximum diffusion-to-tap value specified in the technology design rules. The offset from the left edge of the row Use the -offset option to shift the pattern startpoint to the right by the specified distance in microns. The handling of fixed cells By default, tap cells are inserted at the computed tap locations, regardless of whether a fixed cell occupies that location. Use the -skip_fixed_cells option to prevent the insertion of tap cells in locations occupied by fixed cells. By default, when you use this option, the command considers the fixed cell as a blockage and breaks the row at the fixed cell, which can result in a tap cell being inserted on each side of the fixed cell. To prevent tap cells from overlapping fixed cells without breaking the row, use the -preserve_distance_continuity option with the -skip_fixed_cells option. When you use both options, the command shifts the tap cell to avoid overlap with the fixed cell. The -preserve_distance_continuity option shifts only those tap cells whose computed tap location is occupied by an instance of one of the specified library cells. 584 Inserting Tap Cells Feedback For example, the following command shifts tap cells whose computed tap location is occupied by a fixed instance of the mylib/cell1 library cell: fc_shell> create_tap_cells -lib_cell mylib/tap -distance 30 \\ -skip_fixed_cells -preserve_distance_continuity mylib/cell1 When you use the -skip_fixed_cells option, you can also specify the minimum horizontal spacing between the boundary and a corner tap cell that is above or below a blocked area by using the -min_horizontal_periphery_spacing option. This option specifies the minimum number of unit tiles between the boundary and an affected corner tap cell. Figure 122 shows how using this option affects the tap cell placement both with and without boundary cells. Figure 122 Tap Cell Boundary Row Spacing -min_horizontal_periphery_spac -min_horizontal_periphery_spac The addition of extra tap cells You can use one or both of the following methods to prevent the insertion of extra tap cells: Use the -row_end_tap_bypass option to specify that the boundary cells contain taps, so additional tap cells are not inserted at the boundary. Note that the command does not verify that the block has boundary cells or that the boundary cells actually contain taps. Use the -at_distance_only option to allow the insertion of tap cells only at the specified tap distance, half of the tap distance, or one fourth of the tap distance (for the stagger pattern only). Note that using this option can cause DRC violations. The regions in which to insert tap cells Use the -voltage area option to restrict the tap cell insertion to the specified voltage areas. 585 Inserting Tap Cells Feedback The naming convention used to identify the inserted tap cell instances By default, the tool uses the following naming convention for inserted tap cells: tapfiller! library_cell_name number Use the -separator option to change the separator character from its default of \"!.\" To identify the tap cells inserted in a specific run, use the -prefix option to specify a prefix string. When you use this option, the tool uses the following naming convention: tapfiller! prefix library_cell_name number"}
{"instruction": "How do I Marking Clocks as Propagated After Clock Tree Synthesis", "input": "", "output": "If you run the synthesize_clock_trees or clock_opt command, after clock tree synthesis, the tool removes the ideal setting from all the synthesized clocks of all active scenarios and sets all the corresponding register clock pins as propagated. If your block has scenarios that were not set as active before clock tree synthesis, set these scenarios as active by using the set_scenario_status -active true command and mark all clocks as propagated by using the synthesize_clock_trees -propagate_only command, as shown in the following example: fc_shell> set_scenario_status -active true [all_scenarios] fc_shell> synthesize_clock_trees -propagate_only The synthesize_clock_trees -propagate_only command removes the ideal setting from the clocks; it does not perform clock tree synthesis."}
{"instruction": "How do I Setting Up for Power-Related Features", "input": "", "output": "The following topics describe the tasks you need to perform for setting up a design for power-related features: Annotating the Switching Activity Enabling Leakage Power Optimization for the compile_fusion Command Enabling Power Optimization for the clock_opt Command Improving Yield By Limiting the Percentage of Low-Threshold-Voltage (LVT) Cells Updating Activity for Improved Power Optimization Enabling the Power Integrity Features"}
{"instruction": "How do I Controlling MUX Optimization", "input": "", "output": "The Fusion Compiler tool can map combinational logic representing multiplexers in the HDL code directly to a single multiplexer (MUX) or a tree of multiplexer cells from the target logic library. Multiplexers are commonly modeled with if and case statements. To implement the mutliplexer logic, the HDL Compiler uses SELECT_OP cells, which the Fusion Compiler tool map to combinational logic or multiplexers in the logic library. 226 Controlling Mapping and Optimization Feedback User-specified Tool evaluated Implemented using MUX gates Implemented using MUX or non MUX gates based on area costing analyze elaborate Infers Select_OP cells compile_fusion"}
{"instruction": "How do I Setting the Policy for Early Data Checks", "input": "", "output": "To set or modify the policy for all the checks, or modify the policy settings for data checks, use the set_early_data_check_policy command. Use the following options to configure the policy: -checks : Specifies a predefined list of data checks. It supports an asterisk wildcard character (*) as the name of a check. -policy : Specifies the type of policy depending on what is supported by the check. This can be error : The tool issues an error message if the check does not support error as a policy. tolerate : The tool issues an error message if the check does not support tolerate as a policy. repair : The tool issues an error message if the check does not support repair as a policy. strict : The tool sets the first matching policy in the following order: 1. error 2. tolerate 3. repair For example, when a check supports the error and tolerate policies, and you select strict as the policy type, the error policy type is set. 850 Checking Designs With Abstracts for Top-Level-Closure Issues Feedback lenient : The tool sets the first matching policy in the following order: 1. repair 2. tolerate 3. error For example, when a check supports the error and tolerate policies, and you select lenient as the policy type, the tolerate policy type is set. Note: If you specify both the checks and policies, the configuration supports all the policies described in this section, depending on what the application-specific check supports. However, if you specify only the policies, but not the checks, the configuration supports only the strict and lenient policies. You can also use the if_not_exists keyword with the -policy option to set a policy on the current design only if the design does not already have a policy set. -strategy : Specifies the strategy to apply for a check. Note: -strategy is not applicable for the hierarchical checks. -references : Specifies the policy and strategy for reference subdesigns."}
{"instruction": "How do I Voltage Hotspot Analysis", "input": "", "output": "When rail analysis is complete, there might be hundreds to thousands of voltage drop violations reported in the analysis report, which might make it difficult to identify the root causes for the violations. Use the voltage hotspot analysis capability to generate hotspots for a power or ground net by dividing the whole chip into small grid boxes, and report rail-related information for the generated grid boxes. In addition, you can query cell- or geometry-based rail results only for the specific analysis type by using the get_instance_result and get_geometry_result commands. 939 Voltage Hotspot Analysis Feedback Hotspot analysis provides the following features: Identify the root cause of aggressors with high voltage drop, such as large current from the aggressor itself or from the neighboring cells due to simultaneous switching by the overlapping timing windows. Determine which design technique to use for fixing voltage violations based on the report, such as choosing a candidate reference cell for cell sizing replacement, moving or relocating cells to reduce voltage drops, or applying PG augmentation to solve a voltage drop issue. This section contains the following topics: Generating Hotspots Reporting Hotspots Removing Hotspots Voltage Hotspot Analysis Examples To write rail results only for the cell instances or geometries that reside in the hotspot area, use the get_instance_result and get_geometry_result commands. For more information, see Generating Instance-Based Analysis Reports and Generating Geometry- Based Analysis Reports"}
{"instruction": "How do I Specifying Block-Level Power Intent", "input": "", "output": "You must provide power intent of the subblock for the top-level design implementation when running hierarchical synthesis. To do so, you can provide full block-level UPF for the tool to automatically extract power intent interface. The following figure shows a subblock named U1, and the top-level power intent script loads the block-level power intent by using the load_upf command. Note: The block-level power intent specification is required only for hierarchical synthesis using ETMs. In the abstract flow, the UPF constraints are handled automatically by the tool. 830 Overview of Abstract Views Feedback U1 as an ETM in the PD_Top design Top-Level power intent create_power_domain PD_TOP -include_scope create_supply_net VDD_AO... load_upf block.upf -scope U1... connect_supply_net VDD_AO -port U1/VDD_AO Block-level power intent: block.upf create_power_domain PD_BLK -include_scope create_power_switch sw1 -domain PD_BLK \\ -input_supply_port {in VDD_AO} \\ -output_supply_port {out VDD_SW}...... add_port_state sw1/out -state {ON 1.08} -state {OFF off}... create_pst pst -supplies {VDD_SW...}"}
{"instruction": "How do I Making ECO Changes Using the eco_netlist Command", "input": "", "output": "You can make ECO changes to a block by using the eco_netlist command. If you are using the freeze silicon ECO flow, enable ECO changes in the freeze silicon mode by setting the design.eco_freeze_silicon_mode application option to true before you run the eco_netlist command. When you use the eco_netlist command, use one of the following two methods to make the ECO changes: Specify a golden Verilog netlist that includes the ECO changes by using the -by_verilog_file option Specify a golden block that includes the ECO changes by using the -block option When you use the -block option, by default, The tool assumes the golden block is in the current design library. To specify a different design library, use the -golden_lib option. The tool makes the ECO changes to the current design. To make the ECO changes to a different design, use the -working_block option. To specify the design library that contains the design specified by the -working_block option, use the -working_lib option. The tool compares the working design to the input Verilog netlist or the golden design and generates a change file containing netlist editing Tcl commands that implements the functional changes. You must specify the name of the output file by using the -write_changes option. By default, the tool ignores the following: Differences in the physical-only cells To consider the differences in the physical-only cells, use the -compare_physical_only_cells option. Timing ECO changes, such as cells that are resized or repeaters that are added or removed. To consider the timing ECO changes, in addition to the functional ECO changes, use the -extract_timing_eco_changes option. Differences in power and ground objects. 961 Making ECO Changes Using Netlist Editing Commands Feedback To make the ECO changes to the working design, source the change file that the eco_netlist command generates, as shown in the following example: fc_shell> eco_netlist -by_verilog_file eco.v \\ -compare_physical_only_cells -write_changes eco_changes.tcl fc_shell> source eco_changes.tcl"}
{"instruction": "How do I Performing Conventional Leakage-Power Optimization", "input": "", "output": "To set up for conventional leakage-power optimization during the preroute optimization stage, perform the following: 1. Ensure that at least one scenario is enabled for leakage-power optimization by using the set_scenario_status -leakage_power true command and the set_qor_strategy -metric leakage_power | total_power command for deciding the target of power flow. 2. (Optional) Change the effort level for power optimization by setting the set_qor_strategy -mode command to balanced or extreme_power. The default is balanced. This effort control for the power flow. When you use these settings, the tool performs conventional leakage-power optimization during the clock_opt command. However, it does not perform any dynamic-power optimization. 191 Setting Up for Power-Related Features Feedback"}
{"instruction": "How do I Modifying Routing Corridors", "input": "", "output": "You can make the following modifications to an existing routing corridor: Add new shapes to the routing corridor. To add new shapes, use the create_routing_corridor_shape command. Use the -routing_corridor option to specify the routing corridor that you want to update. You must specify the boundary of the routing corridor by using the -boundary or -path option (for details about these options, see Defining Routing Corridors ). You can also specify the minimum and maximum routing layers for the shape by using the -min_layer_name and -max_layer_name options. Remove rectangles from the routing corridor. To remove shapes, use the remove_routing_corridor_shapes command. Change the nets and supernets associated with the routing corridor. To add nets or supernets to a routing corridor, use the add_to_routing_corridor command. To remove nets or supernets from a routing corridor, use the remove_from_routing_corridor command. You can also modify routing corridors in the GUI by using the Create Route Corridor tool, the Move/Resize tool, or the Delete tool, or by editing the attributes in the Properties dialog box. 493 Routing Constraints Feedback"}
{"instruction": "How do I Arrays During Placement", "input": "", "output": "A sequential array, which is commonly used in storage devices, is a group of registers that are arranged as a two-dimensional array. The clock pins of the registers along a row of a sequential array are usually driven by a single clock-gating cell. To consider the clock-gating cells of a sequential array during placement, set the place.coarse.seq_array_icg_aware application option to true. Doing so can reduce the congestion caused by the clock nets."}
{"instruction": "How do I Defining Blockages That Exclude Registers", "input": "", "output": "To define partial blockages that exclude registers, specify the boundary, type ( -type register option), blockage percentage ( -blocked_percentage option), and optionally the name for the placement blockage. For example, to define a partial blockage that excludes registers, but allows a cell density of 50 percent for other cells, use the following commands: create_placement_blockage -boundary {{10 20} {100 200}} \\ -type register -blocked_percentage 50 Note: Register blockages are honored during placement, but not during legalization, optimization, or clock tree synthesis. 143 Specifying Physical Constraints for Placement and Legalization Feedback"}
{"instruction": "How do I Generating a Congestion Report", "input": "", "output": "To generate a congestion report, run the report_congestion command. fc_shell> report_congestion By default, the report_congestion command uses the congestion map stored with the block to report an overflow summary for the entire block. If a congestion map is not stored with the design, the command generates a congestion map by running global routing in congestion-map-only mode. Note: By default, only the hard congestion data is saved in the design library. To also save the soft congestion data, set the route.global.export_soft_congestion_maps application option to true before performing global routing. The command calculates the overflow as the sum of the overflow for each layer, ignoring any underflow. Example 26 shows the default report, which includes only the hard congestion data. Example 26 Default Global Route Congestion Report **************************************** Report : congestion Design : 564 Analyzing the Routing Results Feedback Version: Date : **************************************** Layer | overflow | # GRCs has Name | total | max | overflow (%) | max overflow Both Dirs | 39 | 8 | 14 ( 0.26%) | 1 H routing | 6 | 2 | 4 ( 0.07%) | 2 V routing | 33 | 8 | 10 ( 0.18%) | 1 In the default congestion report, \"H routing\" refers to results for horizontal routes only and \"V routing\" refers to results for vertical routes only. The total overflow value is the total number of wires in the block that do not have a corresponding track available. The max overflow value is the highest number of overutilized wires in a single global routing cell. The GRCs overflow value is the total number of overcongested global routing cells in the design. The GRCs max overflow value is the number of global routing cells that have the maximum overflow. Note: The overflow and global routing cell numbers reported by the report_congestion command might look slightly more optimistic than those reported by the route_global command because the tool rounds down the congestion information before saving it with the design. Use the following options to modify the default behavior: -rerun_global_router Use this option to rerun the global routing even if the block already has a congestion map. -boundary coordinates Use this option to restrict the reporting to a specific region of the block. -layers layers Use this option to restrict the reporting to specific layers. -mode global_route_cell_edge_based Use this option to report overflow information for each global routing cell. -include_soft_congestion_maps 565 Analyzing the Routing Results Feedback Use this option to output soft congestion reports, if they exist. A soft congestion report includes the demand from the soft nondefault spacing rules, as well as tool-generated soft rules. The command outputs a soft congestion report for each spacing weight level of the soft nondefault spacing rules used in the block. Each soft congestion report contains the sum of the hard and soft congestion with a weight level of at least the current soft level. See Also Global Routing Defining Minimum Wire Spacing Rules Generating a Congestion Map"}
{"instruction": "How do I Restricting the Target Libraries Used", "input": "", "output": "You can restrict the libraries used during clock tree synthesis for the top level or a lower level of the logical hierarchy of a design by using the set_target_library_subset -clock command. To enable the use of the target library subset, you must set the opt.common.enable_target_library_subset_opt application option to The following example specifies the buf1 and buf2 cells from the HVT_lib and LVT_lib libraries as clock tree references. However, it restricts the lower-level block named TSK_BLK to use only the cells from the LVT_lib library for its clock nets. Therefore, only buf1 and buf2 cells from the LVT_lib library are used as clock references for that block. fc_shell> set_lib_cell_purpose -include cts \\ {HVT_lib/buf1 HVT_lib/buf2 LVT_lib/buf1 LVT_lib/buf2} fc_shell> set_target_library_subset -clock {LVT_lib} \\ -objects [TOP/TSK_BLK] fc_shell> set_app_options \\ -name opt.common.enable_target_library_subset_opt -value 1 359 Specifying the Clock Tree Synthesis Settings Feedback"}
{"instruction": "How do I Pin-Trunk Offset", "input": "", "output": "The custom.route.bus_pin_trunk_offset application option changes the default spacing between the bus trunk and the bus bit pins."}
{"instruction": "How do I Reporting Shielding Statistics", "input": "", "output": "To report the shielding statistics, use the report_shields command. Note: In some cases there is a slight difference in the shielding ratios reported by the create_shields and report_shields commands. This is due to graph connectivity differences between the two commands. When the reported values differ, use the values reported by the report_shields command. The difference in reported values is typically less than three percent, but can be up to five percent. By default, the power and ground structure is not included in the shielding ratio calculation. To include the power and ground structure within a threshold distance in the shielding ratio calculation, set the route.common.pg_shield_distance_threshold application option, which specifies the distance threshold in microns. fc_shell> set_app_options \\ -name route.common.pg_shield_distance_threshold -value distance The default report generated by the report_shields command provides overall statistics, as shown in Reporting Shielding Statistics Example 23 Default Shielding Report fc_shell> report_shields... Shielded 82% side-wall of (reset) Shielded 96% side-wall of (clk) Shielded 2 nets with average ratio as follows. 1) 89.00% (total shield ratio/number of shielded nets) 2) 87.92% (total shield length/total shielded net length) You can output the statistics for each layer by using the -per_layer true option with the report_shields command, as shown in Example 24 Example 24 Layer-Based Shielding Report fc_shell> report_shields -per_layer true... Shielded 82% side-wall of (reset) Layer: M1 ratio: 0% Layer: M2 ratio: 40% 547 Performing Postroute Optimization Feedback Layer: M3 ratio: 85% Layer: M4 ratio: 80% Shielded 96% side-wall of (clk) Layer: M3 ratio: 0% Layer: M4 ratio: 96% Layer: M5 ratio: 100% Shielded 2 nets with average ratio as follows. 1) 89.00% (total shield ratio/number of shielded nets) 2) 87.92% (total shield length/total shielded net length)"}
{"instruction": "How do I Deriving Clock Tree Exceptions From Ideal Clock Latencies", "input": "", "output": "If you have set ideal clock latencies for specific sinks in your design, you can use the derive_clock_balance_points command to convert these ideal latency settings to clock tree exceptions. The derive_clock_balance_points command converts ideal latencies specified with the set_clock_latency command on clock sink pins to set_clock_balance_points commands. Use the derive_clock_balance_points command before clock tree synthesis, when the design has ideal clocks. By default, the derive_clock_balance_points command Generates balance point constraints for all ideal primary clocks of all active scenarios that are enabled for setup analysis, hold analysis, or both. It does not generate balance points for generated clocks. To generate the balance points for Specific primary clocks, use the -clocks option. All active scenarios of specific corners, use the -corners option. Calculates a reference latency for each primary ideal clock, which is the sum of the ideal source and network latency specified on the clock with the set_clock_latency command. To specify a different reference latency value, use the -reference_latency option. Applies the derived clock balance point constraints to the design. To generate an output file containing set_clock_balance_points commands, instead applying it to the design, use the -output option. Balance points that the tool derives are clock and corner specific. Ensure that appropriate set_clock_latency constraints are set for all clocks for all modes used for clock tree synthesis in at least the worst corner. The tool uses the following formula to derive the delay values for the corresponding set_clock_balance_points commands: (Clock balance point delay value at the sink) = (Reference latency of the clock) - (Total ideal clock latency at the sink) The total ideal clock latency at the sink is the sum of the source latency of the clock and the ideal network latency for the sink. 351 Defining the Clock Trees Feedback For example, assume you have the following timing constraint settings: fc_shell> set_clock_latency -source 0.5 [get_clocks clk] fc_shell> set_clock_latency 1.0 [get_clocks clk] fc_shell> set_clock_latency 1.5 [get_pins reg1/CK] fc_shell> set_clock_latency 0.5 [get_pins reg2/CK] If you run the derive_clock_balance_points command, the tool derives the following clock balance point constraints: fc_shell> set_clock_balance_points -delay -0.5 \\ -balance_points [get_pins reg1/CK] -clock clk -corners worst fc_shell> set_clock_balance_points -delay 0.5 \\ -balance_points [get_pins reg2/CK] -clock clk -corners worst To avoid conflicts, do not manually apply any clock balance points for a clock that you derive balance points with the derive_clock_balance_points command."}
{"instruction": "How do I Building the Local Clock Subtree Structures", "input": "", "output": "In a structural multisource clock tree, the local subtrees are directly driven by the clock mesh. You can synthesize these local subtrees by using the synthesize_multisource_clock_subtrees command. Before you synthesize the local subtrees, you must 1. Build the global clock distribution structure. 2. Model the clock mesh net with a realistic annotated delay and transition values using the set_annotated_delay and set_annotated_transition commands. 3. Remove dont_touch size_only fixed, and locked attributes setting on the clock cells that are not required. These settings prevent the synthesize_multisource_clock_subtrees command from merging or splitting clock cells, if necessary. 4. Specify settings for local subtree synthesis by using the set_multisource_clock_subtree_options command. You must specify The clock for synthesizing the subtrees by using the -clock option. The drivers of the subtrees to be synthesized by using the -driver_objects option. The clock specified with the -clock option should pass through each drivers specified with the -driver_objects option. Optionally you can Prevent the tool from merging specific clock tree cells by using the -dont_merge_cells option. Balance the levels of the local subtree by using the -balance_levels true option and specify a target number of levels, which applies to all sinks of the local subtree, by using the -target_level option. Optionally, you can apply a different target number of levels to specific sink pins and clock balance points by using the set_multisource_clock_subtree_constraints command with the -pins and -target_level options. Specify a maximum total wire delay from any subtree driver to any of its sinks by using the -max_total_wire_delay option and the corner it applies to by using the -corner option. 429 Implementing Multisource Clock Trees Feedback Enable the reordering of clock-gating cells by using the -enable_icg_reordering true option. When you enable this feature, the tool swaps the position of a clock-gating cell with the buffer that is driving the clock-gating cell. Then, the buffer is gated by the clock- gating cell, thereby reducing the dynamic power consumption. To perform reordering, you must Enable scenarios used for structural multisource clock tree synthesis for dynamic power optimization Annotate switching activity for the enable pins of the clock-gating cells You can prevent specific clock-gating cells from being reordered by using the set_multisource_clock_subtree_constraints command with the -cells and -ignore_for_icg_reordering options. To report the settings you specified, use the report_multisource_clock_subtree_options command. To remove the settings you specified, use the remove_multisource_clock_subtree_options command. 5. (Optional) Enable multicorner optimization by setting the cts.multisource.enable_multi_corner_support application option to true. The default is false By default, the tool uses the worst corner associated with the mode in which the subtree options are defined. When you enable this feature, the tool considers all corners associated with the mode in which the subtree options are defined. 6. (Optional) Ignore the maximum capacitance, maximum fanout, or both constraints of the clock drivers by using the cts.multisource.ignore_drc_on_subtree_driver application option. When you synthesize multisource clock subtrees, by default, the tool considers the maximum transition, capacitance, and fanout constraints of the clock drivers you specify. However, the clock drivers typically have relaxed or no maximum capacitance or maximum fanout constraint, which can affect the multisource clock tree QoR. The following example ignores both the maximum capacitance and maximum fanout constraints of the clock drivers: fc_shell> set_app_options \\ -name cts.multisource.ignore_drc_on_subtree_driver \\ -value \"max_fanout max_capacitance\" 7. (Optional) Enable fishbone routing for the subtree clock nets by using the cts.multisource.subtree_routing_mode application option. 430 Implementing Multisource Clock Trees Feedback fc_shell> set_app_options \\ -name cts.multisource.subtree_routing_mode -value fishbone 8. (Optional) Specify name prefixes and suffixes to use when merging and splitting clock cells during local subtree synthesis by using the following application options: cts.multisource.subtree_merge_cell_name_prefix cts.multisource.subtree_merge_cell_name_suffix cts.multisource.subtree_split_cell_name_prefix cts.multisource.subtree_split_cell_name_suffix cts.multisource.subtree_split_net_name_prefix cts.multisource.subtree_split_net_name_suffix When you run the synthesize_multisource_clock_subtrees command the tool performs the following steps: 1. Merges equivalent clock cells to remove any artificial boundaries between clusters of sinks. 2. Optimizes the subtree by splitting, sizing, and relocating the clock cells, and snaps the first level of clock cells to the clock straps. 3. Routes the clock nets. By default, it global routes the nets. However, if you enable fishbone routing by using the cts.multisource.subtree_routing_mode application option, the tool creates a mix of detail routed fishbone trunks and fingers, and global comb routes to connect the net loads to the fishbone fingers, as shown in Figure 97 You can control the fishbone routing by using the following application options: cts.routing.fishbone_max_tie_distance cts.routing.fishbone_max_sub_tie_distance cts.routing.fishbone_bias_threshold cts.routing.fishbone_bias_window cts.routing.fishbone_horizontal_bias_spacing cts.routing.fishbone_vertical_bias_spacing 4. Refines the clock trees by sizing and relocating cells based on the routing. 431 Analyzing the Clock Tree Results Feedback Figure 97 Detail Fishbone Routes and Global Comb Routes Global comb route Fishbone trunk Fishbone finger You can run specific steps of the synthesize_multisource_clock_subtrees command by using the -from and -to options and specifying merge optimize route_clock, or refine Structural subtrees that you build by using the synthesize_multisource_clock_subtrees command are not changed or removed when you subsequently run any clock tree synthesis command."}
{"instruction": "How do I Specifying Switching Probability for Supply Nets", "input": "", "output": "The leakage power of a block is scaled based on the switching probability of its supply nets, which represents the fraction of time a supply net is in the on state. You can specify the switching probability for one or more supply nets by using the set_supply_net_probability -static_probability command. By default, the switching probability is applied to the current scenario and the corresponding mode and corner. To specify modes, corners, or scenarios in which to apply the setting, use the -modes -corners, or -scenarios option. To get the switching probability of a supply net, use the get_supply_net_probability command, and to reset the value, use the reset_supply_net_probability command. By default, the tool propagates supply net activity through power switches and determines the static probability of the switched supply net based on the UPF power switch constraint. For example, consider the following UPF power switch constraint: create_power_switch my_switch \\ -output_supply_port {vout VDDS} \\ -input_supply_port {vin VDD} \\ -control_port {ms_sel ctrl1} \\ -control_port {ms_ctrl ctrl2} \\ -on_state {on vin {ms_ctrl &&!ms_sel}} 188 Setting Up for Power-Related Features Feedback The tool derives the static probability of the supply net named VDDS, which is connected to the output of the power switch, based on the probability of the power switch being on This is derived based on the following: The Boolean function specified with the -on_state option, which is ms_ctrl &&! ms_sel, and the switching activity (static probability) of the nets connected to the corresponding control ports, which are nets named ctrl1 and ctrl2. The switching probability of the supply net connected to the input supply port specified with the -on_state option, which is the supply net named VDD. The following application options control whether dynamic and leakage power are scaled based on the supply switching activity: The power.scale_dynamic_power_at_power_off option controls whether dynamic power is scaled. The default is false (no scaling). The power.scale_leakage_power_at_power_off option controls whether leakage power is scaled. The default is true (scaling is performed)."}
{"instruction": "How do I Defining Instance-Specific Via Ladder Constraints", "input": "", "output": "To define instance-specific via ladder constraints, use the set_via_ladder_constraints command. You must specify the instance pins and the via ladder templates that can be used for those pins. For example, to enable the use of the VL1, VL2, and VL3 via ladder templates for the u1/i1 and u2/i2 pins, use the following command: fc_shell> set_via_ladder_constraints -pins {u1/i1 u2/i2} \\ {VL1 VL2 VL3} To report the via ladder constraints, use the report_via_ladder_constraints command. To remove via ladder constraints, use the remove_via_ladder_constraints command. 456 Inserting Via Ladders Feedback"}
{"instruction": "How do I Preparing the Design", "input": "", "output": "The Fusion Compiler tool uses a design library to store your design and its associated library information. This topic describes how to create a design library and how to prepare and save your design. These steps are explained in the following topics: Defining the Search Path Setting Up Libraries Using Pin Access Checker Utility Analyzing Libraries Reading the Design Mitigating Design Mismatches Importing the Floorplan Information Setting Up Multivoltage Designs Specifying Timing Constraints and Settings Specifying Logical Design Rule Constraints Specifying Clock Gating Constraints Specifying Physical Constraints for Placement and Legalization Specifying Placement Settings Specifying Legalization Settings Controlling the Optimization of Cells, Nets, Pins, and Ports Specifying Settings for Preroute Optimization Setting Up for Power-Related Features Specifying the Routing Resources 72 Defining the Search Path Feedback Handling Design Data Using the Early Data Check Manager Applying Mega-Switch Command Settings"}
{"instruction": "How do I Inserting Via Ladders", "input": "", "output": "via ladder, which is also referred to as a via pillar, is a stacked via that starts from the pin layer and extends into an upper layer where the router connects to it. Via 446 Inserting Via Ladders Feedback ladders reduce the via resistance, which can improve performance and electromigration robustness. To use via ladders, Via ladder rules must be defined in the technology data for the design For information about defining via ladder rules, see Defining Via Ladder Rules You must insert the via ladders before you perform global routing The Fusion Compiler tool provides the following methods for inserting via ladders: Automatic insertion during preroute optimization, as described in Specifying Automatic Via Ladder Insertion Settings for Preroute Optimization Constraint-based insertion by using the insert_via_ladders command, as described in Constraint-Based Via Ladder Insertion Manual insertion by using the create_via_ladder command, as described in Manual Via Ladder Insertion See Also Querying Via Ladders Removing Via Ladders Controlling Via Ladder Connections"}
{"instruction": "How do I UPF Flows", "input": "", "output": "The Fusion Compiler tool supports both the traditional UPF flow and the golden UPF flow. The golden UPF flow is an optional method of maintaining the UPF multivoltage power intent of the design. It uses the original \"golden\" UPF file throughout the synthesis, physical implementation, and verification steps, along with supplemental UPF files generated by the Fusion Compiler tool. 39 Fusion Compiler Concepts Feedback Figure 3 compares the traditional UPF flow with the golden UPF flow. Figure 3 UPF-Prime (Traditional) and Golden UPF Flows The golden UPF flow maintains and uses the same, original \"golden\" UPF file throughout the flow. The Fusion Compiler tool writes power intent changes into a separate \"supplemental\" UPF file. Downstream tools and verification tools use a combination of the golden UPF file and the supplemental UPF file, instead of a single UPF' or UPF'' file. The golden UPF flow offers the following advantages: The golden UPF file remains unchanged throughout the flow, which keeps the form, structure, comment lines, and wildcard naming used in the UPF file as originally written. You can use tool-specific conditional statements to perform different tasks in different tools. Such statements are lost in the traditional UPF-prime flow. Changes to the power intent are easily tracked in the supplemental UPF file. You can optionally use the Verilog netlist to store all PG connectivity information, making connect_supply_net commands unnecessary in the UPF files. This can significantly simplify and reduce the overall size of the UPF files. To enable the golden UPF flow, use the following application option setting before you load the UPF: fc_shell> set_app_options -as_user_default \\ -list {mv.upf.enable_golden_upf true} To load supplemental UPF files, use the -supplemental option with the load_upf command. For more information about using the golden UPF flow, see SolvNet article 1412864, \"Golden UPF Flow Application Note.\" 40 Fusion Compiler Concepts Feedback"}
{"instruction": "How do I Controlling the Tapering Width", "input": "", "output": "By default, the wire is tapered to the default routing width, which is the routing width that is defined for the metal layer in the technology file. To taper the wire to the pin width rather than the default routing width, change the route.detail.pin_taper_mode application option to pin_width from its default of default_width before you perform detail routing. To enable pin tapering only when required to avoid DRC violations, set the route.detail.use_wide_wire_effort_level application option to either low or high This setting improves the nondefault via rate at a cost of longer runtime. You should use this option only when the majority of pins on the nets being routed are accessible with nondefault vias. To disable tapering for certain types of pins, set one or more of the following application options to true route.detail.use_wide_wire_to_input_pin route.detail.use_wide_wire_to_output_pin route.detail.use_wide_wire_to_macro_pin route.detail.use_wide_wire_to_pad_pin, and route.detail.use_wide_wire_to_port To disable tapering for all pins, set the -taper_distance option to 0 when you create the nondefault routing rule with the create_routing_rule command."}
{"instruction": "How do I Defining a Soft Placement Blockage", "input": "", "output": "To define a soft blockage, specify the boundary, type ( -type soft option), and optionally the name for the placement blockage. For example, to define a soft blockage enclosed by a rectangle with corners at (120, 75) and (230, 200), use the following command: create_placement_blockage -boundary {120 75 230 200} \\ -type soft A soft blockage prevents the initial placement from placing cells within the specified area, but allows legalization, optimization, and clock tree synthesis to do so. However, after placement and optimization, during subsequent incremental placement, the tool can move the cells added during legalization, optimization, and clock tree synthesis out of the soft blockage area. To prevent this, use the following application option setting: set_app_options -name place.coarse.enable_enhanced_soft_blockages \\ -value true 141 Specifying Physical Constraints for Placement and Legalization Feedback Note: Soft placement blockages are honored during placement, but not during legalization, optimization, or clock tree synthesis."}
{"instruction": "How do I Assigning Nets to a Routing Corridor", "input": "", "output": "To assign nets and supernets to a routing corridor, use the add_to_routing_corridor command. You must specify the routing corridor and the nets or supernets to add to it. You can assign a net or supernet to only one routing corridor and that routing corridor must cover all pins connected to the associated nets. In addition, the supernets must belong to the same block as the routing corridor. For example, to define a routing corridor named corridor_a and assign the nets named n1 and n2 to this routing corridor, use the following commands: fc_shell> create_routing_corridor -name corridor_a \\ -boundary { {10 10} {20 35} } \\ -min_layer_name M2 -max_layer_name M4 fc_shell> create_routing_corridor_shape -routing_corridor corridor_a \\ -boundary { {20 25} {40 35} } \\ -min_layer_name M2 -max_layer_name M4 fc_shell> create_routing_corridor_shape -routing_corridor corridor_a \\ -boundary { {40 10} {50 35} } \\ -min_layer_name M2 -max_layer_name M4 fc_shell> add_to_routing_corridor corridor_a [get_nets {n1 n2}] 492 Routing Constraints Feedback Note: You can also assign nets or supernets to the routing corridor by using the -object option when you use the create_routing_corridor command to create the routing corridor."}
{"instruction": "How do I Performing Signoff Design Rule Checking", "input": "", "output": "Signoff design rule checking runs the IC Validator tool within the Fusion Compiler tool to check the routing design rules defined in the foundry runset. To perform signoff design rule checking, run the signoff_check_drc command, as described in Performing Signoff Design Rule Checking. In addition, you can use the signoff_fix_drc command to automatically fix the DRC violations detected by the signoff_check_drc command. For more information, see Automatically Fixing Signoff DRC Violations Note: An IC Validator license is required to run the signoff_check_drc and signoff_fix_drc commands. 572 Analyzing the Routing Results Feedback"}
{"instruction": "How do I Reducing Dynamic Voltage Drop", "input": "", "output": "When running the compile_fusion command, you can reduce dynamic voltage drop across a block by enabling dynamic power shaping optimization by setting the compile.flow.enable_dps application option to true. The tool performs dynamic power shaping optimization during the final_opto stage of the compile_fusion command. When you enable this feature, the tool performs power analysis and uses useful skew techniques to reduce dynamic voltage drop. Optionally, you can customize the power analysis performed during dynamic power shaping optimization by using the ccd.dps.use_case application option."}
{"instruction": "How do I Synthesizing the Global Clock Trees", "input": "", "output": "Before you insert clock drivers, ensure that all clock tree synthesis settings, including clock routing rules, are specified. To perform clock tree synthesis and detail routing to build an H-tree style global clock tree, use the synthesize_multisource_global_clock_trees command. When building the H-tree, the tool tries to minimize the skew between the endpoints, which is essential for multisource clock tree synthesis. When you use this command to synthesize and detail route a global clock tree, you must specify The clock net to synthesize by using the -nets option. The library cells to use by using the -lib_cells option. You can specify both single- rail and dual-rail library cells. By default, the tool uses the Custom Router to route the H-tree structure and connect to the pins of the clock tree cells. If the Custom Router is unable to resolve all routing DRC violation when making pin connections, use the Zroute to make the pin connections by using the -use_zroute_for_pin_connections options. To stop the routes at the highest available metal layer close to the pin shape, use the -skip_pin_connections option. The following example synthesizes and detail routes a global clock tree for the clock net named clkA. fc_shell> synthesize_multisource_global_clock_trees \\ -nets [get_nets clkA] -lib_cells [get_lib_cells my_lib/CKBUF8X] \\ -use_zroute_for_pin_connections You can also use the synthesize_multisource_global_clock_trees command to only perform clock detail routing for an H-tree style clock structure that has already been synthesized. 413 Implementing Multisource Clock Trees Feedback When doing so, you must specify The startpoint of the global clock structure, by using the -roots option. The endpoints of the global clock structure by using the -leaves option. The following example detail routes an existing H-tree style clock structure. The startpoint is the port named clk1 and the endpoints are the inputs of a group of mesh drivers. fc_shell> synthesize_multisource_global_clock_trees \\ -roots [get_ports clk1] -leaves [get_pins mesh_buf*/A] \\ -use_zroute_for_pin_connections When routing the H-trees, the tool uses the highest routing layers available, based on the routing rules specified for the clock nets. These same layers can contain prerouted nets such as power and ground nets. To prevent placing clock drivers under these preroutes, which can cause pin accessibility issues, the synthesize_multisource_global_clock_trees command creates temporary placement blockages for the preroutes on the same layers it uses for routing. After it completes routing, it removes these temporary placement blockages, as shown in the following example output.... Net: clk; Rule: htree_ndr; Min Layer: M8; Max Layer: M9... Information: Using routing H/V layer pair 'M9'/'M8' for net 'clk'. (CTS-659)... Converting metal shapes in horizontal layer M9 and vertical layer M8 into placement blockages. In total 703 placement blockages created.... Successfully deleted all temporary placement blockages and the cell map. If you specify multirow-height cells with the -lib_cell option of the synthesize_multisource_global_clock_trees command, the tool might not be able to place them due to the temporary placement blockages it creates for the preroutes. If so, you can prevent the tool from creating the temporary placement blockages by setting the cts.multisource.enable_pin_accessibility_for_global_clock_trees application option to false To remove a clock structure created by the synthesize_multisource_global_clock_trees command, use the remove_multisource_global_clock_trees command. 414 Implementing Multisource Clock Trees Feedback"}
