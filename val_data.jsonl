{"header": "Postroute Redundant Via Insertion", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To perform postroute redundant via insertion, use the add_redundant_vias command. This command can replace single-cut vias with multiple-cut via arrays, single-cut vias with other single-cut vias that have a different contact code, and multiple-cut via arrays Fusion Compiler User Guide 626 Chapter 7: Chip Finishing and Design for Manufacturing Inserting Redundant Vias Feedback with different multiple-cut via arrays. During redundant via insertion, the detail router also checks the design rules within the neighboring partition to minimize DRC violations. By default, the add_redundant_vias command inserts redundant vias on all nets. To insert redundant vias only on specific nets, use the -nets option to specify the nets. Using net-specific redundant via insertion allows you to further improve the optimized via rate without causing large-scale routing and timing changes. After the vias are checked and replaced, the detail router rechecks for DRC violations and corrects any violations. If the percentage of redundant vias is not high enough, you can increase the effort level by using the -effort option to get a better redundant via rate. Increasing the effort level to high can increase the redundant via rate by about 3 to 5 percent by shifting the vias to make room for additional vias. However, because high-effort redundant via insertion moves the vias more, it can result in a less lithography-friendly pattern at the 45-nm technology node and below. In this case, you should use concurrent soft-rule-based redundant via insertion to improve the redundant via rate. You can also try to increase the postroute redundant via rate by setting the route.detail.optimize_wire_via_effort_level application option to high , which reduces the number of single vias and makes more room for redundant vias by reducing wire length. After you perform the initial postroute redundant via insertion, set the route.common.post_detail_route_redundant_via_insertion application option to enable automatic insertion of redundant vias after subsequent detail routing or ECO routing. This helps to maintain the redundant via rate in your block."}
{"header": "Defining the Search Path", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "The Fusion Compiler tool uses a search path to look for files that are specified with a relative path or with no path. To specify the search path, use the set_app_var command to set the search_path application variable to the list of directories, in order, in which to look for files. When the tool looks for a file, it starts searching in the leftmost directory specified in the search_path variable and uses the first matching file it finds. You can also use the Tcl lappend command to add your directories to the default search path, which is the directory from which you invoked the tool. For example, fc_shell> lappend search_path ./mylibdir"}
{"header": "Defining Cell Spacing Constraints for Legalization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Cell spacing constraints control the spacing between a standard cell and another standard cell or a boundary (the chip boundary, a hard macro, a hard macro keepout margin, a hard placement blockage, or a voltage area guard band). You assign library cells to groups (the boundaries are in a predefined group named SNPS_BOUNDARY), and then define the required spacing between cells in these groups. By default, there are no spacing constraints between standard cells during legalization. To enhance yield, you can define the valid spacing between standard cells or between a standard cell and a boundary. Note: The support for spacing constraints between standard cells and power or ground nets depends on how the net is represented in the block. If the power or ground net is defined as a complete blockage, the legalizer and the check_legality command ignore spacing rule violations between standard cells and the power or ground net. If the power or ground net is defined as a partial blockage, the legalizer and the check_legality command check for spacing rule violations between standard cells and the power or ground net. Cell spacing constraints are implemented by attaching labels, which are similar to attributes, to the left and right sides of library cells, assuming that the cell is in its north orientation, and specifying the invalid spacings between these labels. To define cell spacing constraints, 1. Add labels to the library cells that have spacing constraints by using the set_placement_spacing_label command. You must specify the following information for each label: The label name (the -name option) The library cells to which to apply the label (the -lib_cells option) The sides of the library cells to which to apply the label (the -side option, which can take a value of right left , or both The label definitions are additive; you can specify the same label to be used on the right side of some cells and the left side of other cells. For example, to assign a label named X to the right side of the cellA library cell and the left side of the cellB and cellC library cells, use the following commands: fc_shell> set_placement_spacing_label -name X \\ -lib_cells {cellA} -side right Fusion Compiler User Guide 151 Chapter 2: Preparing the Design Specifying Physical Constraints for Placement and Legalization Feedback fc_shell> set_placement_spacing_label -name X \\ -lib_cells {cellB cellC} -side left You can assign multiple labels to a side of a library cell. For example, to assign labels named Y and Z to the right side of the cellB library cell, use the following commands: fc_shell> set_placement_spacing_label -name Y \\ -lib_cells {cellB} -side right fc_shell> set_placement_spacing_label -name Z \\ -lib_cells {cellB} -side right 2. Define the spacing requirements between the labels by using the set_placement_spacing_rule command. You must specify the following information for each rule: The labels being constrained (the -labels option) You must specify exactly two labels in each set_spacing_label_rule comandcomandset_spacing_label_rule set_placement_spacing_rule command. You can specify any of the labels defined by the set_placement_spacing_label command or the predefined SNPS_BOUNDARY label, which includes the chip boundary, hard macro boundaries, a hard macro keepout margins, hard placement blockages, and voltage area guard bands. The two labels can be the same or different. The range of invalid spacings, in number of unit tiles For example, to specify that there must be at least one unit tile between labels X and Y (they cannot abut), use the following command: fc_shell> set_placement_spacing_rule -labels {X Y} {0 0} To specify that there must be at least one unit tile between X labels and any boundary, use the following command: fc_shell> set_placement_spacing_rule \\ -labels {X SNPS_BOUNDARY} {0 0} To specify that two X labels cannot have a spacing of two unit tiles, use the following command: fc_shell> set_placement_spacing_rule -labels {X X} {2 2} To specify that labels X and Z must have a spacing of less than two unit tiles or more than four unit tiles, use the following command: fc_shell> set_placement_spacing_rule -labels {X Z} {2 4} Fusion Compiler User Guide 152 Chapter 2: Preparing the Design Specifying Placement Settings Feedback Caution: The cell spacing constraints are not saved with the block; they apply only to the current session and must be redefined in each session."}
{"header": "Limiting the Latency Adjustment Values", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can limit the latency adjustment values for concurrent clock and data optimization performed during the place_opt clock_opt , and route_opt commands as follows: Limit the amount that the clock latencies are advanced by using the ccd.max_prepone application option. Limit the amount that the clock latencies are delayed by using the ccd.max_postpone application option. There is no default for these application options. Specify these values in the library timing units. The following example sets a limit of 0.2 for advancing and 0.1 for delaying clock latencies: fc_shell> set_app_options -list {ccd.max_prepone 0.2} fc_shell> set_app_options -list {ccd.max_postpone 0.1}"}
{"header": "Ensuring Clock Tree Exceptions are Valid", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To identify pins on the clock network, the tool checks if the is_clock_is_used_as_clock pin attribute is true during clock tree synthesis. If you use the set_clock_balance_points command to specify a clock tree exception on a pin for which the is_clock_is_used_as_clock attribute is false , the tool accepts the exception, but ignores it during clock tree synthesis. Fusion Compiler User Guide 347 Chapter 5: Clock Tree Synthesis Defining the Clock Trees Feedback Consider the clock network in the following figure. Figure 75 Specifying Exceptions on Pins Beyond the Clock Network CLK U2 FF3 n5 By default, the tool sets The is_clock_is_used_as_clock attribute of the U2/A, U2/Y, and FF3/D pins to false and considers the network beyond the U2/A pin as part of the data network The U2/A pin as an ignore pin and excludes the network beyond this from clock tree synthesis During clock tree synthesis, the tool adds a guide buffer and isolates the U2/A pin from the rest of the clock network. During subsequent data path optimization, the tool can fix any existing DRC violations beyond the guide buffer. Assume you want clock tree synthesis to fix DRC violations up to the FF3/D pin using clock tree constraints. To do so, you must 1. Specify the FF3/D pin as an explicit ignore pin as follows: fc_shell> set_clock_balance_points -clock [get_clocks CLK] \\ -consider_for_balancing false -balance_points [get_pins FF3/D] Fusion Compiler User Guide 348 Chapter 5: Clock Tree Synthesis Defining the Clock Trees Feedback 2. Force clock tree synthesis to consider the FF3/D pin as a pin on the clock network by using the set_sense -clock_leaf command as follows: fc_shell> set_sense -clock_leaf [get_pins FF3/D] The set_sense -clock_leaf command sets The is_clock_used_as_clock attribute to true for all the pins of the clock branches that fanin to the pin specified as the clock leaf The is_clock_used_as_clock attribute to false for all the pins in the fanout from the pin specified as the clock leaf, and the tool does not propagate the clock beyond this pin To check the value of the is_clock_used_as_clock pin attribute, use the get_attribute command, as shown in the following example: fc_shell> get_attribute [get_pins FF3/D] is_clock_used_as_clock"}
{"header": "Accessing SolvNetPlus", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The SolvNetPlus site includes a knowledge base of technical articles and answers to frequently asked questions about Synopsys tools. The SolvNetPlus site also gives you access to a wide range of Synopsys online services including software downloads, documentation, and technical support. To access the SolvNetPlus site, go to the following address: https://solvnetplus.synopsys.com If prompted, enter your user name and password. If you do not have a Synopsys user name and password, follow the instructions to sign up for an account. If you need help using the SolvNetPlus site, click REGISTRATION HELP in the top-right menu bar."}
{"header": "Via Ladder Rule Files", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The command generates two via ladder rule files: An XML file that provides information about the via ladder rules The XML file has the following syntax: <EmRule> <!-- template definition --> <Template name=\" rule_name \" for_electro_migration=\"true\" for_high_performance=\"true\"> <Layer name=\" layer_name \" row_number=\" cuts_per_row ... more layers </Template> \u2026 more templates </EmRule> Each Template section specifies the template for a via ladder rule. Within a template section, the via ladder structure is specified by specifying the number of cuts per row for each metal layer involved in the via ladder. By default, the generated XML file is named auto_perf_via_ladder_rule.xml. To specify a different name, use the -xml_file option. A script file that defines the via ladder rules The script file contains a create_via_rule command for each template defined in the XML file, as well as set_attribute commands to set the appropriate via rule attributes. By default, the generated script file is named auto_perf_via_ladder_rule.tcl. To specify a different file name, use the -rule_file option."}
{"header": "Global Routing", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Before you run global routing, Define the common routing application options For information about the common routing application options, see the route.common_options man page. Define the global routing application options For information about the global routing application options, see the route.global_options man page. To perform standalone global routing, use the route_global command. By default, global routing is not timing-driven. For information about enabling timing-driven global routing, see Timing-Driven Global Routing The global router divides a block into global routing cells. By default, the width of a global routing cell is the same as the height of a standard cell and is aligned with the standard cell rows. For each global routing cell, the routing capacity is calculated according to the blockages, pins, and routing tracks inside the cell. Although the nets are not assigned to the actual wire tracks during global routing, the number of nets assigned to each global routing cell is noted. The tool calculates the demand for wire tracks in each global routing cell and reports the overflows, which are the number of wire tracks that are still needed after the tool assigns nets to the available wire tracks in a global routing cell. For advanced node designs, via density can be a concern. To enable via density modeling, set the route.global.via_cut_modeling application option to true . The tool then calculates the number of vias in each global routing cell and reports via overflows. Global routing is done in two phases: The initial routing phase (phase 0), in which the tool routes the unconnected nets and calculates the overflow for each global routing cell The rerouting phases, in which the tool tries to reduce congestion by ripping up and rerouting nets around global routing cells with overflows The tool might perform several rerouting phases. At the end of each rerouting phase, the tool recalculates the overflows. You should see a reduction in the total number of global routing cells with overflow and in the total overflow numbers. The global router stops and exits from the rerouting phase when the congestion is solved or cannot be solved further or after the maximum number of phases has occurred, as defined by the -effort_level option. You can force the global router to perform the maximum number of phases based on the specified effort level by setting the route.global.force_full_effort application option to true . By default, the tool Fusion Compiler User Guide 526 Chapter 6: Routing and Postroute Optimization Routing Signal Nets Feedback uses medium effort and performs a maximum of three rerouting phases. You can perform up to six rerouting phases by specifying ultra effort. There are five global routing effort levels: minimum low medium high , and ultra Minimum ( -effort_level minimum The minimum effort level uses two times larger global routing cells relative to the other effort levels. It also has a much lower congestion cost and runs only one rerouting phase. It should only be used for prototype routing or for an initial congestion evaluation, not for detail routing. Low ( -effort_level low Low effort runs a maximum of two rerouting phases with very similar congestion cost. It is faster in comparison to medium effort and has reasonable QoR. If your block is not very congested, you can use the low effort level. Medium ( -effort_level medium Medium effort is the default effort level and runs a maximum of three rerouting phases. Global routing stops after the third phase or when the overflow is resolved, whichever occurs first. High ( -effort_level high High effort runs up to four rerouting phases. If your block is congested, use the high effort level. Ultra ( -effort_level ultra Ultra effort runs up to six rerouting phases. If your block is very congested, use the ultra effort level. At the end of global routing, the following information is stored in the design library: The g-links and g-vias on each routed net This information is used for the next routing steps. After Zroute performs track assignment and detail routing, it removes these g-links and g-vias from the design library. The congestion data This information is used to generate a congestion map. By default, only the hard congestion data is saved in the design library. To also save the soft congestion data, set the route.global.export_soft_congestion_maps application option to true before performing global routing. The soft congestion data includes demand from soft nondefault spacing rules, as well as tool-generated soft rules. Fusion Compiler User Guide 527 Chapter 6: Routing and Postroute Optimization Routing Signal Nets Feedback The global router reports block statistics and congestion data after the initial routing phase and after each rerouting phase. When global routing is complete, the global router reports a summary of the wire length and via count. Example 19 shows a global routing report. In the congestion report, the Overflow value is the total number of wires in the block that do not have a corresponding track available. The Max value corresponds to the highest number of overutilized wires in a single global routing cell. The GRCs value is the total number of overcongested global routing cells in the block. Example 19 Global Routing Report Start Global Route ... ... Design statistics: Design Bounding Box (0.00,0.00,3180.00,1154.00) Number of routing layers = 10 layer M1, dir Hor, min width = 0.05, min space = 0.05 pitch = 0.15 layer M2, dir Ver, min width = 0.06, min space = 0.06 pitch = 0.15 ... Net statistics: Total number of nets = 255165 Number of nets to route = 248716 Number of single or zero port nets = 1721 4728 nets are fully connected, of which 4728 are detail routed and 0 are global routed. 1648 nets have non-default rule clock_spacing ... phase3. Routing result: phase3. Both Dirs: Overflow = 3320 Max = 3 GRCs = 4405 (0.08%) phase3. H routing: Overflow = 1759 Max = 2 (GRCs = 1) GRCs = 2756 (0.10%) phase3. V routing: Overflow = 1560 Max = 3 (GRCs = 20) GRCs = 1649 (0.06%) phase3. M1 Overflow = 1475 Max = 2 (GRCs = 1) GRCs = 2426 (0.09%) phase3. M2 Overflow = 1265 Max = 3 (GRCs = 20) GRCs = 1343 (0.05%) ... Overflow over macro areas phase3. Both Dirs: Overflow = 293 Max = 2 GRCs = 300 (0.04%) phase3. H routing: Overflow = 133 Max = 1 (GRCs = 129) GRCs = 139 (0.03%) phase3. V routing: Overflow = 160 Max = 2 (GRCs = 2) GRCs = 161 (0.04%) phase3. M1 Overflow = 0 Max = 0 (GRCs = 0) GRCs = 0 (0.00%) phase3. M2 Overflow = 0 Max = 0 (GRCs = 0) GRCs = 0 (0.00%) ... Density distribution: Layer 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 > 1.2 M1 86.6 10.5 0.37 1.46 0.02 0.44 0.18 0.14 0.07 0.03 0.10 0.00 0.00 0.02 M2 68.2 14.4 7.71 4.54 2.07 1.55 0.66 0.28 0.13 0.03 0.33 0.00 0.00 0.02 ... phase3. Total Wire Length = 21154552.81 phase3. Layer M1 wire length = 947324.93 phase3. Layer M2 wire length = 3959478.25 ... phase3. Total Number of Contacts = 2530044 phase3. Via VIA12SQ_C count = 1050582 phase3. Via VIA23SQ_C count = 856311 ... phase3. completed. Fusion Compiler User Guide 528 Chapter 6: Routing and Postroute Optimization Routing Signal Nets Feedback Before proceeding to detail routing, display the congestion map in the GUI and check the overflow distribution. The congestion report and map help you to identify congested areas. For more information about the congestion report, see Generating a Congestion Report For more information about the congestion map, see Generating a Congestion Map"}
{"header": "Modifying the Stacking Order", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can modify the stacking order of the voltage area shapes by using the set_voltage_area_shape command. To raise a voltage area shape one position, use the -raise option. To lower a voltage area shape one position, use the -lower option. To move a voltage area shape to the top, use the -top option. To move a voltage area shape to the bottom, use the -bottom option. To move a voltage area shape directly above another shape, use the -above option. To move a voltage area shape directly below another shape, use the - below option."}
{"header": "Setting Routing Rules for Clock Gates", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "When you set constraints for physical implementation, you can set nondefault routing rules to define stricter (wider) wire width and spacing requirements for specific nets to improve timing and reduce crosstalk. To specify nondefault routing rules, use the create_routing_rule and set_routing_rule commands. Fusion Compiler User Guide 315 Chapter 4: Clock Gating Clock Gating and Multibit Registers Feedback However, the set_routing_rule command does not allow annotation on the output nets of tool-inserted clock gates, because these nets do not exist until after the execution of the compile_fusion command. To specify nondefault routing rules that are applied automatically on nets connected to the output pins of tool-inserted clock gates, use the set_clock_gate_routing_rule command. These rules are applied on clock gates after the compile_fusion command. For example, create_routing_rule cg_rule... set_clock_gate_routing_rule -rule cg_rule ... compile_fusion ... report_routing_rules"}
{"header": "Creating Constraints for Auto Floorplanning", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "Use the commands and application options described in this topic to create constraints for auto floorplanning. Commands Use the following two commands to set and report auto floorplanning constraints. These two commands do not affect explicit floorplanning. set_auto_floorplan_constraints The command sets constraints, such as utilization of the floorplan to be created during compile. For example, fc_shell> set_auto_floorplan_constraints -core_utilization 0.8 report_auto_floorplan_constraints The command reports the constraints set by the set_auto_floorplan_constraints command. To specify macro placement, pin placement, and voltage area shaping constraints, use the following commands: Macro placement constraints set_macro_constraints create_macro_array create_keepout_margin Pin placement constraints set_block_pin_constraints set_individual_pin_constraints Voltage area shaping constraints set_shaping_options Application Options Use these application options to set up auto floorplanning. compile.auto_floorplan.initialize (default: auto auto : Creates missing floorplan information. The tool exits with an error when inconsistent information is provided. true : Always creates the core and boundary. false : Never creates the core and boundary; uses only existing information. The tool exits with an error when encountering missing or inconsistent information. Fusion Compiler User Guide 111 Chapter 2: Preparing the Design Importing the Floorplan Information Feedback By default, the following objects are preserved: Existing placement of fixed macros Existing placement of pins and pads Existing shaping of voltage areas compile.auto_floorplan.place_pins (default: unplaced compile.auto_floorplan.place_ios (default: unplaced compile.auto_floorplan.place_hard_macros (default: unplaced compile.auto_floorplan.shape_voltage_areas (default: unshaped all : Always places and shapes objects even if they are fixed. Unplaced and unshaped objects will always be placed and shaped. unfixed : Places and shapes objects that are not fixed. Use the fixed information from DEF files or a Tcl floorplan, and use the set_fixed_objects command to modify. Unplaced and unshaped objects will always be placed and shaped. unplaced, unshaped : Never places or shapes objects when they are already placed. Unplaced and unshaped objects will always be placed and shaped. none : Never places or shapes objects even if they are not already placed. This table summarizes how the tool handles fixed, placed, and unplaced objects for each setting of these four application options during auto floorplanning. Application option setting Fixed objects Placed objects Unplaced objects all Placed and shaped Placed and shaped Placed and shaped unfixed Kept Placed and shaped Placed and shaped unplaced, unshaped Kept Kept Placed and shaped none Kept Kept Kept compile.auto_floorplan.keep_bounds (default: auto Fusion Compiler User Guide 112 Chapter 2: Preparing the Design Setting Up Multivoltage Designs Feedback auto : Removes existing bounds if either of the following two application options is set to all compile.auto_floorplan.place_hard_macros compile.auto_floorplan.shape_voltage_areas true : Keeps existing bounds. false : Removes existing bounds. compile.auto_floorplan.keep_placement_blockages (default: auto auto : Removes existing placement blockages if either of the following two application options is set to all compile.auto_floorplan.place_hard_macros compile.auto_floorplan.shape_voltage_areas true : Keeps existing placement blockages. false : Removes existing placement blockages. Automatic Floorplanning Example The following example specifies constraints for automatic floorplanning: # Application options with default settings # set_app_options -name compile.auto_floorplan.initialize -value auto # set_app_options -name compile.auto_floorplan.place_pins -value unplaced # set_app_options -name compile.auto_floorplan.place_ios -value unplaced # set_app_options -name compile.auto_floorplan.place_hard_macros \\ # -value unplaced # set_app_options -name compile.auto_floorplan.shape_voltage_areas \\ # -value unshaped # Constraint settings for automatic floorplanning set_auto_floorplan_constraints -core_utilization 0.75 -side_ratio {1 2} set_macro_constraints -preferred_location {0 0} RAM0 set_block_pin_constraints -self -sides {1 3} set_individual_pin_constraints -ports [get_ports reset] -side 1 set_shaping_options -guard_band_size 2"}
{"header": "Modifying Routed Nets", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can modify routed nets in the GUI by using the following tools: Area Push tool To activate the Area Push tool, click the button on the Edit toolbar or choose Edit > Area Push. You can use the Area Push tool to move unfixed objects away from a rectangular area on a layer while maintaining their physical connections. You select the layer and control whether the tool complies with nondefault routing rules. The tool supports both interactive and batch push operations. Spread Wire tool To activate the Spread Wires tool, click the button on the Edit toolbar or choose Edit > Spread Wires. You can use the Spread Wires tool to move selected, unfixed wires evenly between two points on a layer while maintaining their physical connections. You control whether the tool spreads the wires by layer and whether the tool complies with nondefault routing rules. Stretch Connected tool To activate the Stretch Connected tool, click the button or choose Edit > Stretch Connected. You can use the Stretch Connected tool to move and stretch unfixed wire shapes while optionally maintaining their physical connections. Quick Connect tool To activate the Quick Connect tool, click the button or choose Edit > Route Utilities > Quick Connect. You can use the Quick Connect tool to quickly connect wires to pin shapes, port shapes, terminals, or other wires. Fusion Compiler User Guide 561 Chapter 6: Routing and Postroute Optimization Routing Nets in the GUI Feedback If you need assistance while using these tools, click to open a Help page in the man page viewer. Fusion Compiler User Guide 562 Chapter 6: Routing and Postroute Optimization Cleaning Up Routed Nets Feedback"}
{"header": "Checking Relative Placement Groups Before Placement", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Before you run placement and optimization, you can check the relative placement constraints for issues that might lead to critical or noncritical failures after placement by using the check_rp_constraints command. The following example checks for possible relative placement constraint violation in the group named rp_volt1: fc_shell> check_rp_constraints rp_volt1 ********************************************************************** *** Report : Relative Placement Summary Total number of specified top level relative placement groups: 1 Total number of relative placement groups which may not honor its constraints: 1 ************************************************************************* RP Group: rp_volt1 ------------------------------------------------------------------------- Warning: The height of relative placement group 'rp_volt1' is more than the height of voltage area or exclusive move bound. (RPGP-018) Fusion Compiler User Guide 812 Chapter 10: Physical Datapath With Relative Placement Analyzing Relative Placement Groups Feedback"}
{"header": "Considering the Effects of Cell Pins During Placement", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "When you specify a technology node setting of 7+ s5 , or s4 by using the set_technology -node command, you can specify that the tool uses a technology- specific pin-cost model during placement by setting the place.coarse.pin_cost_aware application option to true . The default is false . When you enable this feature, during placement, the tool tries to improve pin accessibility by using a technology-specific model to predict the routing resources required to access each pin. For all other technology nodes, you can control the maximum local pin density during placement by setting the place.coarse.pin_density_aware application option to true The default is false Table 11 Settings for Controlling the Effects of Pins During Placement set_technology -node place.coarse. pin_cost_aware place.coarse. pin_density_aware The tool does this 7+ s5 , or s4 true true or false Performs technology-specific pin-cost-aware placement 7+ s5 , or s4 false true Performs pin-density-aware placement 7+ s5 , or s4 false false Does not consider the effects of cell pins during placement Any other setting true or false true Performs pin-density-aware placement Fusion Compiler User Guide 157 Chapter 2: Preparing the Design Specifying Placement Settings Feedback Table 11 Settings for Controlling the Effects of Pins During Placement (Continued) set_technology -node place.coarse. pin_cost_aware place.coarse. pin_density_aware The tool does this Any other setting true or false false Does not consider the effects of cell pins during placement"}
{"header": "Viewing Your Checkpoint History", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "To view your checkpoint history, navigate to the checkpoint directory. This directory contains a checkpoint_history.rpt file that captures the history of the checkpoints the tool encounters during each run, along with the runtime and memory usage for each checkpoint. The checkpoint directory also contains any checkpoint reports you have written to it. In some cases, you might want to clear the full or partial contents of your checkpoint history. A typical example is when a checkpointed run fails and you want to clear some or all of the data associated with that run, depending on whether you plan to rerun a portion of the flow or the entire flow. To clear your full checkpoint history, use the reset_checkpoints command. fc_shell> reset_checkpoints The reset_checkpoints command clears the full contents of the checkpoint directory, including any reports you have written to it. However, before clearing the checkpoint directory, the reset_checkpoints command saves a timestamped copy of the directory in your run directory. Fusion Compiler User Guide 61 Chapter 1: Working With the Fusion Compiler Tool Using Setup Files Feedback To clear a portion of the data in your checkpoint_history.rpt file, use the -from option to specify the name of a checkpoint. This option removes all checkpoints including and following the specified checkpoint from your checkpoint_history.rpt file; it does not remove any checkpoint reports you have written to the checkpoint directory. For example, suppose your checkpoint_history.rpt file contains the following data after your run a full checkpointed flow: Checkpoints Memory StartTime ... remove_buffers 32290.86 2020-03-23_14:34:17 ... place_opt_to_initial_drc 36389.15 2020-03-23_17:21:56 ... incr_placement 37002.09 2020-03-23_19:13:02 ... place_opt_to_initial_opto 45655.59 2020-03-23_23:44:36 ... place_opt_to_final_opto 46322.34 2020-03-23_30:12:55 ... Suppose you want to rerun your flow beginning with incremental placement. To clear the last three checkpoints from your checkpoint_history.rpt file before rerunning that portion of your flow, use the following command: fc_shell> reset_checkpoints -from incr_placement After clearing the checkpoints, your checkpoint_history.rpt file lists only the first two checkpoints in your flow: Checkpoints Memory StartTime ... remove_buffers 32290.86 2020-03-23_14:34:17 ... place_opt_to_initial_drc 36389.15 2020-03-23_17:21:56 ... Similarly, the get_checkpoint_data -list_names command returns only the remove_buffers and place_opt_to_initial_drc checkpoints: fc_shell> get_checkpoint_data -list_names remove_buffers place_opt_to_initial_drc"}
{"header": "Applying Compression to Groups With Straddling Leaf Cells", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can apply compression to a relative placement group with cells that straddle multiple rows or columns, as shown in the following example: fc_shell> add_to_rp_group rp -cells U5 \\ -column 0 -row 0 -num_columns 1 -num_rows 2 fc_shell> set_rp_group_options rp -tiling_type horizontal_compression Figure 181 shows the placement of the relative placement group in the previous example. Figure 181 Compression of a Relative Placement Group With a Cell That Straddles Multiple Rows Cell U5 straddles two rows For information about adding cells that straddle multiple rows or columns to a relative placement group, see Adding Leaf Cells Fusion Compiler User Guide 801 Chapter 10: Physical Datapath With Relative Placement Specifying Options for Relative Placement Groups Feedback"}
{"header": "Inserting Metal Fill", "size": 20.0, "font": "Arial-BoldMT", "flags": 20, "text": "After routing, you can fill the empty spaces in the block with metal wires to meet the metal density rules required by most fabrication processes. Before inserting metal fill, the block should be close to meeting timing and have very few or no DRC violations. To insert metal fill, run the signoff_create_metal_fill command, as described in Inserting Metal Fill With IC Validator In-Design Note: An IC Validator license is required to run the signoff_create_metal_fill command. Fusion Compiler User Guide 659 Feedback"}
{"header": "Running the signoff_check_drc Command", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To perform signoff design rule checking by running the signoff_check_drc command, 1. Set up the IC Validator environment as described in Setting Up the IC Validator Environment 2. (Optional) Enable distributed processing by using the set_host_options command, as described in Enabling IC Validator Multicore Processing Fusion Compiler User Guide 665 Chapter 8: IC Validator In-Design Performing Signoff Design Rule Checking Feedback 3. Set the application options for signoff design rule checking. At a minimum, you must specify the foundry runset to use for design rule checking by setting the signoff.check_drc.runset application option. For information about the options for command-based signoff design rule checking, see Setting Options for Signoff Design Rule Checking 4. Save the block to disk. When you run signoff design rule checking, the IC Validator tool uses the on- disk information for the block, not the information in memory. To ensure accurate information, use the save_block command to save the current state of the block before running signoff design rule checking. 5. Run signoff design rule checking by using the signoff_check_drc command. By default, the signoff_check_drc command performs the following tasks: 1. Loads the block into the IC Validator tool, as described in Reading Blocks for Signoff Design Rule Checking 2. Performs signoff design rule checking, as described in Signoff Design Rule Checking 3. Generates an error data file and IC Validator results files, as described in Signoff DRC Results Files You can use the results files to view the violations in the error browser, as described in Using the Error Browser, or to perform automatic design rule fixing, as described in Automatically Fixing Signoff DRC Violations You can use the following methods to analyze the DRC violations reported by the signoff_check_drc command: View the violations in the error browser, as described in Using the Error Browser. View the density of violations in a heat map, as described in Viewing the Violations in an ICV Heat Map See Also Checking Signoff Design Rules Interactively in the GUI Fusion Compiler User Guide 666 Chapter 8: IC Validator In-Design Performing Signoff Design Rule Checking Feedback"}
{"header": "Mapping ECO Cells to Logically Equivalent Spare Cells", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "When the tool maps an ECO cell, it looks for a spare cell with the same library cell name. If it is unable to find such a spare cell, the ECO cells remains unmapped. To identify and map such ECO cells to logically equivalent (LEQ) spare cells, use the following steps: 1. Identify the ECO cells that do not have matching spare cells by using the check_freeze_silicon command. 2. Find logically equivalent spare cells for these ECO cells by using the create_freeze_silicon_leq_change_list command. Specify The names of the unmapped ECO cells by using the -cells option A name for the output file by using the -output option This output file is a Tcl script with netlist editing commands. The commands replace each ECO cell with logically equivalent spare cells, which can be a Single spare cell with the same logical functionality, but a different library cell name Combination of up to two spare cells that give the same logical functionality 3. View the output Tcl file to ensure that the ECO mapping is satisfactory, and it if necessary. 4. Source the Tcl file in the tool to replace the ECO cells with their logical equivalents."}
{"header": "Signoff Metal Fill Result Files", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The signoff_create_metal_fill command stores the output files in the run directory specified by the signoff.create_metal_fill.run_dir application option (or the signoff_fill_run directory if you do not use this option). For each fill run, the command creates a subdirectory named icv_run_# that contains the files generated for that run. When you perform metal fill insertion, the tool writes the following files to the output directory: block .LAYOUT_ERRORS, which contains details about the detected errors block .RESULTS, which contains a summary of the run results signoff_create_metal_fill.log, which contains a summary of the run environment icv_config_out, which contains the paths to the top-level block and the cell libraries layer.map, which contains the generated layer mapping file metal_fill_params.rh, which contains the metal fill parameters and options that you specified metal_fill_compress_params.rh, which contains the storage commands and indicates whether the compression mode was flat (NONE) or hierarchical (AUTO) ./run_details directory, which contains all the data generated by the IC Validator tool for the metal fill insertion run"}
{"header": "Controlling How Buffers are Added", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, the add_buffer_on_route command Adds buffers over all placement blockages, soft macros, and hard macros. To prevent buffers from being placed over specific macro cells, use the -dont_allow_insertion_over_cell option. Alternatively, you can prevent the buffers from being placed over all blockages and macro cells by using the -respect_blockages option. When you use this option, you can specify a list of macro cells over which buffers are allowed by using the -allow_insertion_over_cell option. Adds buffers on both global routed and detail routed nets. To add buffers only on nets that are global routed only, without assigned tracks or detail routing, use the -only_global_routed_nets option. Adds buffers at the lowest common level of hierarchy of the pins being driven by the buffers. To add the buffers on the highest possible level of hierarchy, use the -on_top_hierarchy option. Does not add buffers on a route segment if it is necessary to create new ports because of a difference in the logical and physical topology of the net. To add buffers on such route segments by creating new ports, use the -punch_port option."}
{"header": "Creating Skew Groups", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "During clock tree synthesis, you might want to balance a group of sinks only among each other, and not the rest of the sinks. To do so, define a skew group by using the create_clock_skew_group command. When you use this command, specify the sinks you want to group, by using the -objects option. Optionally, you can specify the following: A clock or generated clock for which to create the skew group by using the -clock option. A mode for which to create the skew group by using the -mode option. Fusion Compiler User Guide 364 Chapter 5: Clock Tree Synthesis Specifying the Clock Tree Synthesis Settings Feedback By default, the tool creates the skew group for the current mode. A name for the skew group by using the -name option. The following example creates a skew group named sg1 consisting of sinks reg1/CP, reg2/ CP, and reg3/CP: fc_shell> create_clock_skew_group -name sg1 \\ -objects {reg1/CP reg2/CP reg3/CP} To report skew groups, use the report_clock_skew_groups command. To remove skew groups, use the remove_clock_skew_groups command."}
{"header": "Defining Gas Stations", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Gas stations are small voltage areas that are created for the purpose of minimizing the use of dual-rail buffers on physical feedthrough paths. Only single-rail repeaters are allowed in gas stations, and only optimization steps can add cells to gas stations. You create gas stations by using the create_voltage_area command during the design planning stage. The tool recognizes gas stations automatically and uses them by trading off the cost of a routing detour with the cost of using a dual-rail cell. Use the -nwell and -pwell options of the create_voltage_area command to specify n-well and p-well supply nets for a voltage area. Defining well supplies for gas station voltage areas provides flexibility for using gas stations for different design styles. If you do not use these options for a voltage area, the well bias values are assumed to be the same as the domain supply values. The report_voltage_areas command lists the n-well and p-well supply nets regardless of whether they are explicitly set."}
{"header": "Reporting Global Layer Constraints", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To report the ignored layers, use the report_ignored_layers command. For example, fc_shell> report_ignored_layers **************************************** Report : Ignored Layers Design : my_design Version: J-2014.12 Date : Wed Oct 22 15:58:23 2014 **************************************** Layer Attribute Value ----------------------------------------------------------------------- Min Routing Layer M2 Max Routing Layer M7 RC Estimation Ignored Layers PO M1 M2 M8 M9 MRDL Fusion Compiler User Guide 200 Chapter 2: Preparing the Design Specifying the Routing Resources Feedback"}
{"header": "Optimization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To improve correlation with the postroute stage of the design flow, you can enable global-route-layer-based RC estimation during the compile_fusion and clock_opt commands. With this feature, the tool uses global routes for all nets and identifies the layers with the most appropriate per-unit resistance values. The nets are then constrained to minimum and maximum layers for preroute RC estimation. To enable this feature, use the opt.common.use_route_aware_estimation application option. If you set it to auto , the feature is enabled only when there is a variation in the per-unit resistance value of the different routing layers true , the feature is enabled irrespective of the variation in the per-unit resistance value of the different routing layers If you enable this feature, use the remove_route_aware_estimation command to remove all global route based estimation before you perform routing."}
{"header": "Specifying Constraints for Clock Nets", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, the Fusion Compiler tool uses the default routing rule and any available routing layers to route the clock trees. You can specify the minimum and maximum routing layers for clock nets as described in Specifying the Routing Resources . These routing layer constraints are used during RC estimation, congestion analysis, and routing. Fusion Compiler User Guide 365 Chapter 5: Clock Tree Synthesis Specifying the Clock Tree Synthesis Settings Feedback To reduce the wire delays in the clock trees, you can use wide wires and higher metal layers instead. routing rulenondefault, defined Wide wires are represented by nondefault routing rules. To use nondefault routing rules on the clock nets, you must first define the routing rules and assign them to the clock nets as described in Using Nondefault Routing Rules"}
{"header": "Removing Constraints for a Group of Repeaters", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To remove the constraints that were assigned to a group of repeaters, use remove_repeater_group_constraints command. For example: fc_shell> remove_repeater_group_constraints -type type_list"}
{"header": "Defining Blockages That Allow Buffers Only", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To define a partial blockage that allows buffers only, specify the boundary, type ( -type allow_buffer_only option), blockage percentage ( -blocked_percentage option), and optionally the name for the placement blockage. For example, to define a partial blockage that allows only the placement of buffers and inverters, with a cell density of 30 percent, use the following commands: create_placement_blockage -boundary {{10 20} {100 200}} \\ -type allow_buffer_only -blocked_percentage 70 Fusion Compiler User Guide 144 Chapter 2: Preparing the Design Specifying Physical Constraints for Placement and Legalization Feedback Note: Buffer-only blockages are honored during placement, but not during legalization, optimization, or clock tree synthesis."}
{"header": "Near 100 Percent Redundant Via Insertion", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can achieve a redundant via rate near 100 percent by using hard-rule-based redundant via insertion. Hard-rule-based redundant via insertion can improve the redundant via rate by treating redundant vias as hard design rules during routing. You can use nearly 100 percent redundant via insertion only during initial routing; this method is not supported during ECO routing. When you use near 100 percent redundant via insertion during initial routing, you should use soft-rule-based redundant via insertion during ECO routing to preserve the redundant via rate achieved during initial routing. Note: This method can result in a very large runtime increase for congested blocks. You should use this method only when needed to improve the redundant via rate beyond that provided by concurrent soft-rule-based redundant via insertion and the soft-rule-based approach resulted in a redundant via rate of at least 90 percent. To perform concurrent hard-rule-based redundant via insertion, 1. Enable nearly 100 percent via insertion by setting the route.common.concurrent_redundant_via_mode application option to insert_at_high_cost . (By default, concurrent redundant via insertion is disabled.) fc_shell> set_app_options \\ -name route.common.concurrent_redundant_via_mode \\ -value insert_at_high_cost To control the effort used to reserve space for the redundant vias, set the route.common.concurrent_redundant_via_effort_level application option. Note: If you enable the route.common.concurrent_redundant_via_mode option before running the place_opt command, the redundant vias are considered during congestion estimation. Fusion Compiler User Guide 629 Chapter 7: Chip Finishing and Design for Manufacturing Inserting Redundant Vias Feedback 2. Route the block. During routing, Zroute inserts the redundant vias and fixes hard design rule violations. In general, redundant via insertion has the same priority as other hard design rules; however, if design rule checking does not converge during detail routing, Zroute automatically relaxes the redundant via constraints to improve DRC convergence."}
{"header": "Optimization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To improve correlation with the postroute stage of the design flow, the tool can perform global routing, perform extraction based on the global routes, and use this parasitic information when performing optimization. If the tool detects that the technology used by the design is an advanced technology node that is less than 16 nm, the tool enables this feature by default. To enable it for any technology, set the opt.common.enable_rde application option to true When enabled, the tool performs route-driven parasitic estimation during the final_opt stage of the compile_fusion and clock_opt commands. The parasitic information is Fusion Compiler User Guide 180 Chapter 2: Preparing the Design Specifying Settings for Preroute Optimization Feedback stored in the design library and used during subsequent optimization steps. If you enable this feature, you should enable it for all subsequent preroute optimization steps in the design flow. During route-driven estimation, the tool honors the capacitance and resistance scaling factors specified with the -early_cap_scale -late_cap_scale -early_res_scale and -late_res_scale options of the set_extraction_options command. When route-driven estimation is enabled, the tool ignores the setting of the opt.common.use_route_aware_estimation application option, which enables global- route-layer-based (GRLB) RC estimation."}
{"header": "Reading Blocks for Signoff Design Rule Checking", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, the IC Validator tool reads the design view for the top-level block and library cell instances, and the pin information from the frame view for the macro cell and I/O pad cell instances. To read both the pin information and the routing blockages from the frame view for macro cells and I/O pad cells, set the signoff.check_drc.ignore_blockages_in_cells application option to false To read the GDSII or OASIS data for specific reference cells, specify the stream files by setting the signoff.physical.merge_stream_files application option. When you use this option, the GDSII or OASIS data replaces the cell library view for the cells defined in the specified stream files, except for cells in the cell libraries specified in the signoff.physical.merge_exclude_libraries application option. To read the layout view for specific reference cells, specify the cells by setting the signoff.check_drc.read_layout_views application option. The layout view is identical to the GDSII or OASIS data that was used to create it, but reduces the runtime for signoff design rule checking. Note: By default, layout views are not included in the cell libraries. To save the layout views, you must set the lib.workspace.save_layout_views application option to true during library preparation, as described in the Library Manager User Guide To read the design view for specific reference cells, specify the cells by setting the signoff.check_drc.read_design_views application option. Note: By default, design views are not included in the cell libraries. To save the design views, you must set the lib.workspace.save_design_views application option to true during library preparation, as described in the Library Manager User Guide The order of precedence for child cell data is 1. GDSII or OASIS data specified with the signoff.physical.merge_stream_files application option 2. Layout views specified with the signoff.check_drc.read_layout_views application option If the IC Validator tool cannot find a layout view and the cell is specified in the signoff.check_drc.read_design_views application option, it reads the design view. Fusion Compiler User Guide 669 Chapter 8: IC Validator In-Design Performing Signoff Design Rule Checking Feedback Otherwise, it reads the frame view. If it cannot find the frame view, the cell is ignored during design rule checking. 3. Design views specified with the signoff.check_drc.read_design_views application option If the IC Validator tool cannot find a design view, it reads the frame view instead. If it cannot find the frame view, the cell is ignored during design rule checking. 4. Frame views For example, to read the design view for all blocks, use the following commands: fc_shell> set_app_options \\ -name signoff.check_drc.read_design_views -value {*} fc_shell> signoff_check_drc To read the design view for the top-level block and all instances of reference cells whose name start with mc, and the frame view for all other child blocks, use the following commands: fc_shell> set_app_options \\ -name signoff.check_drc.read_design_views -value {mc*} fc_shell> signoff_check_drc"}
{"header": "Manually Instantiating Spare Cells", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can manually instantiate spare cells in a block by using one of the following methods: Instantiating them in the Verilog netlist Adding them by using netlist editing commands such as create_cell connect_pin s, and so on When manually instantiating spare cells, you should Evenly distribute the spare cells through the logical hierarchy to better handle ECO changes anywhere in the block Tie their inputs to power or ground, as appropriate, to prevent the spare cells from creating noise and consuming power Fusion Compiler User Guide 956 Chapter 13: ECO Flow Manually Instantiating Spare Cells Feedback If a cell meets the following criteria, the tool automatically identifies it as a spare cell: It is not a physical-only cell All inputs except for the clock pin are unconnected or tied to a logic constant The clock pin of the spare cell, if any, can be connected to the clock network. All outputs are unconnected If you instantiate the spare cells before you perform physical synthesis on a block, the tool places and legalizes the spare cells during the subsequent physical synthesis steps. However, if you instantiate the spare cells in a block that is optimized, placed and legalized, you must place and legalize the spare cells by using the following steps: 1. Spread the spare cells by using the spread_spare_cells command. By default, this command distributes and places all the spare cells evenly throughout the core area. You can specify the spare cells to place by using one of the following two methods: To place specific spare cells, use the -cells option. To place all the spare cells that belong to specific voltage areas, use the -voltage_areas option. You can control the placement of the spare cells as follows: Specify an area within which to place the spare cells by using the -boundary option. Ignore specific types of placement blockages by using the -ignore_blockage_types option. By default, the add_spare_cells command honors all placement blockage types. Ignore the current cell density and place the spare cells randomly by using the -random_distribution option. Specify a percentage of spare cells to be placed based on the cell density distribution by using the -density_aware_ratio option. The rest of the spare cells are placed randomly throughout the design. By default, all the spare cells are placed based on the cell density distribution. For example, if you specify a setting of -density_aware_ratio 80 , the tool places 80 percent of the spare cells based on the cell density distribution and 20 percent randomly across the design. 2. Legalize the spare cells by using the place_eco_cells -legalize_only -cells command. Fusion Compiler User Guide 957 Chapter 13: ECO Flow Automatically Adding Spare Cells Feedback"}
{"header": "Creating Hierarchical Relative Placement Groups", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To create a hierarchical relative placement group by adding a group to another group, use the -rp_group option with the add_to_rp_group command. Specify the column and row position within the relative placement group by using the -column and -row options. The group you specify with the -rp_group option must be in the same design as the hierarchical group in which you are including it. When you include a relative placement group in a hierarchical group, it is as if the included group is directly embedded within its parent group. An included group can be used only in a group of the same design and only one time. However, a group that contains an included group can be further included in another group in the same design or can be instantiated in a group of a different design. The script in Example 43 creates a hierarchical group (rp4) that contains three included groups (rp1, rp2, and rp3). Groups rp1, rp2, rp3, and rp4 are all in the design top. The contents of groups rp1, rp2, and rp3 are treated as leaf cells when they are included in group rp4. You can further include group rp4 in another group in the design top, or you can instantiate group rp4 in a group of a different design. The resulting hierarchical relative placement group is shown in Figure 168 Example 43 Including Groups in a Hierarchical Group create_rp_group -name rp1 -columns 2 -rows 1 add_to_rp_group rp1 -cells U1 -column 0 -row 0 add_to_rp_group rp1 -cells U4 -column 1 -row 0 create_rp_group -name rp2 -columns 2 -rows 1 add_to_rp_group rp2 -cells U2 -column 0 -row 0 add_to_rp_group rp2 -cells U5 -column 1 -row 0 Fusion Compiler User Guide 787 Chapter 10: Physical Datapath With Relative Placement Adding Objects to a Group Feedback create_rp_group -name rp3 -columns 2 -rows 1 add_to_rp_group rp3 -cells U3 -column 0 -row 0 add_to_rp_group rp3 -cells U6 -column 1 -row 0 create_rp_group -name rp4 -columns 1 -rows 3 add_to_rp_group rp4 -rp_group rp1 -column 0 -row 0 add_to_rp_group rp4 -rp_group rp2 -column 0 -row 1 add_to_rp_group rp4 -rp_group rp3 -column 0 -row 2 Figure 168 Including Groups in a Hierarchical Group rp3 rp2 rp1 U3 U2 U4 U5 U6 U1 rp4 rp1 U4 U1 U3 U6 rp2 U2 U5 rp3 col 0 col 1 col 0 col 1 col 0 col 1 row 0 row 0 row 0 row 2 row 0 row 1 col 0"}
{"header": "Defining an Outer Keepout Margin", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can define an outer keepout margin on a hard macro, a hierarchical cell, or a leaf cell. When you define an outer keepout margin, you can either specify the keepout distance explicitly or, for hard macros, you can have the tool derive the keepout distance based on the macro pin count. To explicitly specify an outer keepout margin, use the -outer option to specify the margin distance for each side. You specify the left, bottom, right, and top margins using the following format: lx by rx ty . A value of 0 results in no keepout margin for that side. For example, to create a hard outer keepout margin with a margin of 10 on each side for a macro named my_macro, use the following command: fc_shell> create_keepout_margin -outer {10 10 10 10} my_macro To have the tool derive the outer keepout distance for a hard macro based on its pin count, use the -tracks_per_macro_pin option to specify the track-to-pin ratio. When you use this option, the tool calculates the keepout margin from the track width, the number of macro pins, and the specified track-to-pin ratio, which is typically set to a value near 0.5. A larger value results in larger keepout margins. The derived keepout margin is always hard; the -type setting is ignored. The derived margins are subject the minimum and maximum Fusion Compiler User Guide 138 Chapter 2: Preparing the Design Specifying Physical Constraints for Placement and Legalization Feedback values specified by the -min_padding_per_macro and -max_padding_per_macro options. For example, to have the tool derive the outer keepout margin for a macro named my_macro by using a track-to-pin ratio of 0.6 with a minimum keepout distance of 0.1 and a maximum keepout distance of 0.2, use the following command: fc_shell> create_keepout_margin -tracks_per_macro_pin 0.6 \\ -min_padding_per_macro 0.1 -max_padding_per_macro 0.2 my_macro"}
{"header": "Splitting Clock Cells", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can manually split clock cells that have DRC violations by using the split_clock_cells -cells command, as shown in the following example: fc_shell> split_clock_cells -cells [get_cells U1/ICG*] The tool does not split the specified cells if They do not have DRC violations They have don't-touch, size-only, or fixed-placement attribute settings It is necessary to punch ports on the boundaries of power domains or blocks that have been identified with the set_freeze_ports command After splitting a cell, the tool Names the new cells using the <original_cell_name>_split_<integer> naming convention Copies all the settings and constraints from the original cell to the newly created cells Fusion Compiler User Guide 385 Chapter 5: Clock Tree Synthesis Implementing Clock Trees and Performing Post-CTS Optimization Feedback Instead of specifying the cells to split, you can specify one or more collection of loads that are driven by the same driver by using the -loads option, as shown in the following example: fc_shell> set loads1 [get_pins I1/reg*/CK] fc_shell> set loads2 [get_pins I2/reg*/CK] fc_shell> split_clock_cells -loads [list $load1 $load2] After splitting, each set of loads is driven by a newly created driver."}
{"header": "Swapping Variant Cell", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The add_group_repeater and place_group_repeater commands support variant cell in group repeater insertion and placement. Fusion Compiler User Guide 991 Chapter 13: ECO Flow Swapping Variant Cell Feedback The following topics describe the steps in this flow Setting Constraints of Variant Cell Setting Application Option Grouping Variant Cell Running and Placing Group Repeaters Troubleshooting"}
{"header": "Concepts", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "This topic introduces the following concepts used in the Fusion Compiler tool: Power Intent Concepts UPF Flows Multiple-Patterning Concepts Fusion Compiler User Guide 37 Chapter 1: Working With the Fusion Compiler Tool Fusion Compiler Concepts Feedback"}
{"header": "Clock-Gating Enable Source Selection", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, the tool extracts the clock-gating enable condition from one of these sources: Signals connected directly to the synchronous enable pin of the sequential element, as shown in Figure 48 Figure 48 Directly Connected Enable Signal The enable condition on the feedback loops of the input and output data pins of the sequential element, as shown in Figure 49 Figure 49 Enable Signal in a Feedback Loop When using clock gating, you can specify the signal source of the enable logic. The set_clock_gating_objects -enable_source option applies to all objects specified with the -force or -include options in the same command. If you use the -enable_source option, you cannot use the -clear -reset , or -exclude options. Fusion Compiler User Guide 296 Chapter 4: Clock Gating Setting Up Clock Gating Feedback The -enable_source option can be one of the following: none enable_pin_only feedback_loop_only both (default) prefer_enable_pin prefer_feedback_loop For example, the following command inserts an always-enabled clock-gating cell: set_clock_gating_objects -force [get_cells u_dfx/input_b_reg*] \\ -enable_source none The following command uses the enable signal from the synchronous enable pin, if there is one. Otherwise, the tool uses the enable on the feedback loop of the register. set_clock_gating_objects -include [get_cells u_dfx/input_c_reg*] \\ -enable_source prefer_enable_pin"}
{"header": "Controlling the Selection of Self-Gating Objects", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To override the default behavior of selecting self-gating objects, use the set_self_gating_objects command with the following options: -force object_list Directs the tool to perform self-gating on the listed objects, even if the objects do not pass internal checks. -exclude object_list Prevents the tool from self-gating the listed objects, even if they pass the internal checks. -include object_list Specifies that the listed objects should be self-gated according to the insertion rules set by the set_clock_gating_options command. This is the default setting for all registers in the design. -clear object_list Removes all inclusion, exclusion, and forced criteria on the listed objects. -reset Removes all configurations previously set by the set_self_gating_objects command. -tree_type combinational_logic_type Specifies the type of combinational cells to use. Valid arguments are xor (the default), or nand , and auto . When auto is specified, the tool automatically decides which comparison logic to use based on switching activity information. This might help to reduce the area while optimizing power. You must use this option with the -include or -force options. To report self-gating objects, use the report_self_gating_objects command."}
{"header": "Specifying Antenna Properties", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "In general, the antenna properties for standard cells and hard macros are defined in their frame views in the reference libraries. You can set default values for the antenna properties, which apply to cells that do not have antenna properties defined in the reference libraries. route.detail.default_diode_protection Specifies the diode protection value used for standard cell output pins during antenna analysis if the diode protection value is not specified in the e view of the cell. route.detail.default_gate_size Specifies the gate size used for standard cell input pins during antenna analysis if the gate size is not specified in the e view of the cell. route.detail.default_port_external_antenna_area Specifies the antenna area used for ports (top-level pins) during antenna analysis if the antenna area is not specified in the e view of the cell. route.detail.default_port_external_gate_size Specifies the gate size used for ports (top-level pins) during antenna analysis if the gate size is not specified in the e view of the cell. route.detail.macro_pin_antenna_mode Specifies how macro cell pins are treated for antenna considerations. Fusion Compiler User Guide 616 Chapter 7: Chip Finishing and Design for Manufacturing Finding and Fixing Antenna Violations Feedback route.detail.port_antenna_mode Specifies how the ports (top-level pins) are treated for antenna considerations. If you are using a hierarchical flow and create a block abstraction for a block, you must use the derive_hier_antenna_property command to extract the antenna information from the block to use at the next level of hierarchy. Note: If the hierarchical antenna properties are not defined for all layers for a macro, Zroute treats the data as incomplete, skips antenna analysis, and issues a ZRT-311 warning message. If you get this error message, see SolvNet article 027178, \"Debugging the ZRT-311 Message .\" See Also Annotating Antenna Properties on Hard Macro Cells"}
{"header": "Controlling Mapping and Optimization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The following topics describe how you can customize and control the mapping and optimization that is performed during the initial_map logic_opto , and initial_drc stages of the compile_fusion command: Ungrouping or Preserving Hierarchies During Optimization Controlling Boundary Optimization Controlling Datapath Optimization Controlling MUX Optimization Controlling Sequential Mapping Controlling Register Replication Controlling Register Merging Fusion Compiler User Guide 217 Chapter 3: Physical Synthesis Controlling Mapping and Optimization Feedback Selectively Removing or Preserving Constant and Unloaded Registers Reporting Cross-Probing Information for Optimized Registers Controlling High-Fanout-Net Synthesis"}
{"header": "Using ETMs", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To minimize the number of iterations and obtain optimal results, you can perform feasibility analysis before running hierarchical synthesis, as shown in Figure 189 The hierarchical synthesis feasibility flow uses the following block-level information generated post compile_fusion Floorplanning information to generate the ETM in step 2 Power intent and test model (CTL) information for top-level synthesis in step 4 Fusion Compiler User Guide 825 Chapter 11: Hierarchical Implementation Performing Hierarchical Synthesis Using ETMs Feedback Figure 189 Hierarchical Synthesis Feasibility Analysis 1. Synthesize the block in the front- end tool compile_fusion RTL Block UPF (front end) Block CTL (front end) UPF SDC, floorplan SDC Design (ndm) Netlist UPF CTL SPEF Design (frame) 2. Create an ETM in the front-end tool extract_model Block_ETM (ndm) 3. Synthesize the top-level design in the front-end tool compile_fusion RTL Top-level UPF SDC, floorplan Fusion Compiler User Guide 826 Chapter 11: Hierarchical Implementation Performing Hierarchical Synthesis Using ETMs Feedback"}
{"header": "Conventions", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "The following conventions are used in Synopsys documentation. Convention Description Indicates syntax, such as write_file Indicates a user-defined value in syntax, such as write_file design_list Indicates user input\u2014text you type verbatim\u2014in examples, such as prompt> write_file top Purple Within an example, indicates information of special interest. Within a command-syntax section, indicates a default, such as include_enclosing = true | false [ ] Denotes optional arguments in syntax, such as write_file [-format fmt Fusion Compiler User Guide 29 About This User Guide Customer Support Feedback Convention Description ... Indicates that arguments can be repeated as many times as needed, such as pin1 pin2 ... pinN Indicates a choice among alternatives, such as low | medium | high Indicates a continuation of a command line. Indicates levels of directory structure. Bold Indicates a graphical user interface (GUI) element that has an action associated with it. Edit > Copy Indicates a path to a menu command, such as opening the Edit menu and choosing Copy Ctrl+C Indicates a keyboard combination, such as holding down the Ctrl key and pressing C."}
{"header": "Analyzing the Clock Mesh", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To reduce skew variation, clock mesh structures require higher timing accuracy than traditional clock structures. Therefore, to analyze a clock mesh structures, use the analyze_subcircuit command, which performs transistor level circuit simulation for the clock mesh and back-annotates accurate timing information. Before you run the analyze_subcircuit command, you must Detail route the clock mesh net. Have a circuit-level model for each of the gates in your clock tree and a transistor model for each of the transistors in the circuit-level models. Have access to a SPICE simulator such, as NanoSim, FineSim, or HSPICE. Fusion Compiler User Guide 423 Chapter 5: Clock Tree Synthesis Implementing Multisource Clock Trees Feedback For the analyze_subcircuit command, you must specify The clock mesh net you want to simulate by using the -net option. Alternatively, you can specify the sinks of the mesh net by using the -to option. If multiple clocks reach the net or the sinks you specify, use the -clock option to distinguish the clock you want to analyze. A name by using the -name option. This name is used to construct the circuit elements. It is also used in the name of the output files and the directory where the output is stored. Optionally you can specify an annotated transition on the clock port or the start point of your clock mesh. If you do so, the clock must be specified as propagated by using the set_propagated_clock command. When you run the analyze_subcircuit command, the tool performs the following steps: 1. Performs RC extraction and generates parasitic files. You can run extraction as a standalone step by using the -extraction option. 2. Generates SPICE files for simulating the clock mesh, using the parasitic files from the previous step as input. You can generate the SPICE files as a standalone step by using the -create_spice_deck option. When you do so, you can use parasitic files generated by a different extraction tool. If these parasitic files have a different naming convention, you can specify the appropriate file suffix by using the -spef_input_file_suffix and -rc_include_file_suffix options. 3. Runs SPICE simulation, using the SPICE files generated in the previous step as input. By default, the tool uses the NanoSim simulator. You can use the FineSim or HSPICE simulators by using the finesim or hspice setting with the -simulator option. You must specify the location of the circuit-level and transistor-level models by using the -driver_subckt_files and -spice_header_files options. You customize these settings by specifying different files for the maximum and minimum conditions within each scenario by using the -configuration option. You can run simulation as a standalone step by using the -run_simulation option. 4. Generates timing annotation files containing set_disable_timing set_annotated_delay , and set_annotated_transition commands, using the simulation results as input. Fusion Compiler User Guide 424 Chapter 5: Clock Tree Synthesis Implementing Multisource Clock Trees Feedback For clock mesh nets, which have multiple drivers, the set_disable_timing command is used to disable all except one of the drivers, which is called the anchor driver. The annotated net delay arcs are defined from the anchor driver. You can generate the timing annotation files as a standalone step by using the -write_annotation option. 5. Applies the annotation files generated in the previous step. You can apply the annotation files as a standalone step by using the -apply_annotation option. If you want to run some of the steps of the mesh analysis flow, such as extraction or SPICE simulation, using other tools, you can do so and run the rest of the steps of the flow using the standalone options of the analyze_subcircuit command, following the same sequence. The following example analyzes the clock mesh net named clk_mesh using the HSPICE simulator. It customizes the simulation by using different files for the minimum and maximum conditions of each scenario. fc_shell> analyze_subcircuit -net clk_mesh \\ -driver_subckt_files max_spice_model \\ -spice_header_files header_file \\ -configuration { \\ {-scenario_name scenario1 \\ -max_driver_subckt_files max_file1 \\ -max_spice_header_files header_max1 \\ -min_driver_subckt_files min_file1 \\ -min_spice_header_files header_min1} \\ {-scenario_name scenario2 \\ -max_driver_subckt_files max_file2 \\ -max_spice_header_files header_max2 \\ -min_driver_subckt_files min_file2 \\ -min_spice_header_files header_min2}} -simulator hspice \\ -name clk_mesh_analysis"}
{"header": "Using Custom Routing Application Options", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The Fusion Compiler tool provides a set of application options to control custom routing results. The application options are applied globally. To define net-specific routing constraints to override the routing applications options, see Defining Routing Constraints To list all application options that are available for custom routing, use the following command: fc_shell> report_app_options custom.route.* To use the hybrid flow for custom routing, set the custom.route.hybrid_flow application option to on . This sets the values for each of hybrid flow related application options automatically. Table 56 lists the application options for custom routing. Fusion Compiler User Guide 764 Chapter 9: Routing Using Custom Router Using Custom Routing Application Options Feedback Table 56 Application Options for Running Custom Routing Application option Description custom.route.bus_corner_type custom.route.bus_intra_shield_placement custom.route.bus_pin_trunk_offset custom.route.bus_split_even_bits custom.route.bus_split_ignore_width custom.route.bus_tap_off_enable custom.route.bus_tap_off_shielding Specifies constraints for bus routing. See Bus Routing Options custom.route.match_box Specifies the area within which the Custom Router performs length matching. custom.route.layer_grid_mode Specifies whether the route and corresponding parallel shields, jumpers for parallel shields, and bus shields snap to the wire tracks or the routing grid. See Track Adherence Options custom.route.diffpair_twist_jumper_enable custom.route.diffpair_twist_jumper_interval custom.route.diffpair_twist_jumper_offset custom.route.diffpair_twist_jumper_style Specifies constraints for differential-pair routing. See Differential-Pair Options custom.route.net_min_layer_mode custom.route.net_min_layer_mode_soft_cost custom.route.net_max_layer_mode custom.route.net_max_layer_mode_soft_cost Specifies the minimum and maximum layer mode and the layer cost. See Specifying Net-Specific Layer Constraints custom.route.routing_area Defines an area within which the Custom Router creates routes. Use this option if your block is large and you only need to create or modify routes within a specific area. custom.route.shield_connect_mesh_overlap custom.route.shield_connect_route custom.route.shield_connect_to_supply custom.route.shield_min_open_loop custom.route.shield_min_shield_seg custom.route.shield_min_signal_seg custom.route.shield_net custom.route.shield_second_net Specifies shielding constraints. See Shielding Options Fusion Compiler User Guide 765 Chapter 9: Routing Using Custom Router Using Custom Routing Application Options Feedback Table 56 Application Options for Running Custom Routing (Continued) Application option Description custom.route.single_loop_match custom.route.single_loop_match_max_spacing custom.route.single_loop_match_min_spacing custom.route.single_loop_match_offset_layer Specifies how to extend the wire. See Single-Loop Matching and Using a DDR Routing Flow custom.route.skip_connect_pin_type Enables the hybrid flow custom.route.distance_to_net_pin Hybrid flow only ) When using the skip_connect_pin_type option, skips the connection if the distance between the pin and the route is <= distance_to_net_pin Specify the distance_to_net_pin option as a list of pairs. The syntax for each pair of values is as follows: {{ netName distance }} custom.route.balance_mode Reduces the skews caused by wire length and via cut count differences in interposer designs. See Balance Mode Option"}
{"header": "Library Configuration", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Library configuration allows you to specify which vendor libraries to use as reference libraries for the current design. You specify the technology file, physical libraries, and logic libraries by using the search_path and link_library variables, and then you use the create_lib or set_ref_libs command to assemble the cell libraries. Fusion Compiler User Guide 76 Chapter 2: Preparing the Design Setting Up Libraries Feedback During library configuration, The Fusion Compiler tool automatically calls the Library Manager tool without user intervention to generate cell libraries, as shown in the following figure: .frame files ASCII technology file .db files Cell libraries Synthesis The tool saves the generated cell libraries to disk and adds them to the reference library list of the design library. These cell libraries are the same as when the cell libraries are created during library preparation in the Library Manager tool. For more information, see the Configuring Cell Libraries topic in the Fusion Compiler Data Model User Guide"}
{"header": "Reporting the Wire Length", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To report the total wire length at any stage of the routing flow, use the consolidated report_wirelength command. This command supports all net types, except power ground nets, by default such as signal nets, clock nets. It also supports non-stripe power ground nets by option control. This command generates a report, which includes the following information in the form of two tables, as shown in the figure: Total wire length per layer with separate global and detailed routing lengths Total wire length by both horizontal and vertical direction Fusion Compiler User Guide 576 Chapter 6: Routing and Postroute Optimization Analyzing the Routing Results Feedback In the generated report, Virtual value means the estimated routing wire length for each net. For each net, the engine provides a virtual routing length before real routing. It remains even after route_auto BestAvailable means the sum of wire length of all nets irrespective of the stage they are in the current design. This command also supports slanting wires and counts the real length of an angle wire in total and counts the projection length of the x-axis and y-axis."}
{"header": "Performing Design Analysis", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Use the reports generated by Fusion Compiler to analyze and debug your design. You can generate reports before and after you compile your design. Generate reports before compile to check that you have set attributes, constraints, and design rules properly. Generate reports after compile to analyze the results and debug your design. This section includes the following topics: Reporting Commands and Examples Measuring Quality of Results Comparing QoR Data Reporting Logic Levels in Batch Mode Querying Specific Message IDs"}
{"header": "Reducing Dynamic Voltage Drop", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "When running the compile_fusion command, you can reduce dynamic voltage drop across a block by enabling dynamic power shaping optimization by setting the compile.flow.enable_dps application option to true . The tool performs dynamic power shaping optimization during the final_opto stage of the compile_fusion command. When you enable this feature, the tool performs power analysis and uses useful skew techniques to reduce dynamic voltage drop. Optionally, you can customize the power analysis performed during dynamic power shaping optimization by using the ccd.dps.use_case application option."}
{"header": "Fixing Site Name Mismatches", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "If the site names used in the DEF file do not match the site names defined in the technology file, use the -convert_sites option to specify the site name mapping. For example, if the DEF file uses a site named CORE, but the technology file defines only a site named unit, use the following command to convert the site names when reading the DEF file: fc_shell> read_def -convert_sites { {CORE unit} } block .def"}
{"header": "Implementing Clock Trees and Performing Post-CTS Optimization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Before you perform clock tree synthesis, you should save the block. This allows you to refine the clock tree synthesis goals and rerun clock tree synthesis with the same starting point, if necessary. The following topics describe the different methods available for implementing clock trees: Performing Standalone Clock Trees Synthesis Synthesizing, Optimizing, and Routing Clock Trees With the clock_opt Command Controlling Concurrent Clock and Data Optimization Fusion Compiler User Guide 370 Chapter 5: Clock Tree Synthesis Implementing Clock Trees and Performing Post-CTS Optimization Feedback Splitting Clock Cells Balancing Skew Between Different Clock Trees Performing Global-Route-Based Optimization Using Machine Learning Data Routing Clock Trees Inserting Via Ladders During Clock Tree Synthesis, Optimization, and Clock Routing Marking Clocks as Propagated After Clock Tree Synthesis Performing Postroute Clock Tree Optimization Performing Voltage Optimization Marking Clock Trees as Synthesized Removing Clock Trees"}
{"header": "Improving the Banking Ratio", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "During the initial_mapping stage, the tool can prioritize the use of sequential library cells that have functionally equivalent multibit library cells. After you run the compile_fusion command, if the report_multibit -ignored_cells command indicates that many cells were not banked due to a lack of multibit cells in the library, you can enable this feature by setting the compile.seqmap.prefer_registers_with_multibit_equivalent application option to true and rerunning the compile_fusion command. However, enabling this feature might degrade the design QoR."}
{"header": "Using ECO Scripts for Netlist Editing", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "The Fusion Compiler tool supports using ECO scripts to make changes in the netlist during design planning. You can use the write_split_net_eco command to push up the branching of a physical multiple- fanout net to the top level write_push_down_eco command to push down a tree of standard cells one level write_spare_ports_eco command to create spare ports and nets on a child block For more information, see the Generating ECO Scripts for Netlist Editing topic in the Fusion Compiler Design Planning User Guide"}
{"header": "Adding Buffers in a Specified Configuration", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To add buffers in an exact configuration, specify the configuration of cells and their locations by using the -user_specified_buffers option. With the -user_specified_buffers option, you can add cells only on one net at a time. You can insert different types of buffers or inverter pairs by using this option, but you cannot combine both buffers and inverter pairs. For each cell you add, use the {instance_name library_cell_name x y layer_name... } format with the -user_specified_buffers option to specify the Instance name Library cell to use Coordinates of the exact location Layer at that location with an existing routing shape to connect to Instead of specifying the routing layer, you can have the tool automatically detect the closest routing shape to that location by using the -detect_layer option. The following example adds two cells named ECO1 and ECO2 on net n22. The ECO1 cell is of type BUF2, at location (100, 70), connecting to a routing shape on the M3 layer. The ECO2 cell is of type BUF4, at location (150, 70), also connecting to a routing shape on the M3 layer. fc_shell> add_buffer_on_route net22 \\ -user_specified_buffers {ECO1 BUF2 100 70 M3 ECO2 BUF4 150 70 M3}"}
{"header": "Inserting Diodes During Detail Routing", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "One way to protect gates from antenna effects is to provide a discharge path for the accumulated charge to leave the net. However, the discharge path should not allow current to flow during normal chip operation. Discharging can be accomplished by inserting a reverse-biased diode on the net close to the gate that is being protected. To enable diode insertion during detail routing, set the route.detail.insert_diodes_during_routing application option to true To control diode insertion, set the following application options: To specify a preference for fixing antenna violations by using diode insertion rather than layer hopping, set the route.detail.antenna_fixing_preference application option to use_diodes To require fixing of antenna violations by using diode insertion, disable layer hopping by setting the route.detail.hop_layers_to_fix_antenna application option to false By default, when you enable diode insertion, Zroute can fix an antenna violation either by adding a new diode or by using an existing spare diode. Zroute determines which method to use, based on which is closest to the required location: an empty location for a new diode or an existing spare diode. To specify a preference for using a new diode or using an existing spare diode, set the route.detail.diode_preference application option to new or spare respectively. To reset the diode preference to the default behavior, set the route.detail.diode_preference application option to none If you want Zroute to use only one of these methods, set the route.detail.diode_insertion_mode application option to new to force the insertion of new diodes or to spare to force the use of existing spare diodes. To reset the diode insertion method to the default behavior, set the route.detail.diode_insertion_mode application option to new_and_spare Note: To take advantage of spare diodes for antenna violation fixing, you need to add the spare diodes either before or after standard-cell placement and before routing the areas where antenna violations might occur. When inserting new diodes, Zroute selects the diodes from the reference libraries and inserts them into existing open spaces. To control which diodes are used, set the route.detail.diode_libcell_names application option. When you specify the diode library cells, use only the cell names. If you include the library name, the tool does not recognize the diode cells. Fusion Compiler User Guide 619 Chapter 7: Chip Finishing and Design for Manufacturing Finding and Fixing Antenna Violations Feedback By default, Zroute reuses existing filler cell locations for diode insertion. To prevent Zroute from reusing these locations, set the route.detail.reuse_filler_locations_for_diodes application option to false Zroute considers voltage areas when inserting diode cells and also observes the logic hierarchy assignments for diode cells. If a pin has an antenna violation, the diode cells are inserted at the same level of logic hierarchy as the violating pin. If a top-level port has an antenna violation, by default, the diode cells are inserted at the top level. However, if the port belongs to a voltage area, you can insert the diode cells in the logic hierarchy associated with the voltage area by setting the route.detail.use_lower_hierarchy_for_port_diodes application option to true To remove the redundant diodes during routing, set the route.detail.delete_redundant_diodes_during_routing application option to true"}
{"header": "Running Commands in the Background", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To improve runtime, you can run checking and reporting commands in the background while you run other commands in the foreground. This is useful in interactive sessions when you want to continue your work while the tool generates a report. To run commands in the background, use the redirect command with the -bg option. When you use this command, fc_shell returns immediately to execute the next command. If you issue an exit command in the parent process, the tool waits for all redirect -bg commands to complete before exiting. To list the commands supported by the redirect -bg command, use the list_commands -bg command. You can run either a single command or source a Tcl script that contains Fusion Compiler User Guide 69 Chapter 1: Working With the Fusion Compiler Tool Enabling Multicore Processing Feedback only supported commands. If the command or script includes a redirect -bg command, the -bg option is ignored. You can run at most two jobs in the background. If you specify more than two background jobs, they are queued. To specify the maximum number of cores to use for the background jobs, use the -max_cores option with the redirect command. The number of cores available for the parent process (as specified by the -max_cores option of the set_host_options command) is reduced by the number of cores allocated for background jobs. The following example redirects a Tcl script to run in the background: fc_shell> set_host_options -max_cores 8 fc_shell> redirect -bg -max_cores 3 -file bg_log.out \\ {source bg_script.tcl} Information: redirect -bg with max_cores 3 started. The maximum number of cores available in parent is reduced to 5. (BGE-004) Reporting Background Jobs To report the background jobs submitted with the redirect -bg command, use the report_background_jobs command. This command reports both the completed jobs and the jobs currently running in the background, as shown in the following example: fc_shell> report_background_jobs JOB 'redirect -bg -file {background.log} source bg_script.tcl -max_cores 4 ' completed JOB(pid:13010) 'redirect -bg -file {background_1.log} source bg_script_1.tcl -max_cores 3 ' is running To omit the completed jobs, use the -reset option with the report_background_jobs command."}
{"header": "Controlling Physical-Feedthrough Nets in Voltage Areas", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "A net is considered to be native to a voltage area if one or more segments of that net are in a logical hierarchy of that voltage area. If a net must physically route over a nonnative voltage area, then it is a physical feedthrough net of that voltage area, as shown in the following figure. Fusion Compiler User Guide 127 Chapter 2: Preparing the Design Setting Up Multivoltage Designs Feedback Figure 18 Physical-Feedthrough Nets of Voltage Areas VA0 (PD0 ) VA1 (PD1) N1 Top (PD0) Block1 (PD1) N1 Physical view Logical view By default, physical-feedthrough nets are allowed in voltage areas. To prevent physical-feedthrough nets in a voltage area, define a voltage area rule using the create_voltage_area_rule -allow_pass_through false command, as shown in the following example: fc_shell> create_voltage_area_rule -allow_pass_through false \\ -name VA1_rule -voltage_areas VA1 With this rule, the N1 net detours around the VA1 voltage area, as shown in Figure 19 Figure 19 Physical-Feedthrough Nets Disabled for a Voltage Area VA0 N1 VA1 By default, optimization does not insert buffers on physical-feedthrough nets of voltage areas. Inserting a buffer on a physical-feedthrough net can cause a mismatch between the Fusion Compiler User Guide 128 Chapter 2: Preparing the Design Setting Up Multivoltage Designs Feedback logical and physical view of the buffer. The tool resolves such mismatches by supporting the following types of optimization for such nets: Physical-feedthrough buffering During physical-feedthrough buffering the tool performs the following: 1. Inserts buffers in the logical hierarchy of its drivers or loads and applies the power domain of the nonnative voltage area on the buffer using power-domain-on-instance (PDOI) constraints 2. Places the buffers within the nonnative voltage area To allow physical-feedthrough buffering, use the create_voltage_area_rule -allow_physical_feedthrough true command, as shown in the following example: fc_shell> create_voltage_area_rule \\ -allow_physical_feedthrough true \\ -name VA1_rule -voltage_areas VA1 Logical-feedthrough buffering During logical-feedthrough the tool performs the following: 1. Adds buffers in the logical hierarchy corresponding to the nonnative voltage area 2. Places the buffers within the nonnative voltage area To allow logical-feedthrough buffering, use the create_voltage_area_rule -allow_logical_feedthrough true command. To specify logical hierarchies in which feedthrough buffers are allowed or not allowed, use the -include_logical_feedthrough_hierarchy or -exclude_logical_feedthrough_hierarchy option, respectively. The following example enables logical-feedthrough buffering for the VA1 voltage area and limits the feedthrough buffers to only the U1 and U2 hierarchical cells: fc_shell> create_voltage_area_rule \\ -allow_logical_feedthrough true \\ -include_logical_feedthrough_hierarchy {U1 U2}\\ -name VA1_rule -voltage_areas VA1 The following example enables logical-feedthrough buffering for the VA2 voltage area and excludes the U3 hierarchical cell from feedthrough buffering: fc_shell> create_voltage_area_rule \\ -allow_logical_feedthrough true \\ -exclude_logical_feedthrough_hierarchy {U3}\\ -name VA2_rule -voltage_areas VA2 Fusion Compiler User Guide 129 Chapter 2: Preparing the Design Setting Up Multivoltage Designs Feedback Note: To add a logical-feedthrough buffer to a lower-level block, the tool has to add new boundary ports to that block. Therefore, freezing the boundary of a block by using the set_freeze_ports command prevents the tool from adding a logical-feedthrough buffer to that block. Figure 20 Difference in the Logical View After Physical- and Logical-Feedthrough Buffering To create a default rule that applies to all voltage areas that do not have a specific rule, use the create_voltage_area_rule command with the -default_rule option, as shown in the following example: fc_shell> create_voltage_area_rule -default_rule \\ -allow_physical_feedthrough true If a voltage area does not have a specific rule, and there is no default rule, feedthrough buffering for that voltage area is controlled by the opt.common.allow_physical_feedthrough application option setting. To report voltage area rules, use the report_voltage_area_rules command. To remove voltage area rules, use the remove_voltage_area_rules command."}
{"header": "Enabling Advanced Legalization Algorithms", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To enable advanced legalization algorithms for 2D rule checking and cell interaction, which can reduce legalization runtime, set the place.legalize.enable_advanced_legalizer application option to true To specify additional advanced legalization rules that are not automatically detected, set the place.legalize.enable_advanced_legalizer_rules application option. When you enable the advanced legalization algorithms, by default, the tool aligns vertical pin shapes during pin access optimization to improve routability. However, you can specify additional strategies for pin access optimization by setting the place.legalize.optimize_pin_access_strategies application option as shown in the following table. Table 12 Settings for the place.legalize.optimize_pin_access_strategies Application Option To do this Use this setting Align horizontal pin shapes horizontal_align Move cells away from areas of high pin density avoid_high_pin_density Align horizontal pin shapes and move cells away from areas of high pin density horizontal_align avoid_high_pin_density During advanced legalization and legality checking, the tool can simultaneously check for DRC violations between multiple cells and PG net shapes. To enable this feature, set the place.legalize.enable_multi_cell_pnet_checks application option to true To enable multi cell checks at the last run of route_opt command or after the route_auto command, set the following application options to true . This helps to improve the runtime for QoR considerations. To enable the following application options, set the place.legalize.enable_multi_cell_pnet_checks application option to true place.legalize.enable_multi_cell_access_check : considers impact on a cell's pin access due to presence of abutting neighbor cells and any prerouted net PG net shapes in the vicinity. Default is false place.legalize.enable_multi_cell_track_capacity_check : analyzes the track capacity of the cell's pins and abutting neighbor cells. Track capacity estimates the sufficiency of routing tracks in the area to access all the specified pins. To enable this application option, set the place.legalize.enable_multi_cell_access_check application option to true . Default is false Fusion Compiler User Guide 164 Chapter 2: Preparing the Design Specifying Legalization Settings Feedback To enable multithreaded advanced legalization, perform the following steps: 1. Enable multithreaded advanced legalization algorithms by setting the place.legalize.enable_threaded_advanced_legalizer application option to true 2. Configure for multithreading as described in Configuring Multithreading To perform multithreaded advanced legality checking, 1. Enable advanced legalization algorithms by setting the place.legalize.enable_advanced_legalizer application option to true 2. Configure for multithreading as described in Configuring Multithreading 3. Perform legality checking using the check_legality command."}
{"header": "Place and Route Design Flow Overview", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "Figure 2 shows the basic place and route design flow using the Fusion Compiler tool. Fusion Compiler User Guide 35 Chapter 1: Working With the Fusion Compiler Tool Place and Route Design Flow Overview Feedback Figure 2 Fusion Compiler Place and Route Flow To run the Fusion Compiler place and route flow, 1. Set up the library data, preparingtiming librarieslogic libraries libraries and prepare the design data, as described in Preparing the Design 2. Perform design planning and power planning. When you perform design planning and power planning, you create a floorplan to determine the size of the design, create the boundary and core area, create site rows for the placement of standard cells, set up the I/O pads, and create a power plan. For more information about design planning and power planning, see the Fusion Compiler Design Planning User Guide 3. Perform placement and optimization. To perform placement and optimization, use the place_opt command. The place_opt command placement and optimization addresses and resolves timing closure for your design. This iterative process uses enhanced placement and synthesis technologies to generate Fusion Compiler User Guide 36 Chapter 1: Working With the Fusion Compiler Tool Fusion Compiler Concepts Feedback legalized placement for leaf cells and an optimized design. You can supplement this functionality by optimizing for power, recovering area for placement, minimizing congestion, and minimizing timing and design rule violations. 4. Perform clock tree synthesis and optimization. To perform clock tree synthesis and optimization, use the clock_opt command. Fusion Compiler clock tree synthesis and embedded optimization solve complicated clock tree synthesis problems, such as blockage avoidance and the correlation between preroute and postroute data. Clock tree optimization improves both clock skew and clock insertion delay by performing buffer sizing, buffer relocation, gate sizing, gate relocation, level adjustment, reconfiguration, delay insertion, dummy load insertion, and balancing of interclock delays. For more information about clock tree synthesis and optimization, see Clock Tree Synthesis 5. Perform routing and postroute optimization, as described in Routing and Postroute Optimization The Fusion Compiler tool uses Zroute to perform global routing, track assignment, detail routing, topological optimization, and engineering change order (ECO) routing. To perform postroute optimization, use the route_opt command. For most designs, the default postroute optimization setup produces optimal results. If necessary, you can supplement this functionality by optimizing routing patterns and reducing crosstalk or by customizing the routing and postroute optimization functions for special needs. 6. Perform chip finishing and design for manufacturing tasks, as described in Chip Finishing and Design for Manufacturing The Fusion Compiler tool provides chip finishing and design for manufacturing and design for yield capabilities that you can apply throughout the various stages of the design flow to address process design issues encountered during chip manufacturing. 7. Save the design."}
{"header": "Querying Routing Blockages", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To find routing blockages, use the get_routing_blockages command. For example, to get all the routing blockages in a block, use the following command: fc_shell> get_routing_blockages * To find the routing blockages for specific nets, use the -of_objects option to specify the nets of interest. For example, to find the routing blockages for the n1 net, use the following command: fc_shell> get_routing_blockages -of_objects [get_nets n1] To find the routing blockages in a specific location, use the get_objects_by_location -classes routing_blockage command."}
{"header": "Physical Synthesis Design Flow Overview", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "Figure 1 shows the basic physical synthesis design flow. Fusion Compiler User Guide 33 Chapter 1: Working With the Fusion Compiler Tool Formal Verification Feedback Figure 1 Fusion Compiler Physical Synthesis Flow RTL/ netlist Design (NDM) Ref. lib (NDM) Tech. data TLU+ files UPF files DEF/Tcl (Optional) SDC files (Optional) Set up the libraries Read RTL files Handle design mismatches and black boxes Apply multivoltage power intent Apply timing and physical constraints Set up clock-gating cells Set up DFT and insert DFT structures Insert multivoltage cells Compile the design Analyze and report QoR Export the design SDC files Design (NDM) Verilog UPF files DEF/ SCANDEF"}
{"header": "Reading Mixed Gate-Level Netlists and RTL Files", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can read a combination of Verilog netlists and RTL files. Use the read_verilog command to read the Verilog netlists. Use the analyze and elaborate commands to read the RTL files. After all the netlist files and RTL files have been read into the tool, use the set_top_module command to link the designs to create the block for synthesis. The following example shows how you can read a mix of netlist and RTL files. As shown in this example, when you elaborate the top-level module with parameters, the top- level module name also contains the parameterized module name. You can control the naming style for parameterized modules using the following application options: hdlin.naming.template_naming_style hdlin.naming.template_parameter_style and hdlin.naming.template_separator_style # Read netlist files read_verilog NETLIST/bot.v # Analyze design files analyze -format sverilog -hdl_library MID RTL/mid.sv analyze -format sverilog RTL/top.svd # Elaborate top design module elaborate -parameters \"N=8,M=3\" top # Set the top level module to resolve references set_top_module top_N8_M3"}
{"header": "Improving the Correlation Between the SMSCTS and CCD", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To improve the correlation between the structural multisource clock tree synthesis (SMSCTS) and concurrent clock and data (CCD), the Fusion Compiler tool supports the enhanced CCD engine with more SMSCTS specific offsets. This improves the CCD balance point implementation and timing after the SMSCTS step in the clock_opt command. To enable the improved correlation between the SMSCTS and CCD in the compile_fusion command and build_clock stage of the clock_opt command, set the cts.multisource.enable_subtree_synthesis_aware_ccd application option to true The improved correlation between the SMSCTS and CCD: Improves the overall latency implementation after SMSCTS in the clock_opt command. Reduces long and short path violations. Improves timing after the clock_opt command with CCD offsets. Fusion Compiler User Guide 409 Chapter 5: Clock Tree Synthesis Implementing Multisource Clock Trees Feedback"}
{"header": "Defining Ignore Pins", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To define one or more pins as ignore pins, use the following syntax: set_clock_balance_points [-clock clock -consider_for_balancing false -balance_points pins The -clock option is not required. If you do not use it, all user-defined ignore pins apply to all clocks. Fusion Compiler User Guide 346 Chapter 5: Clock Tree Synthesis Defining the Clock Trees Feedback For the CLK clock tree shown in Figure 74 , assume that you want to ignore all branches of the clock tree beyond the U2 cell. To do so, you would use the following command: fc_shell> set_clock_balance_points -clock [get_clocks CLK] \\ -consider_for_balancing false -balance_points [get_pins U2/A] Figure 74 User-Defined Ignore Pin CLK U2 To report the user-defined ignore pins, use the remove_clock_tre_exceptions comand-stop_pinscomandsremove_clock_tre_exceptions-stop_pins report_clock_balance_points command. This command reports both the user-defined sink pins and the user-defined ignore pins. During clock tree synthesis, the tool adds guide buffers and isolates ignore pins from the rest of the clock network. During subsequent data path optimization, the tool fixes any existing DRC violations beyond the guide buffers. To remove the ignore pin definition from a pin, use the remove_clock_tre_exceptions comand-stop_pinscomandsremove_clock_tre_exceptions-stop_pins remove_clock_balance_points command. For example, to remove the ignore pin definition from pin U2/CLK for the CLK clock, use the following command: fc_shell> remove_clock_balance_points -clock [get_clocks CLK] \\ -balance_points [get_pins U2/CLK]"}
{"header": "Performing Prechecks for Hierarchical Synthesis Flows", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "To check the readiness for the hierarchical synthesis flow, use the following commands: check_design -checks block_ready_for_top Run this command after block synthesis to check whether the synthesized block is ready for the top-level synthesis. check_design -checks hier_pre_compile Run this command before top-level synthesis to check whether the subblocks and top- level design are ready for the hierarchical flow."}
{"header": "Setting Options for Signoff Design Rule Checking", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Before you run the signoff_check_drc command, configure the run by setting the application options shown in Table 43 . To set the application options, use the set_app_options command. To see the current settings, use the report_app_options command. Table 43 Application Options for Signoff Design Rule Checking Application option Default Description signoff.check_drc.runset (required) N/A Specifies the foundry runset to use for design rule checking. signoff.check_drc. auto_eco_threshold_value 20 Specifies the maximum percentage of change to the block to perform incremental design rule checking using the -auto_eco true option. signoff.check_drc. excluded_cell_types {} Specifies the cell types to exclude from checking. You can specify one or more of the following values: lib_cell (standard cells), macro (macro cells), pad (I/O pad cells), and filler (filler cells). signoff.check_drc. fill_view_data read_if_uptodate Controls whether the IC Validator tool reads the fill data. By default, it reads the fill data only if its timestamp is newer than the timestamp of the design view. To read the fill data regardless of its timestamp, set this application option to ( read ). To never read the fill data, set this application option to discard signoff.check_drc. ignore_blockages_in_cells true Controls whether the IC Validator tool reads only the pin information from the frame view true ) or both the blockages and the pin information ( false ). signoff.check_drc. ignore_child_cell_errors false Controls whether the IC Validator tool reports both top-level and child-level errors to the error data file ( false ) or only top-level errors ( true ). signoff.check_drc. max_errors_per_rule 1000 Specifies the maximum number of errors to report per rule. signoff.check_drc. read_design_views {} Specifies the reference cells for which the IC Validator tool reads the design view instead of the frame view. Using the design view can expose problems that are masked by the frame view abstraction. Fusion Compiler User Guide 667 Chapter 8: IC Validator In-Design Performing Signoff Design Rule Checking Feedback Table 43 Application Options for Signoff Design Rule Checking (Continued) Application option Default Description signoff.check_drc. read_layout_views {} Specifies the reference cells for which the IC Validator tool reads the layout view instead of the frame view. Using the layout view can expose problems that are masked by the frame view abstraction. signoff.check_drc. run_dir signoff_check_drc_run Specifies the run directory, which contains the files generated by the signoff_check_drc command. You can specify either a relative path, in which case the directory is created under the current working directory, or an absolute path. signoff.check_drc. user_defined_options (none) Specifies additional options for the IC Validator command line. The string that you specify in this option is added to the command line used to invoke the IC Validator tool. The Fusion Compiler tool does not perform any checking on the specified string. signoff.physical. layer_map_file (none) Specifies the name of the layer mapping file. If the technology file and the foundry runset file used by the IC Validator tool do not use the same layer numbers, you must supply a layer mapping file to map the technology layers to the layers used in the runset file. For details about the format of the layer mapping file, see Defining the Layer Mapping for IC Validator In-Design Commands signoff.physical. merge_exclude_libraries (none) Specifies the cell libraries whose cells are excluded from replacement with the cell data in the stream files specified in the signoff.physical. merge_stream_files application option. signoff.physical. merge_stream_files (none) Specifies the stream (GDSII or OASIS) files to merge into the current block for signoff design rule checking. When you use this option, the GDSII or OASIS data replaces the cell library data for the cells defined in the specified stream files. Fusion Compiler User Guide 668 Chapter 8: IC Validator In-Design Performing Signoff Design Rule Checking Feedback"}
{"header": "Saving Route Information", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "To save the route information, use the write_routes command. This command generates a Tcl script that reproduces the metal shapes and vias for a block, including their attribute settings. Note that the write_routes command reproduces routes, but not routing blockages. To generate a Tcl script that reproduces routing blockages, use the write_floorplan command."}
{"header": "Controlling Concurrent Clock and Data Optimization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Applying useful skew techniques during datapath optimization to improve the timing QoR by taking advantage of the positive slack and adjusting the clock arrival times of registers is referred to as concurrent clock and data (CCD) optimization. Concurrent clock and data optimization is enabled by default for the compile_fusion and clock_opt commands. To enabled it for the route_opt command, set the route_opt.flow.enable_ccd application option to true You can change the default behavior of concurrent clock and data optimization by Limiting the Latency Adjustment Values Excluding Boundary Paths Excluding Specific Path Groups Excluding Specific Scenarios Excluding Specific Sinks Controlling Timing Optimization Effort Controlling Hold Time Optimization Effort Controlling the Adjustment of I/O Clock Latencies Performing Dynamic-Voltage-Drop-Driven Concurrent Clock and Data Optimization During the route_opt Command Specifying Optimization Targets at the Preroute Stage Specifying Optimization Targets at the Postroute Stage Enabling Buffer Removal at the Postroute Stage Reporting Concurrent Clock and Data Timing Scaling CCD Offsets to New Scenarios for Reporting Timing Skewing Latch and Discrete Clock Gates Fusion Compiler User Guide 376 Chapter 5: Clock Tree Synthesis Implementing Clock Trees and Performing Post-CTS Optimization Feedback"}
{"header": "Displaying ECO Shapes in the GUI", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "When you use the RedHawk mesh add command to add virtual PG meshes in the top block for the current subblock, by default the virtual PG meshes created by the RedHawk mesh add command are not shown as layout objects in the GUI. Therefore, these GUI shapes cannot be queried using layout object collection commands (such as, get_shapes ), and are not saved to the design library when you save the block. To save ECO shapes along with rail results and display them in the GUI, enable the rail.display_eco_shapes application option, like set_app_options -name rail.display_eco_shapes -value true Note: The mesh add command is available only in RedHawk, not in RedHawk SC. Therefore, the tool issues an error message when you enable both the rail.enable_redhawk_sc and rail.display_eco_shapes application options. To display ECO shapes in GUI, you must first enable the RedHawk signoff license key by setting the rail.allow_redhawk_license_checkout application option to true . Otherwise, an error message is issued. To add virtual PG meshes and display the created ECO shapes in the GUI, 1. Prepare a script file (such as, mesh.tcl) that contains the mesh add command. 2. Run design setup with the mesh.tcl script file. fc_shell> set_rail_command_options -script_file mesh.tcl \\ -command setup_design -order after_the_command The tool generates the RedHawk script file and sources the mesh.tcl file after design setup. 3. Perform rail analysis using the following command: fc_shell> analyze_rail -nets -voltage_drop 4. Run the open_rail_result command to load the design data and analysis results. 5. Run the gui_start command to open the Fusion Compiler GUI. In the GUI layout window, choose View > Map and select the map to display. You can now display and query the ECO shapes that are created by the RedHawk mesh add command in the GUI. Script Examples Fusion Compiler User Guide 938 Chapter 12: RedHawk and RedHawk-SC Fusion Voltage Hotspot Analysis Feedback The following script displays ECO shapes in the GUI by using the set_rail_command_option command. ## Open design ## open_block link_block ## Specify taps ## create_taps ## Specify RedHawk Fusion input files or variables ## set_app_options -name rail.enable_redhawk -value 1 set_app_options -name rail.redhawk_path -value set_app_options -name rail.disable_timestamps -value true set_app_options -name rail.display_eco_shapes -value true set_rail_command_options -script_file mesh.tcl -command \\ setup_design ... ## Analyze## analyze_rail -voltage_drop ... -nets {VDD VSS} ## Check GUI ## open_rail_result The following script displays ECO shapes in the GUI by using a RedHawk script. ## Open design ## open_block link_block ## Specify taps ## create_taps ## Specify RedHawk Fusion input files or variables ## set_app_options -name rail.enable_redhawk -value 1 set_app_options -name rail.redhawk_path -value set_app_options -name rail.disable_timestamps -value true set_app_options -name rail.display_eco_shapes -value true ## Analyze ## analyze_rail -voltage_drop ... -nets {VDD VSS} -script_only ## Modify the script.tcl containing mesh add command ## analyze_rail -redhawk_script_file ## Check GUI ## open_rail_result"}
{"header": "Using Hierarchical Relative Placement for Straddling", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "A cell can occupy multiple column positions or multiple row positions, which is known as straddling. For more information about leaf cell straddling, see Adding Leaf Cells Figure 169 shows a relative placement group in which cells straddle columns (instance U2) and rows (instance U7). Figure 169 Hierarchical Relative Placement Group With Straddling U3 U4 U6 U1 U2 U7 Fusion Compiler User Guide 788 Chapter 10: Physical Datapath With Relative Placement Adding Objects to a Group Feedback Figure 170 shows the process of using hierarchical relative placement to build this structure. First, define relative placement groups that contain the leaf cells: rp1 contains U1 and U4, rp2 contains U2, and rp3 contains U3 and U6. Then define a group (rp4) that contains these groups. Finally, define a group (rp5) that contains the hierarchical group rp4 and the leaf cell U7. The resulting group includes both the column and the row straddle. Example 44 shows the commands used in this process. Figure 170 Straddling With Hierarchical Relative Placement rp3 rp2 rp1 U3 U2 U4 U7 U6 U1 rp4 U4 U1 U2 U3 U6 rp1 rp2 rp3 rp5 U4 U1 U2 U3 U6 col 0 col 1 row 0 col 0 col 1 col 0 col 1 row 0 row 0 row 2 row 1 row 0 col 0 row 2 row 1 row 0 col 0 col 1 U7 col 1 row 2 row 1 row 0 rp4 Example 44 Straddling With Hierarchical Relative Placement create_rp_group -name rp1 -columns 2 -rows 1 add_to_rp_group rp1 -cells U1 -column 0 -row 0 add_to_rp_group rp1 -cells U4 -column 1 -row 0 create_rp_group -name rp2 -columns 1 -rows 1 add_to_rp_group rp2 -cells U2 -column 0 -row 0 create_rp_group -name rp3 -columns 2 -rows 1 add_to_rp_group rp3 -cells U3 -column 0 -row 0 add_to_rp_group rp3 -cells U6 -column 1 -row 0 create_rp_group -name rp4 -columns 1 -rows 3 add_to_rp_group rp4 -rp_group rp1 -column 0 -row 0 add_to_rp_group rp4 -rp_group rp2 -column 0 -row 1 add_to_rp_group rp4 -rp_group rp3 -column 0 -row 2 create_rp_group -name rp5 -columns 2 -rows 1 Fusion Compiler User Guide 789 Chapter 10: Physical Datapath With Relative Placement Adding Objects to a Group Feedback add_to_rp_group rp5 -rp_group rp4 -column 0 -row 0 add_to_rp_group rp5 -cells U7 -column 1 -row 0"}
{"header": "Inserting Dense Tap Arrays", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "dense tap array is a tap cell array whose tap distance is smaller than the tap distance used by the create_tap_cells command. To insert a dense tap array, use the create_dense_tap_cells command. You must specify the following information: The tap cell used in the tap wall (the -lib_cell option) You must specify the same tap cell as when you ran the create_tap_cells command. By default, the tool uses the following naming convention for inserted tap cells: tapfiller! library_cell_name number Use the -separator option to change the separator character from its default of \"!.\" To identify the tap cells inserted in a specific run, use the -prefix option to specify a prefix string. When you use this option, the tool uses the following naming convention: tapfiller! prefix library_cell_name number The tap distance (the -distance option) The specified distance must be smaller than the tap distance used by the create_tap_cells command. The tap insertion region (the -bbox option) You specify the tap insertion region by specifying the lower-left and upper-right corners of its bounding box: -bbox {{ llx lly } { urx ury }} The create_dense_tap_cells command first removes the existing tap cells that are completely within the tap insertion region, and then reinserts the tap cells with the specified tap distance to create a denser array in the specified region. To avoid tap rule violations, specify the same tap cell insertion pattern as was used by the create_tap_cells command. The create_dense_tap_cells command supports the following options to control the tap cell insertion: -offset -pattern -skip_fixed_cells , and -at_distance_only . For details about these options, see the man page. After insertion, the command fixes the placement of the inserted tap cells. Fusion Compiler User Guide 592 Chapter 7: Chip Finishing and Design for Manufacturing Performing Boundary Cell Insertion Feedback"}
{"header": "Setting Up for Self-Gating", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To set up the block for self-gating, perform the following steps before you run the compile_fusion command: 1. Enable self-gating by setting the compile.clockgate.self_gating application option to true fc_shell> set_app_options -name compile.clockgate.self_gating \\ -value true 2. Apply switching activity by using the read_saif or set_switching_activity command. 3. (Optional) Specify self-gating settings using the set_self_gating_options command. For more information, see Setting Self-Gating Options 4. (Optional) Override the tool's default behavior of selecting self-gating objects by using the set_self_gating_objects command. For more information, see Controlling the Selection of Self-Gating Objects"}
{"header": "Displaying the PG Electromigration Map", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "A PG electromigration map is a visual display of the color-coded electromigration values overlaid on the physical supply nets. For static analysis, the map displays average electromigration values. For dynamic analysis, the map displays average electromigration values, peak electromigration values, or root mean square electromigration values. Figure 204 shows an example of the electromigration map in which problem areas are highlighted in different colors. Use the options to investigate the problem areas by Fusion Compiler User Guide 904 Chapter 12: RedHawk and RedHawk-SC Fusion Performing PG Electromigration Analysis Feedback selecting layers or nets to display. For example, to examine the current value of one specific net, deselect all the nets and then select the net to display from the list. To analyze only the shapes on a layer, select the layer from the list. For a detailed procedure about how to display an electromigration map, see Displaying Maps in the GUI Figure 204 Displaying a PG Electromigration Map"}
{"header": "Checking Missing Vias and Unconnected Pins", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Use the analyze_rail -check_missing_via command to check for missing vias and unconnected pins in the block based on the settings specified by the set_missing_via_check_options command. Use the -voltage_drop option if you want to run missing via and unconnected pin checks together with voltage drop analysis. The tool then reports all missing vias found in the geometry with voltage values in the missing via report. To set a voltage threshold across layers for filtering the report, use the -threshold option of the set_missing_via_check_options command. You can set multiple threshold values in a missing via check. Fusion Compiler User Guide 892 Chapter 12: RedHawk and RedHawk-SC Fusion Missing Via and Unconnected Pin Checking Feedback Note: In the RedHawk-SC Fusion flow, you must specify the -check_missing_via option together with the -voltage_drop option. In cases you want to report missing vias with and without setting a voltage threshold in one analyze_rail run, first set the desired threshold value (for example, 0.001) and then reset the value to -1. Setting -threshold option to -1 disables voltage checking. When the missing via check is completed, open the generated error data to examine the errors in the error browser. For details, see Viewing Error Data Example 48 fc_shell> set_missing_via_check_options -exclude_stack_via \\ -threshold 0.0001 fc_shell> analyze_rail -voltage_drop static -check_missing_via \\ -nets {VDD VSS} The above example sets the threshold value to 0.0001 and compares voltages across two ends of a via, excluding stack vias. It then runs the missing via check during static rail analysis. The RedHawk script file includes the following commands: perform extraction -power -ground perform analysis -static mesh vias -report_missing -exclude_stack_via -threshold 0.0001 \\ -o apache.missingVias1 Example 49 fc_shell> set_missing_via_check_options -exclude_stack_via \\ -threshold -1 fc_shell> analyze_rail -voltage_drop -check_missing_via \\ -nets {VDD VSS} The above example sets the threshold value to -1 to disable the voltage checking, and runs the missing via check. The RedHawk script file includes the following commands: perform extraction -power -ground mesh vias -report_missing -exclude_stack_via -threshold -1 \\ -o apache.missingVias1.nothreshold Example 50 fc_shell> set_missing_via_check_options -exclude_stack_via \\ -threshold 0.001 fc_shell> set_missing_via_check_options -exclude_stack_via \\ -threshold 0.002 fc_shell> set_missing_via_check_options -exclude_stack_via \\ Fusion Compiler User Guide 893 Chapter 12: RedHawk and RedHawk-SC Fusion Missing Via and Unconnected Pin Checking Feedback -threshold -1 fc_shell> analyze_rail -voltage_drop static -check_missing_via \\ -nets {VDD VSS} fc_shell> report_rail_result -type missing_vias -supply_nets \\ {VDD VSS} rpt.missing_vias Information: writing rpt.missing_vias.no_threshold done Information: writing rpt.missing_vias done In the above example, three different threshold values are set for a missing via check. The tool generates two missing via reports: rpt.missing_vias.no_threshold includes all missing vias found in the geometry, while rpt.missing_vias includes the vias whose voltage difference across two ends is less than 0.001 and 0.002."}
{"header": "Specifying Clock Gating Constraints", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, the tool identifies preexisting clock-gating cells during the execution of the analyze and elaborate commands. During compile, the tool inserts one more level of clock-gating cells at the leaf level and implements clock-gating logic using the default Fusion Compiler User Guide 135 Chapter 2: Preparing the Design Specifying Clock Gating Constraints Feedback clock-gating settings if you do not specify any clock-gating constraints. You cannot disable clock gating. Before you set up clock-gating constraints, load your design and libraries in memory and then use the following commands to set up the constraints: The set_clock_gate_style command To select the type of integrated clock-gating cell, specify the following options: Option Description -test_point Specifies the test control position with respect the to integrated clock-gating cell. The valid values are none before , and after -observation_output Specifies the observation output pin. -target Specifies the target sequential elements to be clock-gated. The valid values are pos_edge_flip_flop and neg_edge_flip_flop -objects Specifies the objects to which the clock gate applies. The set_clock_gating_options command To define the netlist structure of the inserted clock-gating cells, specify the following options: Option Description minimum_bitwidth Specifies the minimum number of bits to gate together. The default is three. max_fanout Specifies the maximum number of cells gated by the same clock-gating cell. The default is infinite. The set_clock_gating_objects command To control clock gating for specified objects and override the default clock-gating behavior that is set during compile, specify the following options. An object can be a hierarchical cell, register, power domain, or module. Option Description -include Specifies a list of objects to gate as per the clock-gating style and clock-gating options. -exclude Specifies a list of objects to exclude from clock gating. Fusion Compiler User Guide 136 Chapter 2: Preparing the Design Specifying Physical Constraints for Placement and Legalization Feedback Option Description -clear Specifies to remove all clock-gating inclusion or exclusion for the specified list of objects. -reset Specifies to remove all criteria previously set by the set_clock_gating_objects command. The default During clock-gating optimization, the tool uses the following setup defaults: Setup Default Maximum fanout Infinite Minimum bit-width Three Clock-gating cell Latch-based cells for both positive-edge and negative-edge triggered flip-flops. If only one type of cell is available, the tool inserts inverters on both sides of the clock-gating cell. For more information, see Setting Up Clock Gating"}
{"header": "Analyzing Signal Electromigration", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The comandsreport_signal_emreport_signal_em comand report_signal_em command performs signal electromigration analysis for each net by calculating the current on every edge and comparing this data with the constraints set by the read_signal_em_constraints command. For example, fc_shell> report_signal_em -violated -verbose Fusion Compiler User Guide 555 Chapter 6: Routing and Postroute Optimization Analyzing and Fixing Signal Electromigration Violations Feedback The report_signal_em command performs a timing update, if needed, and analyzes all nets for electromigration. The -verbose option causes the report to show detailed electromigration analysis information, which usually produces a very large report when used by itself. To get a report with a reasonable size, use the -violated option as well, which limits the report to only the nets with electromigration violations. To limit the analysis to specific nets, use the -nets option. set_em_options comandcomandset_em_options You can specify settings for electromigration analysis by setting the application options shown in the following table. Table 34 Application Options for Signal Electromigration Analysis Application option Default Description em.net_delta_temperature 5.0 Specifies the delta temperature used for RMS limit lookup. em.net_duration_condition_for_peak 0.0 Specifies the duration value for peak current checking. em.net_global_rms_relaxation_factor 1.0 Specifies the global relaxation factor for the RMS limit specified in the constraints file. em.net_metal_line_number Specifies the metal line number used to look up the relaxation factor in the RMS constraint factor table provided in the constraints file. em.net_min_duty_ratio Specifies the minimum duty ratio for computing the peak current. em.net_use_waveform_duration false When false , the command uses current integral based duration. When true , the command uses current waveform based duration. em.net_violation_rule_types \"\" Specifies the type of constraint rules to use. When you perform signal electromigration analysis, the tool computes three current values: Average Root mean square Peak The default report generated by the report_signal_em command lists the number of nets with electromigration violations and the types of constraints violated (mean, absolute Fusion Compiler User Guide 556 Chapter 6: Routing and Postroute Optimization Analyzing and Fixing Signal Electromigration Violations Feedback average, RMS, or peak). If you use the -verbose option, the report displays detailed information about the violations, as shown in Example 25 Example 25 Verbose Electromigration Report fc_shell> report_signal_em -violated -verbose ... Net Name: clks/trimch_macroout_cb_group_gpaf0lts1_gpu_c_0_s_0[3] Violations: RMS PEAK Flag Segment Layer BBox Coordinates Width/Cut Required AVERAGE RMS PEAK -------------------------------------------------------------------------------------- v PATH_36_392230 M6D (1450.000, 995.612 -> 1452.715, 995.652) 0.040 0.085 1.514e-02 (-) 9.650e-01 (5.231e-01) 1.365e+00 (1.349e+00) VIA_S_11051278 V5D (1449.969, 995.582 -> 1450.071, 995.682) 1 - 1.465e-02 (-) 7.380e-01 (-) 1.044e+00 (-) v PATH_35_765189 M5A (1450.001, 994.973 -> 1450.039, 995.651) 0.038 0.047 1.417e-02 (-) 6.088e-01 (4.981e-01) 8.609e-01 (1.274e+00) VIA_S_11051279 V5D (1449.969, 994.942 -> 1450.071, 995.042) 1 - 1.369e-02 (-) 5.249e-01 (-) 7.423e-01 (-) PATH_36_392231 M6D (1407.370, 994.972 -> 1450.040, 995.012) 0.040 - 1.311e-02 (-) 2.047e-01 (5.231e-01) 2.894e-01 (9.443e-01) VIA_S_11051280 V5D (1407.339, 994.942 -> 1407.441, 995.042) 1 - 1.252e-02 (-) 1.926e-01 (-) 2.723e-01 (-) ... The report shows the segment name (Segment column), layer name (Layer column), location coordinates (Bbox Coordinates column), metal width or via cut number (Width/Cut column), the constraint value (Required column), the average, RMS, and peak current in mA for the wire segment or via at that location. The letter \"v\" in the Flag column indicates a violation at that location. A hyphen in the Required column means that there is no electromigration constraint for that metal or via layer. In the AVERAGE, RMS, and PEAK columns, the first value is the calculated value and the value in parenthesis is the limit imposed by the electromigration constraints, where a hyphen indicates that there is no electromigration constraint."}
{"header": "Restricting Optimization on the Clock Network", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can restrict the optimization on portions of the clock network by specifying Don't touch settings These settings identify parts of the clock tree on which clock tree synthesis and optimization is not performed. You can use don't touch settings to prevent the modification of a clock network beyond a specific pin, the buffering of specific nets, or the sizing of specific cells. For information about defining don't touch settings, see Setting Don't Touch Settings Size-only settings These settings identify clock tree cells for which the tool can perform only cell sizing. Note that these cells can be moved, unless they have a placement status of fixed. For information about defining size-only settings, see Setting Size-Only Settings"}
{"header": "Preserving Ports of Existing Hierarchies", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "During optimization and clock tree synthesis, the tool can create new ports on existing hierarchical blocks. To prevent the tool from doing so, use the set_freeze_ports command and set the freeze_clock_port attribute to true on the corresponding cell instance. You can prevent the tool from adding clock ports, data ports, or both by using the -clock -data , or -all option. For example, to prevent the tool from creating additional clock ports on the MBX22 cell instance, use the following command: fc_shell> set_freeze_ports -clock [get_cells MBX22] true To report the freeze-port settings, use the report_freeze_ports command."}
{"header": "Performing Design Rule Checking Using Zroute", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To use Zroute to check the routing design rules defined in the technology file, run the check_routes command. By default, the check_routes command checks for routing DRC violations, unconnected nets, antenna rule violations, and voltage area violations on all routed signal nets in the block, except those marked as user nets, frozen nets, and PG nets. To verify the routing only for specific nets, specify the nets by using the -nets option. To check user routes, set the -check_from_user_shapes option to true To check frozen routes, set the -check_from_frozen_shapes option to true A net is considered frozen when its physical_status attribute is set to locked Fusion Compiler User Guide 569 Chapter 6: Routing and Postroute Optimization Analyzing the Routing Results Feedback To disable checks for routing DRC violations, set the -drc option to false . To disable checks for unconnected nets, set the -open_net option to false . To disable checks for antenna rule violations, set the -antenna option to false . To disable checks for voltage area violations, set the -voltage_area option to false To save time, you can restrict the routing verification to specific regions of the block by using the -coordinates option to specify the lower-left and upper-right coordinates for each rectangular region. When you perform area-based DRC, the check_routes command checks only for DRC violations and voltage area violations. It does not check for unconnected nets, antenna violations, or tie-to-rail violations, as these are net-based violations. Note: The -coordinates option and the -nets option are mutually exclusive; you can use only one of these options. The check_routes command reports the following DRC violations: Spacing violations Different-net wire spacing Different-net nondefault wire spacing (note that the DRC report refers to nondefault routing rules as variable rules) Different-net via-cut spacing Different-net nondefault via-cut spacing (note that the DRC report refers to nondefault routing rules as variable rules) Different-net fat extension spacing Dog bone spacing End-of-line spacing Enclosed via spacing Same-net spacing Same-net via-cut spacing Same-net fat extension spacing Special notch spacing U-shape spacing Via-cut to metal spacing Soft spacing Fusion Compiler User Guide 570 Chapter 6: Routing and Postroute Optimization Analyzing the Routing Results Feedback Area violations Less than minimum area Less than minimum enclosed area Fat wire via keepout area Jog wire via keepout area Length and width violations Less than minimum width Less than minimum length Less than minimum edge length Protrusion length Contact violations Needs fat contact Needs poly contact Needs fat contact on extension Over maximum stack level Enclosure violations End-of-line wire via enclosure Jog wire via enclosure T-shape wire via enclosure Others Open nets, except when doing area-based DRC By default, the check_routes command reports a maximum of 200 open nets. To report all open nets, use the -report_all_open_nets true option (or select \"Report all open nets\" in the GUI). Antenna violations, except when doing area-based DRC Nets crossing the top-cell boundary Frozen layers Minimum layer Fusion Compiler User Guide 571 Chapter 6: Routing and Postroute Optimization Analyzing the Routing Results Feedback Maximum layer Voltage area violations Note: These violations are also reported after each detail route iteration. The check_routes command saves the error data to a file named zroute.err. You cannot control the naming of the error data file generated by the check_routes command, but you can rename the error data file after running the command. To rename the error data file, use the following commands: fc_shell> write_drc_error_data -error_data zroute.err \\ -file_name export.err fc_shell> open_drc_error_data -file_name export.err fc_shell> attach_drc_error_data [get_drc_error_data export.err] \\ -name newname .err After you run the check_routes command, you can use the DRC query commands to get more information about the violations or use the error browser to examine the violations in the GUI. For information about analyzing the DRC violations, see Using the DRC Query Commands . For information about using the error browser, see the Fusion Compiler Graphical User Interface User Guide After running check_routes , you can use the following command to run incremental detail routing that uses the check_routes results as input: fc_shell> route_detail -incremental true \\ -initial_drc_from_input true Note: Incremental detail routing does not fix open nets. To fix open nets, you must run ECO routing. For information about ECO routing, see Performing ECO Routing"}
{"header": "Running Concurrent Clock and Data Optimization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Changing clock latencies can balance the slack in successive timing path stages to optimize clock and data paths. This capability is called concurrent clock and data (CCD) optimization, which can reduce total negative slacks (TNS), worst negative slacks (WNS), area, and leakage power. In addition, it can improve correlation between physical synthesis and place-and-route."}
{"header": "Using Incomplete UPF Information", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The Early Data Check Manager allows you to check designs for power and multivoltage issues early in the design cycle. You can configure different error conditions in different ways. The tool provides comprehensive reports about the data checks. The general flow is as follows: 1. Use the set_early_data_check_policy command to define the global violation handling policy for data checks. 2. Proceed with your tool flow. The tool detects and responds to violations throughout the flow. 3. Use the report_early_data_checks command to obtain a report about all violations or specific data checks. 4. Use the get_early_data_check_records command to get a Tcl collection of violations that can be used in other commands. 5. Use the write_early_data_check_config command to save the settings in a file for future use. 6. Use the remove_early_data_check_records command to clear the data in preparation for another iteration. For more information about the Early Data Check Manager, see the Fusion Compiler Data Model User Guide For a list of power and multivoltage data checks, see the Fusion Compiler Multivoltage User Guide Fusion Compiler User Guide 115 Chapter 2: Preparing the Design Setting Up Multivoltage Designs Feedback"}
{"header": "Optimizing Wire Length and Via Count", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "During detail routing, Zroute optimizes wire length and via count in the areas where DRC violations occur; however, it does not optimize the layout in areas where no DRC violations occur. To improve the manufacturing yield, use the optimize_routes command to perform standalone optimization of wire length and via count after performing detail routing and redundant via insertion. By default, Zroute selects the nets to reroute based on the overall cost. For each selected net, Zroute determines whether to reroute all the shapes in the net or just a portion of them. To select the nets to reroute, use the -nets option to specify the nets. When you specify the nets to optimize, you can also use the -reroute_all_shapes_in_nets option to control whether Zroute must reroute all the associated net shapes. By default, Zroute performs a maximum of 40 detail routing iterations to fix DRC violations that exist after the optimization. You can use the -max_detail_route_iterations option to control the maximum number of detail routing iterations."}
{"header": "Single-Loop Matching", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To create single-loops to extend wires for length matching, use the Custom Router single- loop matching application options. Single-loop matching is typically used in DDR routing flows Figure 164 Adding Single Loops to Extend Wires Application Option Description custom.route.single_loop_match Adds single loops to extend wire lengths. Fusion Compiler User Guide 771 Chapter 9: Routing Using Custom Router Using Custom Routing Application Options Feedback Application Option Description custom.route.single_loop_match_max_spacing Specifies the maximum spacing in the loop. custom.route.single_loop_match_min_spacing Specifies the minimum spacing in the loop. custom.route.single_loop_match_offset_layer Routes the segment at the top of the figure on a layer different from other segments in the loop."}
{"header": "Sorting and Filtering the Data", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can sort and filter the run data to reveal patterns in the results and determine the parameters you want to explore further. To sort and filter the data, see the following topics: Sorting the Data Filtering Metrics Filtering Runs Example Analysis See Also Exploring the Detailed Comparison Data Fusion Compiler User Guide 274 Chapter 3: Physical Synthesis Performing Design Analysis Feedback Sorting the Data Click any column header to sort the data using that metric. The first click performs an ascending sort, while the second click performs a descending sort. For example, to show the worst TNS numbers at the top of the table and the best TNS numbers at the bottom, click the TNS column header: Click the TNS column header again to show the best TNS numbers at the top and the worst at the bottom: Fusion Compiler User Guide 275 Chapter 3: Physical Synthesis Performing Design Analysis Feedback Filtering Metrics To control which metrics are displayed in the table, click the Metrics button and select or deselect the metrics from the Metrics dialog box accordingly. For example, to show only the setup timing, netlist area, and cell counts, select the metrics as shown in Figure 39 Figure 39 Metrics Dialog Box Filtering Runs To control which runs are displayed in the table, click the Runs button and select or deselect the exploration runs accordingly from the Visible Runs (Summary) column. For example, to display only the first four runs in a table, select the runs as shown in Figure 40 Figure 40 Choose Baseline and Visible Runs Dialog Box Fusion Compiler User Guide 276 Chapter 3: Physical Synthesis Performing Design Analysis Feedback Example Analysis The following example demonstrates how you might sort and filter your data to narrow down the runs you would like to explore further. Suppose you open the comparison report shown in Figure 41 and set the util60_aspect1%1_layerM9 run as the base run. Figure 41 Comparison Report You could look at your TNS numbers first and sort the data from best TNS to worst TNS, as shown in the following figure: Notice that the best TNS runs have the M9 top layer, and the worst have the M7 top layer. This suggests that restricting the metal layers significantly impacts timing. Fusion Compiler User Guide 277 Chapter 3: Physical Synthesis Performing Design Analysis Feedback You could then restrict your analysis to your M9 runs by turning off the visibility of your M7 runs, as shown in the following figure: Now that you have your best TNS runs, you could compare their congestion by sorting the GRCOverflow column to show the worst overflow at the top, as shown in the following figure: Notice that your higher-utilization runs have more congestion than your lower-utilization runs. You could restrict your analysis to your lower-utilization runs by turning off the Fusion Compiler User Guide 278 Chapter 3: Physical Synthesis Performing Design Analysis Feedback visibility of your higher-utilization runs as shown in Figure 42 , leaving you with a manageable subset of exploration runs that better meet your timing and congestion goals. Figure 42 Displaying Lower-Utilization Runs"}
{"header": "Analyzing Clock Timing", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The timing characteristics of the clock network are important in any high-performance design. To obtain detailed information about the clock networks in the current block, use the report_clock_timing comandcomandsreport_clock_timing report_clock_timing command. You must use the -type option to specify the type of report to generate. The report_clock_timing command can generate the following types of reports: Single-clock local skew To generate a single-clock local skew report, use the -type skew option. Interclock skew To generate an interclock skew report, use the -type interclock_skew option. Latency To generate a latency report, use the -type latency option. Fusion Compiler User Guide 436 Chapter 5: Clock Tree Synthesis Analyzing the Clock Tree Results Feedback Transition To generate a transition time report, use the -type transition option."}
{"header": "Related Products, Publications, and Trademarks", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "For additional information about the Fusion Compiler tool, see the documentation on the Synopsys SolvNetPlus support site at the following address: https://solvnetplus.synopsys.com You might also want to see the documentation for the following related Synopsys products: Design Compiler (R) IC Validator PrimeTime (R) Suite StarRC"}
{"header": "Signoff ECO Flow", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "After you perform place and route in the Fusion Compiler tool, if your design has timing or design rule violations, you can fix these violations in the PrimeTime tool. You can also perform power or area recovery in the PrimeTime tool. Fusion Compiler User Guide 950 Chapter 13: ECO Flow Signoff ECO Flow Feedback If you make changes to your design in the PrimeTime tool, you can generate an ECO change list file and incorporate those changes into the design by using the Fusion Compiler ECO capabilities, as shown in Figure 217 Figure 217 Signoff ECO Flow Fusion Compiler ECO Yes No StarRC parasitic extraction ECO change list file PrimeTime timing ECO Violations? PrimeTime timing and signal integrity analysis PrimeTime area and power recovery ECO change list file Fusion Compiler ECO To incorporate the PrimeTime ECO changes, use the following steps: 1. Update the design by sourcing the PrimeTime ECO change list file, which is a Tcl file containing netlist editing commands. 2. Update the placement by using the place_eco_cells command as shown in the following example: place_eco_cells -legalize_mode minimum_physical_impact \\ -eco_changed_cells -legalize_only -displacement_threshold 10 For more information about the place_eco_cells command, see Placing ECO Cells 3. Add filler cells to the empty spaces in the site array, as described in Inserting Filler Cells Fusion Compiler User Guide 951 Chapter 13: ECO Flow Incremental Signoff ECO Flow Feedback To reduce runtime, use the -post_eco option when you Insert metal filler cells with the create_stdcell_fillers command, and the tool marks the inserted filler cells as post ECO cells Remove filler cells with DRC violations with the remove_stdcell_fillers_with_violation command, and the tool performs DRC checking only for the post ECO cells 4. Update the routing by using the route_eco command, as described in Performing ECO Routing , or by manually rerouting the affected nets."}
{"header": "Legalizing Relative Placement Groups in a Placed Design", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can improve the placement of relative placement groups in a placed design by legalizing only the relative placement groups. To legalize the placement of only the relative placement groups, but not nonrelative placement cells, use the legalize_rp_groups command. You can also specify a list of relative placement groups to be legalized. To perform a fast legalization of the relative placement groups, use the -prototype option. When you use this option, the tool does not ensure that all legalization constraints are met. Therefore, use it during the prototyping stages of the design flow when you are developing relative placement groups. To specify that relative placement groups can overlap with each other, use the -legalize_over_rp option. For example, the following command legalizes the RP3 relative placement group over the RP1 and RP2 relative placement groups. fc_shell> legalize_rp_groups -legalize_over_rp RP3 Figure 186 shows the placement before and after running the command. Fusion Compiler User Guide 810 Chapter 10: Physical Datapath With Relative Placement Performing Placement and Legalization of Relative Placement Groups Feedback Figure 186 Legalizing the RP3 Relative Placement Group Over Other Groups RP1 RP2 RP1 RP2 RP3 After you legalize one or more relative placement groups by using the legalize_rp_groups command, there might be overlaps with cells in other relative placement groups or cells that are not in relative placement groups. Use the check_legality command to identify any cell overlaps and use the legalize_placement command to resolve any remaining cell overlaps."}
{"header": "Identifying the Clock Roots", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The Fusion Compiler tool uses the clock sources defined by the create_clock command, which can be either input ports or internal hierarchical pins, as the clock roots. For nested clock trees with generated clocks, which are defined by the create_generated_clock command, the tool considers the master-clock source to be the clock root, and the clock endpoints of the nested clock tree are considered endpoints of the master-clock source. For example, for the netlist shown in Figure 72 , the tool considers the CLK port to be the clock root for the genclk1 generated clock. Fusion Compiler User Guide 340 Chapter 5: Clock Tree Synthesis Defining the Clock Trees Feedback Figure 72 Nested Clock Tree With a Generated Clock CLK QN clk1 genclk1 If the block contains generated clocks, ensure that the master-clock sources are correctly defined, as incorrect definitions can result in poor skew and timing QoR. In particular, If the tool cannot trace back to the master-clock source, it cannot balance the sink pins of the generated clock with the sink pins of its source. If the master-clock source is not a clock source defined by the create_clock or create_generated_clock command, the tool cannot synthesize a clock tree for the generated clock or its source. Use the check_clock_trees command to verify that your master-clock sources are correctly defined, as described in Verifying the Clock Trees Specifying the Clock Root Timing Characteristics To get realistic clock tree synthesis results, you must ensure that the timing characteristics of the clock roots are correctly modeled. If the clock root is an input port without an I/O pad cell, you must accurately specify the driving cell of the input port. If you specify a weak driving cell, the tool might insert extra buffers to try to meet the clock tree design rule constraints, such as maximum transition time and maximum capacitance. If you do not specify a driving cell (or drive strength), the tool assumes that the port has infinite drive strength. For example, if the CLK1 port is the root of the CLK1 clock tree, use the following command to set its driving cell as the CLKBUF cell in the mylib cell library: fc_shell> set_driving_cell -lib_cell mylib/CLKBUF [get_ports CLK1] If the clock root is an input port with an I/O pad cell, you must accurately specify the input transition time of the input port. Fusion Compiler User Guide 341 Chapter 5: Clock Tree Synthesis Defining the Clock Trees Feedback For example, if the CLK1 port is the root of the CLK1 clock tree and the I/O pad cell has already been inserted, use the following commands to set its input transition time to 0.3 for rising delays and 0.2 for falling delays: fc_shell> set_input_transition -rise 0.3 [get_ports CLK1] fc_shell> set_input_transition -fall 0.2 [get_ports CLK1]"}
{"header": "Setting the Rerouting Mode", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, Zroute can reroute nets as needed. You can prevent rerouting or limit rerouting to minor changes by setting the physical_status attribute on the nets. To freeze the net and prevent rerouting, set the attribute to locked To limit rerouting to minor changes, set the attribute to minor_change To allow Zroute to reroute the nets as needed, set the attribute to unrestricted For example, to prevent rerouting of the net1 net, which uses the default routing rule, use the following command: fc_shell> set_attribute -objects [get_nets net1] \\ -name physical_status -value locked"}
{"header": "Removing Hotspots", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The tool saves the generated hotspot data in memory. If you want to generate hotspots for other nets in another run, you need to remove the previously generated hotspot data from memory with the remove_hot_spots command before proceeding to another hotspot analysis run. For example, if you have run the generate_hot_spots command on the VDD net, you must first remove the hotspot data for the VDD net before generating hotspots for other nets. Fusion Compiler User Guide 943 Chapter 12: RedHawk and RedHawk-SC Fusion Voltage Hotspot Analysis Feedback See Also Generating Hotspots Reporting Hotspots Voltage Hotspot Analysis Examples"}
