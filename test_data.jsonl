{"header": "Controlling Placement When Using the place_eco_cells Command", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The place_eco_cells command places and legalizes each ECO cell based on the connectivity and the delays associated with the cell. You can control the placement of the ECO cells as follows: To use the channels areas between macro cells for ECO placement, use the -channel_aware option. By default, the command avoids channel areas during ECO placement. Fusion Compiler User Guide 973 Chapter 13: ECO Flow Placing ECO Cells Feedback To place ECO cells closer to fixed points, such as I/O pads or macro cells, specify a weight for the nets connected to the fixed cells by using the -fixed_connection_net_weight option. By default, nets connected to fixed cells have a weight of one. To place ECO cells closer to fixed points, specify an integer value greater than one for the corresponding net. To prioritize specific nets during ECO placement by specifying net weights, 1. Specify net weights by using the set_eco_placement_net_weight command. 2. Specify that the tool honors the net weights by using the -honor_user_net_weight option with the place_eco_cells command. To report the net weights you specify, use the report_eco_placement_net_weight command. To create virtual connections for ECO cells and use them during ECO placement, instead of the actual connections, 1. Create virtual connections by using the create_virtual_connection command 2. Use these virtual connections during ECO placement by using the -use_virtual_connection option with the place_eco_cells command. The following example creates virtual connections for the inputs and output of the cell named ECO17 and performs ECO placement using these virtual connections: fc_shell> create_virtual_connection -name VC_0 \\ -pins {U1/Y ECO17/A} fc_shell> create_virtual_connection -name VC_1 \\ -pins {U2/Y ECO17/B} fc_shell> create_virtual_connection -name VC_2 \\ -pins {ECO17/Y D17_OUT} -weight 3 fc_shell> place_eco_cells -cells ECO17 -use_virtual_connection To remove virtual connections you have created, use the remove_virtual_connections command. To query virtual connections, use the get_virtual_connections command. To ignore high-fanout nets connected to ECO cells that exceed a specific threshold, use the -max_fanout option with the place_eco_cells command. To ignore the connections of specific pins on ECO cells, use the -ignore_pin_connection option with the place_eco_cells command. Fusion Compiler User Guide 974 Chapter 13: ECO Flow Placing ECO Cells Feedback"}
{"header": "Generating Via Ladder Rules for Electromigration Via Ladders", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Instead of explicitly defining via ladder rules for electromigration via ladders, you can use the generate_via_ladder_template command to generate via ladder rules and constraints based on a configuration file. The configuration file is an XML file that provides information about the via ladder rules, as well as the association between the via ladder rules and specific pins. You must specify the name of the configuration file by using the -config_file option. The command generates two script files: A script file that defines the via ladder rules, which is called the template script file This script file contains a create_via_rule command for each template defined in the configuration file, as well as set_attribute commands to set the appropriate via rule attributes. By default, the file is named auto_gen_via_ladder_template.tcl. To specify a different file name, use the -template_file option. A script file that defines the via ladder constraints, which is called the association script file This script file contains set_via_ladder_candidate commands for the pins specified in the configuration file, as well as set_attribute commands to set the is_em_via_ladder_required attribute for the pins to true By default, the file is named auto_gen_via_ladder_association.tcl. To specify a different file name, use the -association_file option. Fusion Compiler User Guide 449 Chapter 6: Routing and Postroute Optimization Inserting Via Ladders Feedback The configuration file has the following syntax: <EmRule> <!-- template definition --> <Template name=\" rule_name \"> <Layer name=\" layer_name \" row_number=\" cuts_per_row [max_stagger_tracks=\" count \"] [upper_cut_x_min_spacing=\" x_spacing \"] [upper_cut_y_min_spacing=\" y_spacing \"] /> ... more layers </Template> \u2026 more templates <!-- Pin to template association --> <Pin name=\" pin_name \"> <Template name=\" rule_name \"/> </Pin> ... more associations </EmRule> Each Template section specifies the template for a via ladder rule. You can specify one or more Template sections. Within a template section, you specify the via ladder structure by specifying the number of cuts per row for each metal layer involved in the via ladder. The command uses the information in the configuration file and associated information from the technology file to generate the via ladder rules. The command derives the following information from the technology file The cut layers that connect the specified metal layers The cut names The minimum required length for each metal layer Note: You must open the block before running the generate_via_ladder_template command to ensure that the command has access to the technology data for the block. Each Pin section specifies the template associated with a pin, where the pin name can include the asterisk wildcard character (*). You can specify one or more Pin sections. The template specified in the Pin section's Template attribute must be one of the templates specified in the Template sections. For example, assume you have a configuration file named vl_config that has the following contents: <EmRule> <Template name=\"template_1_3231\"> <Layer name=\"M1\" row_number=\"3\"/> <Layer name=\"M2\" row_number=\"2\"/> <Layer name=\"M3\" row_number=\"3\"/> Fusion Compiler User Guide 450 Chapter 6: Routing and Postroute Optimization Inserting Via Ladders Feedback <Layer name=\"M4\" row_number=\"1\"/> </Template> <Pin name=\"*/BCELLD5A11*/Z\"> <Template name=\"template_1_3231\"/> </Pin> </EmRule> To generate the script files to define the via ladder rules and constraints, use the following command: fc_shell> generate_via_ladder_template -config_file vl_config Example 17 shows the template script file generated by this command. Example 18 shows the association script file generated by this command. Example 17 Template Script File create_via_rule -name template_1_3231 \\ -cut_layer_names {VIA1 VIA2 VIA3} -cut_names {V1S V2S V3S} \\ -cut_rows {2 3 1} -cuts_per_row {3 2 3} set viaRule [get_via_rules template_1_3231] set_attribute $viaRule upper_metal_min_length_table {0.3 0.2 0.4} set_attribute $viaRule for_electro_migration true Example 18 Association Script File foreach_in_collection pin [get_lib_pins -quiet */BCELLD5A11*/Z] { set_attribute -quiet $pin is_em_via_ladder_required true set_via_ladder_candidate $pin -ladder_name \"template_1_3231\" See Also Defining Via Ladder Rules Specifying Automatic Via Ladder Insertion Settings for Preroute Optimization"}
{"header": "Restricting the Target Libraries Used", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can restrict the libraries used during clock tree synthesis for the top level or a lower level of the logical hierarchy of a design by using the set_target_library_subset -clock command. To enable the use of the target library subset, you must set the opt.common.enable_target_library_subset_opt application option to The following example specifies the buf1 and buf2 cells from the HVT_lib and LVT_lib libraries as clock tree references. However, it restricts the lower-level block named TSK_BLK to use only the cells from the LVT_lib library for its clock nets. Therefore, only buf1 and buf2 cells from the LVT_lib library are used as clock references for that block. fc_shell> set_lib_cell_purpose -include cts \\ {HVT_lib/buf1 HVT_lib/buf2 LVT_lib/buf1 LVT_lib/buf2} fc_shell> set_target_library_subset -clock {LVT_lib} \\ -objects [TOP/TSK_BLK] fc_shell> set_app_options \\ -name opt.common.enable_target_library_subset_opt -value 1 Fusion Compiler User Guide 359 Chapter 5: Clock Tree Synthesis Specifying the Clock Tree Synthesis Settings Feedback"}
{"header": "Hierarchical Synthesis Flow When Floorplans are not Available", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To partition and plan the top-level design and create the lower-level blocks for subsequent bottom-up synthesis, when the floorplans of subblock and top-level design are not available, perform the following steps: Figure 187 Hierarchical Synthesis Flow When Floorplans are not Available 1. Read in the full chip design and apply constraints as shown in the following example: fc_shell> set REF_LIBS \"stdcell.ndm macro.ndm\" fc_shell> create_lib TOP -technology techfile \\ -ref_libs $REF_LIBS fc_shell> analyze -format verilog $rtl_files fc_shell> elaborate TOP fc_shell> set_top_module TOP fc_shell> load_upf fullchip.upf fc_shell> read_sdc fullchip.sdc 2. Identify the design partitions and split the constraints as shown in the following example: fc_shell> set_budget_options -add_blocks {BLOCK1 BLOCK2} fc_shell> split_constraints 3. Create the subblock design libraries with design information and enable block-specific reference library setup as shown in the following example: fc_shell> copy_lib -to_lib BLOCK1.nlib -no_design fc_shell> copy_lib -to_lib BLOCK2.nlib -no_design Fusion Compiler User Guide 819 Chapter 11: Hierarchical Implementation Performing Hierarchical Synthesis Using Abstracts Feedback fc_shell> set_attribute -objects BLOCK1.nlib \\ -name use_hier_ref_libs -value true fc_shell> set_attribute -objects BLOCK2.nlib \\ -name use_hier_ref_libs -value true fc_shell> save_lib -all 4. Create the subblock design partitions as shown in the following example: fc_shell> commit_block -library BLOCK1.nlib BLOCK1 fc_shell> commit_block -library BLOCK2.nlib BLOCK2 fc_shell> save_lib -all 5. Load the UPF and SDC constraints for the unmapped subblocks and the top-level, which are generated by the split_constraints command earlier as shown in the following example: fc_shell> set_constraint_mapping_file ./split/mapfile fc_shell> load_block_constraints -all_blocks -type SDC \\ -type UPF -type CLKNET fc_shell> save_lib -all 6. Run the compile_fusion command until logic optimization with auto floorplanning for sub blocks is complete as shown in the following example: fc_shell> compile_fusion -to logic_opto 7. Run the compile_fusion command until technology mapping for the top-level design is complete as shown in the following example: fc_shell> compile_fusion -to initial_map 8. Perform design planning operations starting from floorplan initialization, subblock and voltage area shaping, hard macro and standard cell placement, power network creation until pin assignment. 9. Run the compile_fusion command until logic optimization for the top-level design is complete as shown in the following example: fc_shell> compile_fusion -from logic_opto -to logic_opto 10. Perform incremental top-level only standard cell placement as shown in the following example: fc_shell> create_placement -floorplan -use_seed_locs 11. Perform timing estimation and budgeting steps to generate the block budgets needed for block level implementation. 12. After completing the design planning operations, rebuild the subblock and top-level design by opening the elaborated RTL NDM, loading floorplan, feedthroughs and budgets. Fusion Compiler User Guide 820 Chapter 11: Hierarchical Implementation Performing Hierarchical Synthesis Using Abstracts Feedback"}
{"header": "RedHawk Fusion and RedHawk-SC Fusion Data Flow", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The RedHawk/RedHawk-SC Fusion feature allows you to perform rail analysis during the implementation stage. With the required input files, the Fusion Compiler tool creates the RedHawk run script and the Global System Requirements (GSR) configuration file for invoking the RedHawk tool (or the RedHawk-SC Python script for invoking the RedHawk-SC tool) to run PG net extraction, power analysis, voltage drop analysis, and PG electromigration analysis. When analysis is complete, the Fusion Compiler tool generates analysis reports and maps using the results calculated by the RedHawk or RedHawk-SC tool. You can then check for hotspots graphically in the Fusion Compiler GUI. Error data and ASCII reports are also available to check for locations where limits are violated. Figure 199 illustrates the data flow when using RedHawk Fusion or RedHawk-SC Fusion to perform rail analysis in the Fusion Compiler environment. Fusion Compiler User Guide 872 Chapter 12: RedHawk and RedHawk-SC Fusion An Overview for RedHawk Fusion and RedHawk-SC Fusion Feedback Figure 199 RedHawk Fusion and RedHawk-SC Fusion Data Flow"}
{"header": "Freeze Silicon ECO Flow", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "Use this flow if your cell placement is fixed, and you can only change the metal and via mask patterns. This flow is recommended if you have taped out your design and you want to avoid the expense of generating a whole new mask set. To perform the freeze silicon ECO flow, your block must contain spare cells. You can add spare cells to a block, anytime during the design flow, by using one of the following methods: Manually instantiate spare cells, as described in Manually Instantiating Spare Cells Automatically add spare cells after placement by using the add_spare_cells command, as described in Automatically Adding Spare Cells Add programmable spare cells during the chip finishing stage by using the create_stdcell_fillers , as described in Adding Programmable Spare Cells The freeze silicon ECO flow consists of the following steps: 1. Enable ECO changes in the freeze silicon mode by setting the design.eco_freeze_silicon_mode application option to true 2. Update the design with the ECO changes by using one of the following methods: Using the eco_netlist command, as described in Making ECO Changes Using the eco_netlist Command Using netlist editing Tcl commands, as described in Making ECO Changes Using Netlist Editing Commands 3. Analyze the mapping of ECO cells to spare cells by using the check_freeze_silicon command. 4. Automatically map all the ECO changes to spare cells by using the place_freeze_silicon command or manually map each ECO cell to a specific spare cell by using the map_freeze_silicon command, as described in Placing and Mapping ECO Cells to Spare Cells 5. Update the routing by using the route_eco command, as described in Performing ECO Routing , or by manually rerouting the affected nets."}
{"header": "Performing Postroute Optimization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The Fusion Compiler tool can perform two types of postroute optimization: Logic optimization This optimization improves the timing, area, and power QoR and fixes logical DRC violations and performs legalization and ECO routing. To perform these optimizations, use the route_opt command, as described in Performing Postroute Logic Optimization Routability optimization This optimization increases the spacing between cells to fix routing DRC violations caused by pin access issues. To perform this optimization, use the optimize_routability command, as described in Fixing DRC Violations Caused by Pin Access Issues If you run both logic optimization and routability optimization, you should first perform the logic optimization and then the routability optimization. Fusion Compiler User Guide 548 Chapter 6: Routing and Postroute Optimization Performing Postroute Optimization Feedback"}
{"header": "Reporting Commands and Examples", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "This table shows some reporting commands to report QoR, timing, area, and so on. Use this command To do this report_area Report area information of the current design. - Area is based on physical libraries. - Numbers of ports and nets are not reported. report_qor Report QoR information and statistics for the current design. - Information is based on physical libraries. report_timing Report the timing information of the current design. Fusion Compiler User Guide 262 Chapter 3: Physical Synthesis Performing Design Analysis Feedback Use this command To do this report_power Calculate and report dynamic and static power of the design or instance. report_clock_gating Report total clock-gating statistics of the design. report_logic_levels Report logic levels of the design. report_area Example fc_shell> report_area -designware -hierarchy -physical **************************************** Report : area Design : test ... **************************************** Information: Base Cell (com): cell XNOR2ELL, w=3300, h=6270 (npin=3) Information: Base Cell (seq): cell LPSDFE2, w=10560, h=6270 (npin=5) Number of cells: 8 Number of combinational cells: 4 Number of sequential cells: 4 Number of macros/black boxes: 0 Number of buf/inv 0 Number of references 2 Combinational area: 49.66 Buf/Inv area: 0.00 Noncombinational area: 231.74 Macro/Black box area: 0.00 Total cell area: 281.40 ____________________________________________________________________ Hierarchical area distribution ------------------------------ Global cell area Local cell area --------------------------------------------- Hierarchical cell Absolute Percent Combi- Noncombi- Black- Total Total national national boxes Design -------------------------------------------------------------------- test 281.40 100.0 37.24 231.74 0.00 test mult_10 12.41 4.4 12.41 0.00 0.00 DW_mult_uns_J1_H3_D1 -------------------------------------------------------------------- Total 49.66 231.74 0.00 Area of detected synthetic parts ---------------------------------- Perc.of Module Implem. Count Area cell area Fusion Compiler User Guide 263 Chapter 3: Physical Synthesis Performing Design Analysis Feedback ---------------------------------------------------- DW_mult_uns pparch 1 12.41 4.4% ---------------------------------------------------- Total: 1 12.41 4.4% Estimated area of ungrouped synthetic parts ------------------------------------------- Estimated Perc. of Module Implem. Count area cell area ---------------------------------------------------- DW_mult_uns pparch 3 48.28 17.2% ---------------------------------------------------- Total: 3 48.28 17.2% Total synthetic cell area: 60.69 21.6% (estimated) ____________________________________________________________ Core Area: 1767 Aspect Ratio: 1.0902 Utilization Ratio: 0.1593 The above information was from the logic library. The following information was from the physical library: Total moveable cell area: 281.4 Total fixed cell area: 0.0 Total physical cell area: 281.4 Core area: 0.000, 0.000, 40.260, 43.890 report_qor Example fc_shell> report_qor *********************************************** Report : qor Design : top ... *********************************************** Scenario 'SC1' Timing Path Group 'clk' ----------------------------------------------- Levels of Logic: 6 Critical Path Length: 0.28 Critical Path Slack: -0.19 Critical Path Clk Period: 0.30 Total Negative Slack: -0.80 No. of Violating Paths: 11 Worst Hold Violation: -0.07 Total Hold Violation: -0.13 No. of Hold Violations: 32.00 ----------------------------------------------- Cell Count ----------------------------------------------- Fusion Compiler User Guide 264 Chapter 3: Physical Synthesis Performing Design Analysis Feedback Hierarchical Cell Count: 2 Hierarchical Port Count: 24 Leaf Cell Count: 287 Buf/Inv Cell Count: 45 Buf Cell Count: 4 Inv Cell Count: 41 CT Buf/Inv Cell Count: 0 Combinational Cell Count: 208 Sequential Cell Count: 79 Macro Count: 1 ----------------------------------------------- Area ----------------------------------------------- Combinational Area: 419.34 Noncombinational Area: 736.26 Buf/Inv Area: 67.60 Total Buffer Area: 9.66 Total Inverter Area: 57.94 Macro/Black Box Area: 2337.90 Net Area: 0 Net XLength: 0 Net YLength: 0 ----------------------------------------------- Cell Area (netlist): 3493.49 Cell Area (netlist and physical only): 3493.49 Net Length: 0 Design Rules ----------------------------------------------- Total Number of Nets: 363 Nets With Violations: 0 Max Trans Violations: 0 Max Cap Violations: 0 ----------------------------------------------- report_transformed_registers Example The report_transformed_registers command reports the following information about registers that are modified or removed during compile: Sequential output ports inversion Constant registers that are removed and the constant values Constant registers that are preserved by users Unloaded registers that are removed Unloaded registers that are preserved by users Register merging Fusion Compiler User Guide 265 Chapter 3: Physical Synthesis Performing Design Analysis Feedback Register replication Shift registers Multibit registers Summary of register optimizations Use the report_transformed_registers command only on a mapped design generated by compile or incremental compile. If you run the command on an unmapped design, the report_transformed_registers command reports no information. The information of transformed or optimized registers is stored in the design library, so you can query the same information by using the report_transformed_registers command in different sessions. For example, fc_shell> report_transformed_registers **************************************** Report: report_transformed_registers Version: ... Date: ... **************************************** Legend: C0p - constant 0 register preserved C1p - constant 1 register preserved C0r - constant 0 register removed C1r - constant 1 register removed ulp - preserved unloaded register ulr - removed unloaded register mrg - merged register srh - shift register head srf - shift register flop mb - multibit rep - replicated inv - inverted Register Optimization --------------------------------------------------------- ------------ I_RISC_CORE/I_DATA_PATH/PSWL_Carry_reg C0r I_RISC_CORE/I_STACK_TOP/I3_STACK_MEM/Stack_Mem_reg[0][0] C0r I_RISC_CORE/I_STACK_TOP/I3_STACK_MEM/Stack_Mem_reg[1][0] C0r To report the count of each type of register transformation, specify the -summary option as shown in the following example: fc_shell> report_transformed_registers -summary **************************************** Report: report_transformed_registers Version: ... Date: ... Fusion Compiler User Guide 266 Chapter 3: Physical Synthesis Performing Design Analysis Feedback **************************************** Legend: C0p - constant 0 register preserved C1p - constant 1 register preserved C0r - constant 0 register removed C1r - constant 1 register removed ulp - preserved unloaded register ulr - removed unloaded register mrg - merged register srh - shift register head srf - shift register flop mb - multibit rep - replicated inv - inverted Register Count ---------------------------------------------------------------------- Constant Registers Deleted 12 Constant Registers Preserved 1 Unloaded Registers Deleted 101 Unloaded Registers Preserved 38 Shift Registers 170 Merged 12 Multibit 10 Inverted 15 Replicated 4"}
{"header": "Running and Placing Group Repeaters", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Use the add_group_repeaters and place_group_repeaters commands to display the summary report for variant cell swapping in command cell collections."}
{"header": "Partitioning and Planning the Full Chip Design", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The hierarchical synthesis flow using abstracts includes the following two cases: Floorplans of subblock and top-level design are not available Floorplans of subblock and top-level design are available Fusion Compiler User Guide 818 Chapter 11: Hierarchical Implementation Performing Hierarchical Synthesis Using Abstracts Feedback"}
{"header": "Generating a Congestion Map", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To display the global route congestion map, choose View > Map > Global Route Congestion in the GUI. If the design library contains global route congestion information for the block, the tool generates the congestion map based on this information; otherwise, you must click Reload to generate the congestion map. When you click Reload, the tool opens a dialog box that contains the following command: route_global -congestion_map_only true Note: By default, only the hard congestion data is saved in the design library. To also save the soft congestion data, set the route.global.export_soft_congestion_maps application option to true before performing global routing. When you click OK in this dialog box, the tool generates a new congestion map. If you want to use different options for the route_global command, you can modify this command before clicking OK. Fusion Compiler User Guide 566 Chapter 6: Routing and Postroute Optimization Analyzing the Routing Results Feedback Figure 118 shows an example of a congestion map. Figure 118 Global Route Congestion Map By default, the congestion map displays only the hard congestion data. To display soft congestion data, select the desired rule level in the Rule level drop-down list. The rule level refers to the spacing weight level of the soft nondefault spacing rules. The congestion map displays the sum of the hard and soft congestion with a weight level of at least the selected rule level. The congestion map shows the borders between global routing cells highlighted with different colors that represent the congestion values. The congestion map supports two methods for calculating the congestion value: Sum of overflow for each layer (the default) In this mode, the tool calculates the congestion value as the sum of the overflow for all selected layers. Underflow is not considered; if a layer has underflow, it contributes zero overflow to the total overflow calculation. Total demand minus total supply In this mode, the tool calculates the congestion value by subtracting the supply for all selected layers from the demand for all selected layers. Note that because this calculation considers the underflow, it produces a more optimistic congestion result in regions that contain both overflow and underflow. For example, assume that the METAL2 layer is heavily congested with a demand of 13 routing tracks and a supply of only 7 tracks for an overflow of 6. The METAL4 is Fusion Compiler User Guide 567 Chapter 6: Routing and Postroute Optimization Analyzing the Routing Results Feedback moderately congested with an overflow of 4, and the METAL6 layer is not congested and contains an underflow of 3. Other layers are not used in the congestion calculation in this example. The sum of overflow calculation results in a congestion value of 6+4=10. The underflow of 3 for the METAL4 layer is not used in the calculation. The total demand calculation results in a congestion value of 6+4-3=7. In this case, the underflow of 3 for the METAL4 layer is used in the calculation. To select the mode, select either \"Sum of overflow for each layer\" or \"Total demand minus total supply\" in the \"Congestion calculation\" section of the Map Mode panel. By default, all metal layers are selected in the congestion map, except those specified as ignored layers with the set_ignored_layers command. To display the congestion map for a subset of layers, select (or deselect) the layers on the Map Mode panel. For example, if the global routing report shows that the maximum overflow occurs on the METAL2 layer, you can deselect all layers, except for METAL2, to display only the METAL2 congestion. The Map Mode panel also displays a histogram showing the number of global routing cells in different ranges (bins) of congestion values for the selected layers. If your block contains global routing cells that have no available routing resources, an additional bin named Blocked is displayed that shows the number of global routing cells with no routing resources. You can select which bins to display in the congestion map by selecting or deselecting them on the Map Mode panel. If the block shows congested areas, zoom into the congested area to see the congestion value on the global routing cell. For example, in Figure 119 , the red highlight on the edge of the global routing cell shows 18/9. This means there are 9 wire tracks available, but 18 tracks are needed. Fusion Compiler User Guide 568 Chapter 6: Routing and Postroute Optimization Analyzing the Routing Results Feedback Figure 119 Global Route Overflow on Global Routing Cell"}
{"header": "Fixing Buffers", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The -buffer option of the fix_mv_design command fixes isolation violations and illegal library cells in buffer trees throughout the design. The command can perform the following changes: Minimize the number of dual-rail buffers or inverters Fix isolation violations in buffer trees Fix buffers and inverters that have illegal settings, as follows: Process, voltage, and temperature settings Library cell purpose or subset settings Target library subset settings Bias voltages Fix a mismatch between a buffer's power domain and the voltage area in which the buffer or inverter is physically placed The command can change the netlist as follows: Swap buffer library cells to fix illegal settings Swap single-rail buffers for dual-rail buffers Swap dual-rail buffers for single-rail buffers Change the backup supplies of dual-rail buffers and inverters Change the input or output supplies of level shifters Fix a mismatch between a buffer's power domain and a voltage area by using a physical or logical feedthrough Fix a mismatch between a buffer's power domain and a gas station voltage area by using a physical or logical feedthrough The fix_mv_design command keeps the placement of the original buffers or inverters and honors the repeater strategies associated with existing buffers and inverters. In addition, Fusion Compiler User Guide 1007 Chapter 13: ECO Flow Fixing Multivoltage Violations Feedback the command only uses supplies that are available in the voltage area or voltage area region. The fix_mv_design command does not insert isolation cells or level-shifter cells to fix existing isolation or voltage violations. Netlist changes caused by the command do not introduce new isolation or voltage violations. To specify a buffer tree, use the -from option with the name of a net or driver pin. If you specify a net name, its driver pin is used. In both cases, the driver pin defines a full or partial buffer tree. Wildcards are supported. The -lib_cells option specifies a list of single-rail and dual-rail buffer or inverter library cells that the fix_mv_design command can use as replacement cells. By default, the command does not swap dual-rail and single-rail cells if the swap is not necessary to fix isolation violations. However, if you also specify the -minimize_dual_rail option, the tool tries to minimize the usage of dual-rail buffers to save area. If the tool inserts a new library cell as a result of the fix_mv_design command, the new cell is chosen according to the following rules, in priority order: A cell from the same library as the original library cell A cell from a library with a name similar to the original library A cell with a name similar to the original library cell name By default, buffer trees stop at level-shifter cells. Specify the -level_shifter option to allow the fix_mv_design command to modify the input or output supplies of level-shifter cells. However, the command does not change level-shifter library cells. To report the changes that the tool recommends without making any netlist changes, use the -report_only option."}
{"header": "Reading Verilog Gate-Level Netlist Files", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Use the read_verilog command to read Verilog netlist files using a specialized Verilog netlist reader. This command cannot be used to read Verilog RTL files. Only the analyze and elaborate commands should be used to read RTL files. Use the set_top_module command after reading the netlist to specify the top-level module and link the design to create the block. read_verilog top.netlist.v set_top_module top When the file has multiple independent modules, use the -top option to identify the top- level module. For example, read_verilog -top top2 netlists.v set_top_module top2 Fusion Compiler User Guide 101 Chapter 2: Preparing the Design Reading the Design Feedback To specify a new block name other than top_module_name .design, use the -design option. For example, read_verilog -top my_top -design desA ../my_data/my_des.v set_top_module my_top"}
{"header": "Routing Rules of Clock Nets", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To improve timing and reduce crosstalk, nondefault routing rules are used extensively for routing clock nets. However, these nondefault routing rules require additional space, which can increase the congestion after clock routing. To consider the effects of the nondefault routing rules of the clock nets during placement, set the place.coarse.ndr_area_aware application option to true"}
{"header": "Placement-Aware Clock Gating", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "When you enable placement-aware clock gating, the tool performs the following optimizations: Replication of clock gates with timing-critical enables Adjustment of clock gates so they are placed closer to their gated registers Automatic clock network latency annotation for clock-gate cells To enable this feature, set the compile.clockgate.physically_aware application option to true . (The default is false .) The example in Figure 61 shows the difference between using and not using physically- aware clock gating. In this layout view, you can see that the integrated clock gates (shown in red) are physically closer to their gated registers. Fusion Compiler User Guide 316 Chapter 4: Clock Gating Fanin-Based Sequential Clock Gating Feedback Figure 61 Placement-Aware Clock Gating Clock gate cells are shown in red Gated clock nets are shown in blue Placement-Aware Clock Gating Disabled Placement-Aware Clock Gating Enabled"}
{"header": "Analyzing the Placeability of a Relative Placement Group", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Before you run placement and optimization, you can check if a specific relative placement group can be placed by using the check_rp_constraints -analyze_placement command. To limit the analysis to a specific region or a specific number of random sites of the core area, use the -region or -trials option, respectively. To ignore physical design constraints, advanced design rules, or relative placement constraints during placement analysis, use the -no_pdc -no_adv , or -no_rp_constraints option, respectively. To report only the relative placement groups that do not meet a specific threshold, use the -threshold option. The tool reports a group only if the percentage of sites the group can be placed, relative to the total number of sites analyzed, is less than the specified threshold."}
{"header": "Using Tcl Scripts", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can use Tcl scripts to accomplish routine, repetitive, or complex tasks. You create a command script file by placing a sequence of Fusion Compiler commands in a text file. Any Fusion Compiler command can be executed within a script file. In Tcl, a pound sign (#) at the beginning of a line denotes a comment. For example, # This is a comment For more information about writing scripts and script files, see the Using Tcl With Synopsys Tools manual. Use one of the following methods to run a Tcl script: Use the -file option with the fc_shell command when you start the Fusion Compiler tool. Use the source command from the fc_shell command line. Choose File > Execute Script in the GUI. If an error occurs when running a command, the Fusion Compiler tool raises the TCL_ERROR condition, which immediately stops the script execution. To tolerate errors and allow the script to continue executing, either Check for TCL_ERROR error conditions with the Tcl catch command on the commands that might generate errors. Set the sh_continue_on_error variable to true in the script file. Fusion Compiler User Guide 50 Chapter 1: Working With the Fusion Compiler Tool Adding Changes to a Script With Checkpoints Feedback See Also Starting the CLI Adding Changes to a Script With Checkpoints"}
{"header": "Introduction to Zroute", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "Zroute has five routing engines: global routing, track assignment, detail routing, ECO routing, and routing verification. You can invoke global routing, track assignment, and detail routing by using task-specific commands or by using an automatic routing command. You invoke ECO routing and route verification by using task-specific commands. Zroute includes the following main features: Multithreading on multicore hardware for all routing steps, including global routing, track assignment, and detail routing A realistic connectivity model where Zroute recognizes electrical connectivity if the rectangles touch; it does not require the center lines of wires to connect A dynamic maze grid that permits Zroute to go off-grid to connect pins, while retaining the speed advantages of gridded routers A polygon manager, which allows Zroute to recognize polygons and to understand that design rule checks (DRCs) are aimed at polygons Concurrent optimization of design rules, antenna rules, wire optimization, and via optimization during detail routing Concurrent redundant via insertion during detail routing Support for soft rules built into global routing, track assignment, and detail routing Timing- and crosstalk-driven global routing, track assignment, detail routing, and ECO routing Intelligent design rule handling, including merging of redundant design rule violations and intelligent convergence Net group routing with layer constraints and nondefault routing rules Clock routing Route verification Fusion Compiler User Guide 439 Chapter 6: Routing and Postroute Optimization Introduction to Zroute Feedback Optimization for DFM and design-for-yield (DFY) using a soft rule approach Support for advanced design rules, such as multiple patterning Fusion Compiler User Guide 440 Chapter 6: Routing and Postroute Optimization Basic Zroute Flow Feedback"}
{"header": "Removing PG Augmentation Shapes", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To remove PG augmentation shapes, use the -mode remove option with the signoff_create_pg_augmentation command. When you use this command, the IC Validator tool removes all PG augmentation shapes from the current block."}
{"header": "Controlling Pin Connections", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, Zroute connects a signal route to a pin by using wires or vias anywhere on the pin. To restrict the allowed types of pin connections on a per-layer basis, use the following Fusion Compiler User Guide 513 Chapter 6: Routing and Postroute Optimization Routing Constraints Feedback syntax to set the route.common.connect_within_pins_by_layer_name application option: set_app_options -name route.common.connect_within_pins_by_layer_name -value { { layer mode } ... } Valid values for the mode argument are off (the default) There are no restrictions on pin connections. via_standard_cell_pins Only the connections to standard cell pins by using a via are restricted. When using a via connection, the via's metal enclosure must be contained within the pin shape. There are no restrictions on signal routes connected to macro cell and pad cell pins by using a via or to any pins by using wires. via_wire_standard_cell_pins The connections to standard cell pins by using a via or a wire are restricted. When using a via connection, the via's metal enclosure must be contained within the pin shape. When using a wire, the wire must be contained within the pin shape. via_all_pins The connections to any pins (standard cell, macro cell, or pad cell) by using a via are restricted. When using a via connection, the via's metal enclosure must be contained within the pin shape. There are no restrictions on signal routes connected to any pins by using wires. via_wire_all_pins The connections to any pins by using a via or a wire are restricted. When using a via connection, the via's metal enclosure must be contained within the pin shape. When using a wire, the wire must be contained within the pin shape. For example, if you use the following command (or use the default settings), all of the connections shown in Figure 113 are valid and no DRC violations are reported: fc_shell> set_app_options \\ -name route.common.connect_within_pins_by_layer_name \\ -value {{M1 off}} Fusion Compiler User Guide 514 Chapter 6: Routing and Postroute Optimization Routing Constraints Feedback Figure 113 Unrestricted Pin Connections If you set the mode for M1 to via_all_pins , as shown in the following example, the via enclosures must be inside the pin shape. The connections shown on the left side of Figure 114 are valid; however, the connections on the right side of the figure cause DRC violations. fc_shell> set_app_options \\ -name route.common.connect_within_pins_by_layer_name \\ -value {{M1 via_all_pins}} Figure 114 Restricted Via-to-Pin Connections No DRC Violations DRC Violations If you set the mode for M1 to via_wire_standard_cell_pins , as shown in the following example, both the via enclosures and wires must be inside the pin shape. The connections Fusion Compiler User Guide 515 Chapter 6: Routing and Postroute Optimization Routing Constraints Feedback shown on the left side of Figure 115 are valid; however the connections on the right side of the figure cause DRC violations. fc_shell> set_app_options \\ -name route.common.connect_within_pins_by_layer_name \\ -value {{M1 via_wire_standard_cell_pins}} Figure 115 Restricted Via-to-Pin and Wire-to-Pin Connections DRC Violations No DRC Violations"}
{"header": "Clock-Gate Collapsing", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The default of the compile.clockgate.max_number_of_levels application option is 0, which allows an infinite number of levels. You can set the compile.clockgate.max_number_of_levels application option without enabling clock-gate level expansion. In this case, the tool collapses clock-gate levels if the specified limit is less than the number of clock-gate levels that exist after the initial_map stage. The tool collapses clock-gate levels as follows: The tool first tries to collapse clock gates at levels higher than the specified maximum level, starting from the clock gates at the highest level (closest to the registers). If a specific clock gate cannot be collapsed, the tool tries to collapse upstream clock gates until it reaches the lowest level (closest to the source). The collapse can occur across hierarchies. The tool tries to preserve the parent (upstream) clock gate. The tool removes all remaining clock gates that do not meet the maximum number of levels."}
{"header": "Using the compile_fusion Command", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To perform unified physical synthesis, use the compile_fusion command. The compile_fusion command consists of the following stages: 1. initial_map During this stage, the tool maps the design and performs area optimization. 2. logic_opt During this stage, the tool performs logic-based delay optimization. 3. initial_place During this stage, the tool merges the clock-gating logic and performs coarse placement. 4. initial_drc During this stage, the tool removes existing buffer trees and performs high-fanout-net synthesis and electrical DRC violation fixing. 5. initial_opto During this stage, the tool performs physical optimization and incremental placement. 6. final_place During this stage, the tool performs final placement to improve timing and congestion. 7. final_opto During this stage, the tool performs final optimization and legalization to improve timing, power, and logical DRCs. Fusion Compiler User Guide 213 Chapter 3: Physical Synthesis Performing Unified Physical Synthesis Feedback When you run the compile_fusion command, by default, the tool runs all stages. To run only some of these stages, use the -from option to specify the stage from which you want to begin and the -to option to specify the stage after which you want to end. If you do not specify the -from option, the tool begins from the initial_place stage. Similarly, if you do not specify the -to option, the tool continues until the final_opto stage is completed. Breaking the compile_fusion command in to stages allows you to perform different tasks between the stages, such as changing constraints or settings, generating reports for analysis, performing other implementation tasks such as design planning or DFT insertion, and so on. If you make manual changes to the design between stages, ensure the changes honor the expected state of the design. For example, the design is expected to be mapped after the initial_map stage. Therefore, do not introduce unmapped logic to the design after this stage. You can repeat a stage; however, ensure that you run all stages in the correct sequence. The following example runs the compile_fusion command until it completes the initial_opto stage, performs analysis, changes an application option setting, and restarts by running the initial_opto stage again. fc_shell> compile_fusion -to initial_opto fc_shell> report_qor fc_shell> set_app_option \\ -name opt.common.advanced_logic_restructuring_mode -value timing fc_shell> compile_fusion -from initial_opto In the following situations, the design can contain unmapped cells after the compile_fusion command: Missing the required cells in the library User-specified restrictions on the required library cells When a design contains unmapped cells, the compile_fusion command continues the compilation and provides an estimated area for the unmapped cells. Unmapped cells are marked with the is_unmapped attribute. To query unmapped cells in a netlist, use the following command: fc_shell> get_cells -hierarchical -filter \"is_unmapped==true\" Note the following limitations: DesignWare operators are not mitigated. Only placement information is stored in the database after mitigation; routing information is not saved. Fusion Compiler User Guide 214 Chapter 3: Physical Synthesis Performing Unified Physical Synthesis Feedback"}
{"header": "Reporting Multibit Registers", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "After you run the compile_fusion command, you can report the registers that are transformed due to multibit banking and debanking by using the report_transformed_registers -multibit command. The following example shows a portion of a report generated by the report_transformed_registers -multibit command. fc_shell> report_transformed_registers -multibit ... **************************************** Attributes: mb - multibit mbd - multibit debanked ... Register Optimization ----------------------------------- MB_2_MB_1 mb (source:MB_2, MB_1) MB_0_MB_3 mb (source:MB_0, MB_3) MB_5, MB_6 mbd (source: MB_5_MB_6)"}
{"header": "Reserving Space for Top-Level Routing", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To reserve space for top-level routing, create a corridor routing blockage by using the -reserve_for_top_level_routing option when you create the routing blockage. During block-level implementation, a corridor routing blockage acts as a regular blockage to prevent routing in the blockage area. During frame view extraction, the tool removes the corridor routing blockage to allow top-level routing in this area."}
{"header": "Removing Routing Corridors", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To remove routing corridors from the current block, use the remove_routing_corridors command. To remove specific routing corridors, specify the routing corridors, either as a list or collection, such as that returned by the get_routing_corridors command. To remove all routing corridors, specify the -all option. You can also remove routing corridors in the GUI by using the Delete tool."}
{"header": "Viewing PG Electromigration Analysis Results", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "When PG electromigration analysis is complete, you can check for current violations by displaying a PG electromigration map or checking the generated errors in the error browser. Displaying the PG Electromigration Map Checking PG Electromigration Violations"}
{"header": "Reducing Electromigration", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Clock cells consume more power than cells that are not in the clock network. Clock cells that are clustered together in a small area increase the current densities for the power and ground rails, which increases the potential for electromigration problems. One way to avoid the problem is to set spacing requirements between clock cells to prevent local clumping of the clock cells along a standard cell power rail between the perpendicular straps. To use this method to reduce electromigration in the block, 1. Define clock cell spacing rules for the inverters, buffers, and integrated clock-gating cells in the clock network by using the set_clock_cell_spacing command, as described in Defining Clock Cell Spacing Rules 2. Perform clock tree synthesis by using the synthesize_clock_trees command, as described in Performing Standalone Clock Trees Synthesis , or the clock_opt command, as described in Synthesizing, Optimizing, and Routing Clock Trees With the clock_opt Command Note: The clock cell spacing rules are also honored by the balance_clock_groups command. For information about using this command, see Balancing Skew Between Different Clock Trees Fusion Compiler User Guide 362 Chapter 5: Clock Tree Synthesis Specifying the Clock Tree Synthesis Settings Feedback 3. Check clock cell spacing rule violations by using the check_legality -verbose command. You should not see any violations if you set the appropriate clock cell spacing constraints."}
{"header": "Defining Matching Wire Lengths", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "To define a group of nets or pin-to-pin connections that must have the same wire length, use the create_wire_matching command. By matching wire lengths, you can minimize clock skews and timing violations. Two types of length-matching methods are available: Pin-based: Wire lengths between pins must match. Figure 157 and Figure 158 show examples of pin-based wire length matching. In both examples, all the receivers have a matched length constraint from driver D. Net-based: Total length of wires of specified nets must match. Figure 159 shows an example of net-based wire length matching. In the example, the total wire length of nets pr1 and pr2 are within the specified 10-um tolerance. Figure 157 Receivers With Matched Wire Length From Driver D Fusion Compiler User Guide 758 Chapter 9: Routing Using Custom Router Defining Routing Constraints Feedback Figure 158 Receivers With Matched Wire Length From Driver D' Figure 159 Net-Based Wire Length Matching Syntax: fc_shell> create_wire_matching -for objects -tolerance float -match_type type -exclude objects -relative -driver pin or port -force intent_name Command or Options Description create_wire_matching Creates a length-matching constraint. -for Name of the driver pin or port ( Figure 157 and Figure 158 ), or net group ( Figure 159 ) that must comply with the constraint. -tolerance Length tolerance. The float value must be >= 0. To specify the tolerance as a percentage, use the -relative option. -relative (Optional) Interprets a -tolerance value <=1 as a percentage. The option must always be used with the -tolerance option. Fusion Compiler User Guide 759 Chapter 9: Routing Using Custom Router Defining Routing Constraints Feedback Command or Options Description -match_type (Optional) Type of length matching. Valid values are: length : (Default) Compares the length of each object in the constraint group to make sure they have the same total length. length_per_layer : Compares the per-layer length. -exclude (Optional) Excludes the specified pins or ports from the length matching constraint. -driver (Optional) Name of the driver pin or port. -force (Optional) Overwrites the existing constraint. Use the option to delete existing constraint groups. intent_name (Optional) Name of the constraint. If you do not specify a name, the command assigns a name. By default, the command returns an error if the assigned name already exists. To delete an existing constraint, use the -force option. After routing, a matched-length summary report is generated. You can use the report to troubleshoot and resolve the lengths that do not meet the set tolerance. The content of the report depends on the -for option that you specified: If the -for option specifies pin-based length matching, a Length Constraint Report is generated. See Figure 160 If the -for option specifies net-based length matching, a Routed Length report is generated. See Figure 161 Figure 160 Pin-Based Length Matching Report Fusion Compiler User Guide 760 Chapter 9: Routing Using Custom Router Defining Routing Constraints Feedback Figure 161 Net-Based Length Matching Report In Example 34 , the commands create wire matching constraints for the scenario shown in Figure 157 . All receivers (R) have a matched length constraint from the balanced driver (D). Example 34 Wire Matching Constraints for All Receivers to Driver D fc_shell> create_wire_matching -for [get_nets -physical_context $net] \\ -relative -tolerance 0.01 -driver [get_pins -physical_context D/o1] fc_shell> create_wire_matching -for [get_pins \\ -physical_context {R1/a R2/a R3/a}] -tolerance 0.01 -relative In Example 35 , the commands create wire matching constraints for the example in Figure 158 Example 35 Wire Matching Constraints for Receivers Connected to Driver D' fc_shell> create_wire_matching -for [get_nets -physical_context $net] \\ -tolerance 0.01 -relative -driver $driver_full_name fc_shell> create_wire_matching \\ -for [get_pins -physical_context -of_objects $net] \\ -exclude $driver_full_name -tolerance 0.01 -relative In Example 36 , the command creates a constraint group named abc for the nets and bundles that match the pattern pr*. An absolute tolerance of 10 um is set to match the length of each object in the constraint group. See Figure 159 Example 36 Wire Matching Constraints for pr* Nets fc_shell> create_wire_matching abc \\ -for [get_nets -physical_context pr*] \\ -tolerance 10 {abc} In Example 37 , the command creates a constraint group named def for the nets and bundles that match the pattern pr*. A tolerance of 10 percent is set to match the length of each object in the constraint group. Fusion Compiler User Guide 761 Chapter 9: Routing Using Custom Router Defining Routing Constraints Feedback Example 37 Wire Matching Constraints for pr* Nets With Percent Tolerance fc_shell> create_wire_matching def \\ -for [get_nets -physical_context pr*] \\ -tolerance 0.10 -relative {def} In Example 38 , the command creates a wire matching constraint named clk_match for the clk net. Each of the endpoints that connect to the clk net has an individual matching constraint. Example 38 Wire Matching Constraints for the clk Net fc_shell> create_wire_matching -for [get_pins -physical_context \\ -of_objects [get_nets -physical_context {clk}]] \\ -tolerance 0.01 -match_type length_per_layer -relative \\ -force clk_match In Example 39 , the command creates a wire matching constraint named clk_match2 for all the nets in the block, except the pins whose names match the keyword u1/a. Example 39 Wire Matching Constraints With Exclusions fc_shell> create_wire_matching -for $nets -tolerance 0.05 \\ -exclude [get_pins -physical_context u1/a] -force clk_match2 In Example 40 , the script creates a net-based wire matching constraint for the scenario shown in Figure 162 . The cell instance has an o1 terminal that servers as an inverter pin, driving signals on net1 and net1p to the pins. The I2 and I3 pins are excluded from the length matching constraint. Example 40 Net-Based Wire Matching Constraints With Pin Exclusions # set nets to match length set nets [get_nets -physical_context {net1 net1p}] # set allowed layers set_routing_rule -min_routing_layer m7 -max_routing_layer m8 \\ -min_layer_mode allow_pin_connection -max_layer_mode hard $nets # setup Custom Router wire match constraint set exclude_pin_names [get_pins -physical_context {i2/a i3/a}] create_wire_matching -for $nets -tolerance 0.01 -relative \\ -exclude $exclude_pin_names # run Custom Router route_custom -nets $nets Fusion Compiler User Guide 762 Chapter 9: Routing Using Custom Router Managing Constraint Groups Feedback Figure 162 Net-Based Wire Matching Constraints With Pin Exclusions"}
{"header": "Adding Relative Placement Groups", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Hierarchical relative placement allows relative placement groups to be embedded within other relative placement groups. The embedded groups then are handled similarly to leaf cells. Fusion Compiler User Guide 786 Chapter 10: Physical Datapath With Relative Placement Adding Objects to a Group Feedback You can use hierarchical relative placement to simplify the expression of relative placement constraints. With hierarchical relative placement, you do not need to provide relative placement information multiple times for a recurring pattern. Using hierarchical relative placement provides these benefits: Allows you to organize your relative placement in a manner that is easier to maintain and understand. For example, you can create the relative placement group to parallel your Verilog or VHDL organization. Allows reuse of a repeating placement pattern, such as an adder. Can reduce the number of lines of relative placement information you need to write. Allows integrating blocks. Provides flexibility for the configuration you want."}
{"header": "Setting Clock Gating Transformations", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, clock gating optimization occurs automatically when you synthesize fhs design. You can, however, define settings to allow or prevent clock gating optimization on specific objects. The tool makes no distinction among clock gates. Every clock gate is subject to optimization, whether it is a preexisting or tool-inserted clock gate. The simplest way to restrict clock gating optimization is by using the set_dont_touch and set_size_only commands. These commands restrict all clock gating optimization by preventing removal, merging, and splitting of all clock gates. For a more refined approach, use the set_clock_gate_transformations command. With this command, you can set specific constraints on each integrated clock gate and control which operations can be performed on the clock gate. The set_clock_gate_transformations command provides the following options: -split_fanout Setting this option to false prevents fanout splitting even if the fanout is larger than the maximum allowed. This setting also prevents any splitting performed by placement- aware clock gating. -merge_equivalents Setting this option to true allows a clock gate to be merged with an equivalent clock gate. -collapse_levels Setting this option to false prevents redundant clock gates from being collapsed -ungate_fanout Setting this option to true specifies that the clock gate fanout remain ungated -reset Resets all clock gate settings for the whole design If the size_only or dont_touch attributes are set on a clock-gating instance or clock- gating library cell, these attributes take precedence over any of the constraints specified by the set_clock_gate_transformations command. Fusion Compiler User Guide 314 Chapter 4: Clock Gating Setting Routing Rules for Clock Gates Feedback Example Using Clock Gating Transformations For the example in Figure 60 , suppose you set the following restrictions: set_clock_gating_options -minimum_bitwidth 6 set_clock_gate_transformations [get_cells uicg_b*] true \\ -ungate_fanout false set_clock_gate_transformations [get_cells uicg_c*] false Figure 60 Example of Clock Gating Restrictions During optimization, the tool removes the uicg_a clock gate because of a minimum bitwidth violation (minimum bitwidth is 6). The uicg_b1 and uicg_b2 clock gates are merged (assuming they have an equivalent enable signal). Even though the minimum bitwidth is not met, ungating is not allowed, so the registers remain gated. The uicg_c1 and uicg_c2 clock gates do not allow any transformations, therefore no optimizations are performed for these clock gates."}
{"header": "Using the Command Log File", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "The command log file records the commands processed by the Fusion Compiler tool, including setup file commands and application option settings. By default, the Fusion Compiler tool writes the command log to a file named fc_command.log in the directory from which you invoked fc_shell. You can change the name of the command log file by setting the sh_command_log_file variable in your .synopsys_fc.setup file. You should make any changes to this variable before you start the Fusion Compiler tool. If your user-defined or project-specific setup file does not contain this variable, the Fusion Compiler tool automatically creates the fc_command.log file. Each Fusion Compiler session overwrites the command log file. To save a command log file, move it or rename it. You can use the command log file to Produce a script for a particular implementation strategy Record the physical implementation process Document any problems you are having"}
{"header": "Reporting Routing Corridors", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To report the routing corridors in your block, use the report_routing_corridors command. By default, the command reports all routing corridors; to report specific routing corridors, specify the routing corridors to report. By default, the command reports the following information for each routing corridor: its name; the shapes associated with the routing corridor, including their names, minimum routing layer, maximum routing layer, and boundary; the connectivity of the routing corridor shapes; and the nets and supernets associated with the routing corridor. To output a Tcl script that re-creates the routing corridors, use the -output option. To report the routing corridor for a specific net or supernet, use the get_routing_corridors command. When you run this command, you must use the -of_objects option to specify the nets of interest."}
{"header": "Controlling Boundary Optimization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can control boundary optimization across user-specified logical boundaries and match the interface boundary of a physical block with the RTL module interface. Boundary optimization allows you to use RTL floorplanning DEF files during block implementation. The following figure shows how constants, equal-opposite logic, logic phase, and unloaded ports are propagated through the logical boundaries without and with boundary optimization. Fusion Compiler User Guide 219 Chapter 3: Physical Synthesis Controlling Mapping and Optimization Feedback Constant propagation Phase inversion Unloaded propagation Equal-opposite logic propagation Disabled Enabled Disabled Disabled Disabled Enabled Enabled Enabled Disabled: without boundary optimization Enabled: with boundary optimization Global Control By default, all types of boundary optimization are enabled during compile. To control boundary optimization globally, use the compile.flow.boundary_optimization application option. When you set the compile.flow.boundary_optimization application option to false The tool disables propagation of equal-opposite logic and phase inversion. Constants and unloaded ports continue to propagate across hierarchies. To disable constant propagation and unloaded propagation globally, set the compile.flow.constant_and_unloaded_propagation_with_no_boundary_opt application option to false . The default is true . The setting does not affect object-level specifications. Controlling Specific Types of Boundary Optimization To control the level of boundary optimization for hierarchical cell pins, hierarchical cells, or blocks, use the set_boundary_optimization command. The tool uses the following order of precedence to determine the setting to use during optimization: 1. Setting applied on pins of hierarchical cell instances 2. Setting applied on hierarchical cell instances, which applies to its pins as well 3. Setting applied on modules, which applies to all its cells and pins as well Fusion Compiler User Guide 220 Chapter 3: Physical Synthesis Controlling Mapping and Optimization Feedback The following table shows the level of boundary optimization you can specify with the set_boundary_optimization command and the types of boundary optimization that are enabled for each level. Table 20 Levels of Boundary Optimization and the Corresponding Types of Boundary Optimization Performed Level of boundary optimization Constant propagation Unloaded propagation Equal-opposite logic propagation Phase inversion all Enabled Enabled Enabled Enabled auto Enabled Enabled Disabled Disabled none Disabled Disabled Disabled Disabled You can control the specific types of boundary optimization allowed for an object by using the -constant_propagation -unloaded_propagation -equal_opposite_propagation , and -phase_inversion options. These options are mutually exclusive with the boundary optimization level specified by using all auto , or none and cannot be used on the same object in a single command invocation. If you use the set_boundary_optimization command multiple times on the same object, the effect is additive. Based on the types of boundary optimization you enable or disable, the tool sets the constant_propagation unloaded_propagation equal_opposite_propagation , and phase_inversion read-only attributes of the specified object to true or false . If you Enable all four types, the tool sets the boundary_optimization read-only attribute to true Disable at least one type, the tool sets the boundary_optimization read-only attribute to false To report boundary optimization settings, use the report_boundary_optimization command. To remove them, use the remove_boundary_optimization command. The following example Disables all boundary optimization for the U1 cell instance Disables equal-opposite logic propagation and phase inversion for the U2 cell instance Disables constant propagation and phase inversion for the U3/in1 cell pin fc_shell> set_boundary_optimization [get_cells U1] none fc_shell> set_boundary_optimization [get_cells U2] auto fc_shell> set_boundary_optimization [get_pins U3/in1] \\ -constant_propagation false Fusion Compiler User Guide 221 Chapter 3: Physical Synthesis Controlling Mapping and Optimization Feedback fc_shell> set_boundary_optimization [get_pins U3/in1] \\ -phase_inversion false Controlling Phase Inversion To prevent boundary optimization from moving inverters across hierarchical boundaries, set the compile.optimization.enable_hierarchical_inverter application option to false . By default, the application option is set to true to allow phase inversion. This application option is only effective when boundary optimization is enabled."}
{"header": "Aligning by the Right Edges", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To align a group by aligning the right edges, use the -alignment right option of the set_rp_group_options command. Note: For hierarchical relative placement groups, the bottom-right alignment does not propagate through the hierarchy. Figure 175 shows cells that are right aligned. Fusion Compiler User Guide 796 Chapter 10: Physical Datapath With Relative Placement Specifying Options for Relative Placement Groups Feedback Figure 176 Bottom-Right-Aligned Relative Placement Group U4 U3 U2 U1 row 3 row 2 row 1 row 0 col 0"}
{"header": "Preventing Specific Clocks From Being Synthesized", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, the tool synthesizes all clocks defined with the create_clock and create_generated_clock commands. To prevent the tool from synthesizing a specific clock, specify it by using the cts.common.skip_cts_clocks application option. fc_shell> set_app_options \\ -name cts.common.skip_cts_clocks -value CK_B"}
{"header": "Removing Metal Fill", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The method you use to remove metal fill depends on the extent of the metal fill removal: To remove all metal fill from a block, specific layers of a block, or specific regions of a block, use the signoff_create_metal_fill command with the -mode remove option. This command uses the IC Validator tool to remove metal fill from the current block, as described in Removing Metal Fill With the IC Validator Tool To remove specific fill shapes, use the remove_shapes or remove_fill_cells commands. You would typically use this method when manually fixing DRC violations related to the metal fill. You might also be able to fix the DRC violation by modifying the metal fill shapes, as described in Modifying Metal Fill Fusion Compiler User Guide 739 Chapter 8: IC Validator In-Design Inserting Metal Fill With IC Validator In-Design Feedback"}
{"header": "Improving Instance Voltage Drop by Augmenting the Power Grid", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Power grid augmentation is a technique used to improve the instance voltage drop. When you augment the power grid, the added metal shapes act as parallel resistors, which reduces the resistance of the power grid as seen by the standard cells. Figure 148 shows an example of power grid augmentation and how it lowers the power grid resistance. Figure 148 Power Grid Augmentation The Fusion Compiler tool supports the following methods of power grid augmentation: Standard power grid augmentation , which inserts as many PG augmentation shapes as possible to lower the instance voltage drop Timing-driven power grid augmentation , which inserts PG augmentation shapes in the specified regions of the block, except around timing-critical nets Guided power grid augmentation , which inserts PG augmentation shapes only from cells with IR violations to their tap with the minimum path resistance Each method uses RedHawk Fusion analysis to drive the power grid augmentation and uses the IC Validator tool to insert the PG augmentation shapes. For detailed information about performing power grid augmentation, see the topic associated with the method you want to use. See Also RedHawk and RedHawk-SC Fusion Fusion Compiler User Guide 699 Chapter 8: IC Validator In-Design Improving Instance Voltage Drop by Augmenting the Power Grid Feedback"}
{"header": "Commands", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You interact with the Fusion Compiler tool by using fc_shell commands, which are based on the Tool Command Language (Tcl) and include certain command extensions needed to implement specific Fusion Compiler functionality. The Fusion Compiler command language provides capabilities similar to Linux command shells, including variables, conditional execution of commands, and control flow commands. You can Enter individual commands interactively at the fc_shell> prompt in fc_shell Enter individual commands interactively on the console command line in the GUI Run one or more Tcl scripts, which are text files that contain fc_shell commands (see Using Tcl Scripts When entering a command, an option, or a file name, you can minimize your typing by pressing the Tab key when you have typed enough characters to specify a unique name; the Fusion Compiler tool completes the remaining characters. If the characters you typed could be used for more than one name, the Fusion Compiler tool lists the qualifying names, from which you can select by using the arrow keys and the Enter key. If you need to reuse a command from the output for a command-line interface, you can copy and paste the portion by selecting it, moving the pointer to the fc_shell command line, and clicking with the middle mouse button. When you run a command, the Fusion Compiler tool echoes the command output (including processing messages and any warnings or error messages) in fc_shell and, if the GUI is open, in the console log view. By default, the tool does not use page mode, so the output might scroll. To enable page mode, set the sh_enable_page_mode variable to true Fusion Compiler User Guide 46 Chapter 1: Working With the Fusion Compiler Tool Entering fc_shell Commands Feedback"}
{"header": "Setting Clock Tree Design Rule Constraints", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "The Fusion Compiler tool supports the following design rule constraints for clock tree synthesis: clock tre synthesismaximum capacitanceclock tre design rule constraintmaximum capacitance Maximum capacitance To specify maximum capacitance constraints for clock tree synthesis, use the -clock_path option with the set_max_capacitance command. If you do not specify this constraint, the clock tree synthesis default is 0.6 pF. clock tre synthesismaximum transition timeclock tre design rule constraintmaximum transition time Maximum transition time To specify maximum transition time constraints for clock tree synthesis, use the -clock_path option with the set_max_transition command. If you do not specify this constraint, the clock tree synthesis default is 0.5 ns. By default, these constraints apply to all corners associated with the current mode. To set the constraint for a specific mode, use the -mode option with the get_clocks command to identify the clocks. To set the constraint for specific corners associated with the specified mode, use the -corners option with the constraint command. Be careful to apply the correct constraints across all the modes and their associated corners. For example, to set a maximum transition time of 0.20 ns on all pins in the CLK clock path for all corners of the current mode, use the following command: fc_shell> set_max_transition 0.20 -clock_path [get_clocks CLK] To set different maximum transition time constraints for different corners associated with a specific mode, use the -mode option with the get_clocks command to specify the mode and use the -corners option to specify the corner. For example, to set the maximum transition time to 0.15 ns for corner1 in mode1 and 0.10 ns for corner2 in mode1, use the following commands: fc_shell> set_max_transition 0.15 -corners corner1 \\ -clock_path [get_clocks -mode mode1] fc_shell> set_max_transition 0.10 -corners corner2 \\ -clock_path [get_clocks -mode mode1] To set the same maximum capacitance constraint for different corners associated with a specific mode, use the following command: fc_shell> set_max_capacitance 0.6 \\ -clock_path [get_clocks -mode mode2] \\ -corners [get_corner \\ [get_attribute [get_modes mode2] associated_corners]] Fusion Compiler User Guide 356 Chapter 5: Clock Tree Synthesis Specifying the Clock Tree Synthesis Settings Feedback"}
{"header": "Reporting Shielding Information", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "After you run the create_shields command, you can Query the shield shapes associated with a shielded net by using the get_shapes -shield_only command, as described in Querying Shield Shapes Report the shielding statistics by using the report_shields command, as described in Reporting Shielding Statistics"}
{"header": "Generating Verification Checkpoints During Compilation", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can generate intermediate verification checkpoints during the compile_fusion command, which you can use in the Formality tool to provide a netlist snapshot of the synthesis design state and verify the intermediate netlists. Verification checkpointing allows the Fusion Compiler and Formality tools to synchronize on an intermediate netlist and in turn results in higher completion rates and better QoR. To enable verification checkpointing, use the set_verification_checkpoints command as shown in the following example: fc_shell> set_verification_checkpoints Enabling checkpoint \"ckpt_logic_opt\" Enabling checkpoint \"ckpt_pre_map\" When you enable this feature, by default, the compile_fusion command generates verification checkpoints before mapping and during logic optimization, and the corresponding verification-checkpoint stages are named ckpt_pre_map and ckpt_logic_opt . You can enable verification checkpointing at only one stage as shown in the following example: fc_shell> set_verification_checkpoints {ckpt_logic_opt} Disabling checkpoint \"ckpt_pre_map\" Enabling checkpoint \"ckpt_logic_opt\" At each verification checkpoint, the tool automatically generates a checkpoint netlist and the guide_checkpoint command in the .svf file that is used by the Formality tool during verification."}
{"header": "Command", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The following topics describe how you can control the multibit optimization performed during the clock_opt command: Enabling the Rewiring of Mixed-Drive-Strength Multibit Cells Enabling Post-Clock-Tree-Synthesis Multibit Debanking Enabling the Rewiring of Mixed-Drive-Strength Multibit Cells Some logic libraries have mixed-drive-strength multibit cells where some bits have a higher drive strength than others. For designs that use such cells, if a violating path goes through a lower-drive-strength bit, the tool can rewire the mixed-drive-strength multibit cell such that the violating path goes through a higher-drive-strength bit. To enable this feature for the clock_opt command, set the clock_opt.flow.enable_multibit_rewiring application option to true Enabling Post-Clock-Tree-Synthesis Multibit Debanking To improve the timing QoR, the clock_opt command can debank multibit registers during the final_opt stage, if doing so does not introduce hold timing violations. To enable this feature, set the clock_opt.flow.enable_multibit_debanking application option to true before you run the final_opt stage of the clock_opt command."}
{"header": "Reading the Design", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Before you read a design, you must create or open the design library associated with the design, as described in Setting Up Libraries The tool can read RTL designs in SystemVerilog, Verilog, or VHDL and gate-level netlists in Verilog format. Use the following methods to read designs: Reading RTL Files in SystemVerilog, Verilog, or VHDL Format Reading Designs Using the -autoread Option Reading Designs Using the VCS Command-line Options Reading Verilog Gate-Level Netlist Files Reading Mixed Gate-Level Netlists and RTL Files Fusion Compiler User Guide 98 Chapter 2: Preparing the Design Reading the Design Feedback By default, when the tool reads the RTL or gate-level netlist files, it creates a block in the current design library and increments its open count. The tool determines the top-level module of the block by identifying the module that is not instantiated by any other modules in the specified files and uses the top-level module name as the block name. Use the following commands to work with blocks: create_block : Creates a block open_block : Opens an existing block current_block : Sets or reports the current block save_block : Saves a block close_blocks : Closes a block See Also Blocks Working With Design Libraries"}
{"header": "Creating Floating Logical Supply Nets", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "A floating logical supply net is a power or ground net that is not connected to any logical pin or port in the block. For example, a power feedthrough net created during power planning is a floating supply net. To create a floating supply net with the connect_pg_net command, use the following steps: 1. Specify the supply net type in the UPF file by using the supply_net_pg_type attribute, as shown in the following UPF file example: create_supply_net VDD set_design_attributes -elements VDD \\ -attribute supply_net_pg_type power 2. Enable floating supply nets by setting the mv.pg.create_floating_pg application option to true before you create supply nets with the connect_pg_net command, as shown in the following script example: # Apply the UPF load_upf $upf_input_file_name commit_upf # create logical supply nets set_app_options -as_user_default \\ -name mv.pg.create_floating_pg -value true connect_pg_net -automatic check_mv_design The tool creates the logical supply nets in the topmost hierarchy of the current UPF scope for domain-independent supply nets. For domain-dependent supply nets, the tool creates the logical supply nets in the topmost hierarchy of the domain. The tool does not create a logical supply net in the following situations: There is a conflict between the connection and the supply net type specified with the supply_net_pg_type attribute. The supply net is connected to a PG pin of an instance. The connect_pg_net command is not specified in the current or parent physical hierarchy. Fusion Compiler User Guide 119 Chapter 2: Preparing the Design Setting Up Multivoltage Designs Feedback"}
{"header": "Creating Abstracts for Signal Electromigration Analysis", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To create an abstract that can be used for signal electromigration analysis at the top-level, set the abstract.enable_signal_em_analysis application option to true before you run the create_abstract command."}
{"header": "Controlling Register Replication", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can perform logic optimization by running the compile_fusion -to logic_opto command. To identify registers that you want the tool to replicate during logic optimization, use the set_register_replication command. This command sets the register_replication attribute on the specified registers and improves the timing by balancing fanout. During logic optimization, the specified registers are replicated and the loads of the original registers are evenly distributed among the new replicated registers when the -num_copies option is used. When you use the -max_fanout option, the tool computes the number of copies and attempts to distribute loads evenly without violating the maximum fanout constraints. You can control the number of copies that are created by using one of the following methods: Specify the total number of registers after replication, including the original, by using the -num_copies option. Specify the maximum fanout of the replicated registers by using the -max_fanout option. If you specify both options, the -max_fanout option is ignored. The following example specifies that the tool should replicate the regA and regB registers by creating one additional copy of each register: fc_shell> set_register_replication -num_copies 2 regA fc_shell> set_register_replication -num_copies 2 regB Figure 33 shows the regA and regB registers before and after optimization. Figure 33 Before and After Register Replication r1 r2 r3 Out1 Out2 r1 r2 r3 RegB regA RegA regB regA regB Out2 Out1 Fusion Compiler User Guide 238 Chapter 3: Physical Synthesis Controlling Mapping and Optimization Feedback You can include logic in the fanin or fanout of the specified register by using the -include_fanin_logic or -include_fanout_logic option. You can specify any startpoint in the fanin or endpoint in the fanout of the register. The following example specifies that the tool should replicate the A_reg register and the logic in the path from this register to the U1 cell: fc_shell> set_register_replication -num_copies 2 A_reg \\ -include_fanout_logic U1 To specify endpoint registers or primary output ports that must be driven by the original register after replication, as shown in Figure 34 , use the -driven_by_original_register option. The following example specifies that after replication, the r0 register must drive the r1, r2, and r3 registers: fc_shell> set_register_replication -num_copies 3 r0 \\ -driven_by_original_register {r1 r2 r3} Figure 34 Using the -driven_by_original_register Option r0 r1 r2 r3 Out1 Out2 Out3 r0 r1 r2 r3 Out1 Out2 Out2 r0_rep1 r0_rep2"}
{"header": "Self-Gating Optimization", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The tool supports self-gating optimization, which occurs at the compile_fusion command. This feature reduces dynamic power consumption by turning off the clock signal of certain registers during clock cycles when the data remains unchanged. Fusion Compiler User Guide 328 Chapter 4: Clock Gating Self-Gating Optimization Feedback Figure 66 Example of a Self-Gating Cell CLK Registers with an enable condition that cannot be inferred from the existing logic can only be gated using the self-gating technique. They cannot be gated using traditional clock gating. By default, the tool supports self-gating only on registers that are not gated. You can use the set_self_gating_options command to allow self-gating on these registers. However, the time duration that the clock signal is turned off might increase for these registers,. To ensure QoR improvements, the self-gating algorithm takes timing and power into consideration. A self-gating cell is inserted for the registers if There is enough timing slack available in the register's data pin. For designs with multiple scenarios, the algorithm considers the timing of the worst case among active scenarios enabled for setup. Internal dynamic power of the circuit is reduced. For designs with mutiple scenarios, the algorithm uses the average internal dynamic power among active scenarios enabled for dynamic power. To minimize the area and power overhead, a self-gating cell can be shared across a few registers by creating a combined enable condition with a tree of comparator cells. If the self-gated registers are driven by synchronous set or synchronous clear signals, these signals are also included in the construction of the enable signal so that the circuit remains functionally unchanged. Figure 67 is an example of a self-gating cell that is shared across two registers (4 bits). Note that one of the self-gated registers is a multibit register and the other register is a single-bit register. The tool can also self-gate a group of multibit registers or a group of single-bit registers. Fusion Compiler User Guide 329 Chapter 4: Clock Gating Self-Gating Optimization Feedback Figure 67 Self-Gating Tree CLK D0 Q0 D2 Q2 D1 Q1 EN The tool does not support the following types of sequential cells for self-gate insertion: Level-sensitive sequential cells Level-sensitive scan design registers Master-slave flip-flops Retention registers Single-bit and multibit registers that belong to shift registers Multibit registers with multiple clock paths For more information, see the following topics: Self-Gating Flow Library Requirements for Self-Gating Setting Up for Self-Gating Reporting and Querying Self-Gating Cells"}
{"header": "Mitigating Design Mismatches", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "During early design development, frequent design updates can cause incomplete or inconsistent data, such as pin mismatches between a block-level design and the reference to it from a top-level design. To enable the tool to successfully link a block even if it has certain types of design mismatch, set a mismatch configuration for the block. By default, the tool cannot link any block with inconsistent or mismatching data. When you set mismatch configurations, the tool either ignores or fixes several different types of mismatching data and continues the linking process. Blocks linked with mismatching data can be used only for feasibility analysis. To learn how to mitigate design mismatches, see the Fusion Compiler Data Model User Guide"}
{"header": "Improving the Repeater Levels in Clock Tree", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The tool supports clock level improvement which ensures considering level improvement as a metric while building the clock trees and also considers buffering solutions which helps to improve the repeater levels. With lesser buffer trees chosen the level improvement takes place locally which further helps to improve the metric for overall clock tree. Figure 81 Improving the Repeater Levels in Clock Tree To enable clock level improvement, set the cts.buffering.reduce_clock_level_effort application option to high before the build_clock stage of the clock_opt command."}
{"header": "and Clock Routing", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "A via ladder is a stacked via that starts from the pin layer and extends into an upper layer where the router connects to it. Via ladders reduce the via resistance, which can improve performance and electromigration robustness. The via ladder insertion flow during clock tree synthesis, optimization, and clock routing consists of the following steps: 1. Ensure that the via ladder rules are defined as described in Defining Via Ladder Rules 2. Specify the via ladders that can be used for specific library pins by using the set_via_ladder_candidate command, as described in Specifying Via Ladder Candidates for Library Pins 3. Define the via ladder constraints by using the set_via_ladder_rules command, as described in Defining Via Ladder Constraints 4. Enable high-performance and electromigration via ladder insertion for critical paths during the clock_opt command by setting the opt.common.enable_via_ladder_insertion application option to true 5. Perform clock tree synthesis and optimization by using the clock_opt -to build_clock command. 6. Insert the via ladders by using the insert_via_ladders command, as described in Inserting Via Ladders 7. Route the clock nets by using the clock_opt -from route_clock command. Fusion Compiler User Guide 391 Chapter 5: Clock Tree Synthesis Implementing Clock Trees and Performing Post-CTS Optimization Feedback"}
{"header": "Creating Abstracts With Power Information", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To create an abstract that contains power information of the corresponding block, use the following steps at the block level: 1. Activate the scenarios for which you want to perform power analysis by using the -active true option of the set_scenario_status command and enable them for power analysis by using the following options: -dynamic_power true for dynamic power analysis -leakage_power true for leakage power analysis Power information is stored only for active scenarios that are enabled for dynamic or leakage power. 2. (Optional) Apply switching activity by either reading in a SAIF file with the read_saif command or annotating the switching activity information on the nets with the set_switching_activity command. For more information about applying switching activity, see Annotating the Switching Activity Fusion Compiler User Guide 834 Chapter 11: Hierarchical Implementation Creating Abstract Views Feedback 3. Store the power information in the abstract by setting the abstract.annotate_power application option to true 4. Create the abstract for the block by using the create_abstract command. When you create an abstract with power information, the tool stores the power information only for the logic that is removed. When you instantiate such an abstract and perform power analysis at the top level, the tool Recomputes the power for the interface logic in the abstract, in context, based on the switching activity and loading seen at the top level Uses the stored power in the abstract for the logic that was removed when the abstract was created To report the power information in an abstract instantiated at the top level, use the report_power -blocks command. If there are multiple levels of physical hierarchy, to specify the number of level for which you want to report, use the -levels option."}
{"header": "Viewing Density Heat Maps in the GUI", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "After running the signoff_report_metal_density command, you can view heat maps in the GUI for both the minimum density and gradient density reports. Note: The signoff_report_metal_density command generates the heat maps only when the signoff.report_metal_density.create_heat_maps application option is set to true To display the minimum density heat map, choose View > Map > ICV Metal Fill Density Figure 151 shows a minimum density heat map. In this heat map, each colored tile corresponds in size to the density window step. To customize or standardize the density values in the heat map, set the bin range, which is indicated by a red oval in the figure. Fusion Compiler User Guide 737 Chapter 8: IC Validator In-Design Inserting Metal Fill With IC Validator In-Design Feedback Figure 151 Minimum Density Heat Map To display the density gradient heat map, choose View > Map > ICV Metal Fill Gradient Fusion Compiler User Guide 738 Chapter 8: IC Validator In-Design Inserting Metal Fill With IC Validator In-Design Feedback Figure 152 shows a density gradient heat map. In this heat map, each colored bar corresponds in size to the gradient window size. Figure 152 Density Gradient Heat Map"}
{"header": "Preventing Off-Grid Routing", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, wires and vias need to be aligned to the wire track grid for a metal layer only if the onWireTrack or onGrid attribute is set to 1 in its Layer section in the technology file. To override the technology file settings, set the following application options: route.common.wire_on_grid_by_layer_name This option controls off-grid routing for metal layers. route.common.via_on_grid_by_layer_name This option controls off-grid routing for via layers. Use the following syntax to set these options: { { layer true|false} ... } Specify the layers by using the layer names from the technology file. Specify true to forbid off-grid routing and false to allow off-grid routing. If you use either of these options, the tool ignores all settings for the onWireTrack and onGrid attributes in the technology file and uses only the settings specified by these options. If you do not specify a layer in these options, off-grid routing is allowed on that layer, regardless of the setting in the technology file. For example, to prevent off-grid routing for wires on the M2 and M3 metal layers and for vias on the V2 via layer, regardless of the settings in the technology file, use the following commands: fc_shell> set_app_options \\ -name route.common.wire_on_grid_by_layer_name \\ -value {{M2 true} {M3 true}} fc_shell> set_app_options \\ -name route.common.via_on_grid_by_layer_name \\ -value {{V2 true}} Fusion Compiler User Guide 510 Chapter 6: Routing and Postroute Optimization Routing Constraints Feedback"}
{"header": "Removing Filler Cells", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "Filler cells inserted by the Fusion Compiler tool have instance names that start with the string xofiller . To remove all the filler cells from a block, use the remove_cells command, as shown in the following example: fc_shell> remove_cells [get_cells xofiller*] If you used the standard filler cell insertion flow and want to remove only those filler cells with DRC violations, use the remove_stdcell_fillers_with_violation command, as described in Checking for Filler Cell DRC Violations"}
{"header": "Measuring Quality of Results", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To measure the quality of results (QoR) of the design in the current state and store the quality information in a set of report files, use the create_qor_snapshot command. You can capture the QoR information using different optimization strategies or at different stages of the design and compare the quality of results. The create_qor_snapshot command measures and reports the quality of the design in terms of timing, design rules, area, power, congestion, and so on. It stores the quality information into a set of snapshot files in a directory named snapshot under the current working directory. To store the quality information in a different directory, use the time.snapshot_storage_location application option. The following example generates a QoR snapshot named r1 using zero wire load for timing paths in the snapshot directory: fc_shell> create_qor_snapshot -name r1 -zero_wire_load ... No. of scenario = 4 s1 = function s2 = function_min s3 = test s4 = test_min Fusion Compiler User Guide 267 Chapter 3: Physical Synthesis Performing Design Analysis Feedback ------------------------------------------------------------------------ --- WNS of each timing group: s1 s2 s3 s4 ------------------------------------------------------------------------- REGIN -0.34 - - - fref_clk0 2.34 3.25 - - pld_clk 0.65 1.65 - - pll_fixed_clk_central 0.61 1.65 - - REGOUT 0.39 0.44 1.18 1.72 ... ------------------------------------------------------------------------- Setup WNS: -0.34 0.44 1.02 1.10 -0.34 Setup TNS: -130.82 0.00 0.00 0.00 -130.82 Number of setup violations: 1152 0 0 0 1152 Hold WNS: -0.55 -0.78 -0.30 -1.28 -1.28 ... ------------------------------------------------------------------------- Area: 1200539.606 Cell count: 562504 Buf/inv cell count: 145920 Std cell utilization: 0.24 ... Querying QoR Snapshots To retrieve and report the snapshots created by the create_qor_snapshot command, use the query_qor_snapshot command. The query_qor_snapshot command analyzes the QoR timing reports previously generated and displays the results in HTML format according to the specified filters. In this example, the query_qor_snapshot command analyzes the placeopt snapshot that is stored in the snapshot directory and then reports the timing paths with worst negative slack values between -2.0 ns and -1.0 ns: fc_shell> create_qor_snapshot -name placeopt fc_shell> query_qor_snapshot -name placeopt -filters \"-wns -2.0,-1.0\" Reporting QoR Snapshots To display QoR information and statistics for the current design, use the report_qor command. For example, the following command displays the r1 QoR snapshot that is stored in the snapshot directory: fc_shell> report_qor_snapshot -name r1 -display Removing QoR Snapshots To remove an existing QoR snapshot from the directory specified by the time.snapshot_storage_location application option, use the remove_qor_snapshot Fusion Compiler User Guide 268 Chapter 3: Physical Synthesis Performing Design Analysis Feedback command. For example, the following command removes the preroute QoR snapshot that is stored in the snapshot directory: fc_shell> remove_qor_snapshot -name preroute"}
{"header": "Reading DEF Files", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To read the floorplan information from a DEF file, use the read_def command. fc_shell> read_def block .def Note: When possible, use DEF v5.8 or later, as this version supports more types of physical objects and obstructions than previous versions. By default, the read_def command Annotates the floorplan information onto the current block To annotate the information onto a different block, use the -design option to specify the block name. Preserves the existing floorplan information In incremental mode, The placement area is imported based on the current core area and site rows in the DEF files Physical constraints that can have only one value are overwritten by the value from the latest DEF file; for example, port location and macro location are overwritten. Physical constraints that can have accumulated values are recomputed; that is, core area can be recomputed based on the existing value and the site row definitions in the latest DEF file. Placement keepouts from different DEF files are accumulated and the final keepout geometry is computed internally during synthesis. To remove the existing floorplan information before annotating the floorplan information from the DEF file, use the -no_incremental option. In this mode, the placement area is imported based on the site rows in the DEF files. Uses rule-based name matching for macros and ports Fusion Compiler User Guide 104 Chapter 2: Preparing the Design Importing the Floorplan Information Feedback Rule-based name matching automatically resolves name differences by using the tool's intelligent name matching capability. By default, when rule-based name matching is enabled, the following characters are considered equivalent: Hierarchical separators { / _ . } For example, a cell named a.b_c/d_e is automatically matched with the string a/b_c.d/e in the DEF file. Bus notations { [ ] __ ( ) } For example, a cell named a [4] [5] is automatically matched with the string a_4__5_ in the DEF file. To disable rule-based name matching and require exact name matches between the DEF file and the block, set the file.def.rule_based_name_matching application option to false For more information, see \"Rule-Based Name Matching\" in the Fusion Compiler Data Model User Guide Ignores any objects in the DEF file that do not exist in the block, except for PG objects To allow new non-PG objects to be created from the DEF file, use the -add_def_only_objects option to specify the types of objects to create. Specify one or more of the following keywords: cells The tool creates the cells that exist only in the DEF file and connects their power and ground pins as defined in the DEF file; it does not connect the signal, clock, or tie pins even if these connections are defined in the DEF file. The tool also does not create new hierarchical cells; any hierarchy specified in the DEF file must already exist in the block. nets The tool creates the signal, clock, and tie nets that exist only in the DEF file and connects them to the ports specified in the DEF PINS section; it does not connect the nets to any other ports or pins in the netlist even if these connections Fusion Compiler User Guide 105 Chapter 2: Preparing the Design Importing the Floorplan Information Feedback are defined in the DEF file. The tool does not create new hierarchical nets; any hierarchy specified in the DEF file must already exist in the block. ports The tool creates the signal, clock, and tie ports that exist only in the DEF file and connects them to the nets specified in the DEF PINS section. all The tool creates the non-PG cells, nets, and ports that exist only in the DEF file, as if you had specified cells nets , and ports"}
{"header": "Controlling Congestion-Driven Restructuring During Placement", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, the tool restructures nets to reduce congestion during The create_placement command, except when you use the -timing_driven option The initial_place stage of the compile_fusion command You can control the congestion-driven restructuring as follows: Specify an effort level by setting the place.coarse.cong_restruct_effort application option to low medium (default), high , or ultra Prevent the tool from increasing the path depth by more than three levels of logic by setting the place.coarse.cong_restruct_depth_aware application option to true"}
{"header": "Considering Wide Cell Density During Placement", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "If a cell cannot straddle the vertical power straps and the width of the cell is more than half the pitch of the power straps, only one such cell can be placed between the power straps. Therefore, during placement, the tool must minimize the density of such wide cells to ensure that they can be placed and legalized without large displacements. For advanced technology nodes with wide cells, enable wide-cell modeling during placement by setting the place.coarse.wide_cell_use_model application option to true"}
{"header": "Generating Rail Analysis Script Files", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can run the analyze_rail -script_only command to generate the settings required for running rail analysis based on the information in the design library without actually executing the analysis run. The analyze_rail -script_only command writes data to the working directory. The output files that are saved to the directory are Table 67 Output data when running analyze_rail -script_only File Name Description RedHawk RedHawk-SC RedHawk GSR file Contains configuration settings for running RedHawk Fusion rail analysis Yes No LEF/DEF, SPEF, and STA files Generated if you do not specify these input files before running the analyze_rail command Yes Yes RedHawk Fusion run script file (analyze_rail.tcl) Includes the commands that are required for running rail analysis Yes No RedHawk-SC Fusion run script file (analyze_rail.py) Includes the python commands that are required for running rail analysis No Yes Fusion Compiler User Guide 880 Chapter 12: RedHawk and RedHawk-SC Fusion Preparing Design and Input Data for Rail Analysis Feedback"}
{"header": "Specifying the Boundary Cell Insertion Requirements", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To specify the boundary cell insertion requirements, use the set_boundary_cell_rules command. You use this command to specify the following requirements: The library cells to use for the boundary cells, as described in Specifying the Library Cells for Boundary Cell Insertion The rules used to place the boundary cells, as described in Specifying Boundary Cell Placement Rules The naming convention used for the inserted cells, as described in Specifying the Naming Convention for Boundary Cells The creation of routing guides to honor the metal cut allowed and forbidden preferred grid extension rules, as described in Creating Routing Guides During Boundary Cell Insertion Fusion Compiler User Guide 593 Chapter 7: Chip Finishing and Design for Manufacturing Performing Boundary Cell Insertion Feedback Note: This feature is supported only by the compile_boundary_cells command; it is not supported by the compile_targeted_boundary_cells command. The creation of placement blockages to honor the minimum jog and minimum separation rules, as described in Creating Placement Blockages During Boundary Cell Insertion Note: This feature is supported only by the compile_boundary_cells command; it is not supported by the compile_targeted_boundary_cells command. Note: The settings specified by the set_boundary_cell_rules command are saved in the design library. See Also Reporting the Boundary Cell Insertion Requirements"}
{"header": "Performing Effective Resistance Analysis", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "Note: Effective resistance analysis is supported in both RedHawk Fusion and RedHawk-SC Fusion analysis flows. To calculate effective resistance for the specified power and ground nets, use the analyze_rail -effective_resistance command. To specify a list of cell instances for effective resistance calculation, describe the target instances in a text file. Then specify this text file with the rail.effective_resistance_instance_file application option. For example, fc_shell> sh cat cell_list.txt u_GS_PRO_65 u_GS_PRO_64 ChipTop_U_compressor_mode/U3 fc_shell> set_app_options \\ -name rail.effective_resistance_instance_file \\ -value cell_list.txt fc_shell> analyze_rail -nets {VDD VSS} -effective_resistance You can perform effective resistance analysis before or during voltage drop analysis. When the analysis is completed, the tool writes the effective resistance values into the same rail result with the voltage drop results. Note: In the RedHawk-SC rail analysis flow, you must specify both the -effective_resistance and -voltage_drop options for effective resistance calculation. When the calculation is complete, the tool saves the results in the working directory. To write the effective resistance values to a text file, use the report_rail_result -type effective_resistance command. To query the resistance value, use the get_attribute command. For example, fc_shell> get_attribute [get_pins u_GS_PRO_65/VDD] \\ effective_resistance Fusion Compiler User Guide 914 Chapter 12: RedHawk and RedHawk-SC Fusion Performing Distributed RedHawk Fusion Rail Analysis Feedback See Also Specifying RedHawk and RedHawk-SC Working Directories Writing Analysis and Checking Reports"}
{"header": "Removing Multicore Configurations", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To remove the multicore configurations defined by the set_host_options command, use the remove_host_options command. To remove all multicore configurations, use the -all option. To remove a specific multicore configuration, specify the configuration name with the -name option. Fusion Compiler User Guide 67 Chapter 1: Working With the Fusion Compiler Tool Enabling Multicore Processing Feedback"}
{"header": "Controlling the Optimization of Relative Placement Cells", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "When a relative placement cell is modified or moved, the relative placement structure can be disturbed. When a relative placement cell is removed during optimization, the relative Fusion Compiler User Guide 805 Chapter 10: Physical Datapath With Relative Placement Specifying Options for Relative Placement Groups Feedback placement information of the instance is also removed, disrupting the relative placement structure. To preserve the relative placement structures during various postplacement optimization processes, use the -optimization_restriction option with the set_rp_group_options command and specify the appropriate setting as shown in Table 60 Table 60 Settings for the -optimization_restriction Option To do this Use this setting Allow unrestricted optimization of the relative placement cells all_opt Allow only sizing of the relative placement cells size_only Allow only in-place sizing of the relative placement cells size_in_place Prevent any optimization of the relative placement cells no_opt For a hierarchical relative placement group, the -optimization_restriction option setting applied to the top level is propagated to the lower-level groups and any settings applied to the lower-level groups are ignored."}
{"header": "Cleaning Up Routed Nets", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "After routing is complete, you can clean up the routed nets by running the remove_redundant_shapes command. fc_shell> remove_redundant_shapes By default, this command reads the DRC information stored in the design view of the block and then removes dangling and floating net shapes from all nets in the block based on this information. To run the check_routes command to get the DRC information instead of using the information stored in the design view, use the -initial_drc_from_input false option. You can restrict the removal to Specific nets by using the -nets option Specific layers by using the -layers option Fixed or unfixed route types by using the -route_types option When removing dangling net shapes, the tool does not change topologies or connections and does not touch terminals. In addition, no changes are made to open nets or nets with DRC violations. You can disable the removal of dangling net shapes by using the -remove_dangling_shapes false option. You can disable the removal of floating net shapes by using the -remove_floating_shapes false option. In addition to removing dangling and floating net shapes, this command can also remove loops in the specified nets. To remove loops, use the -remove_loop_shapes true option. By default, the remove_redundant_shapes does not report the changes it makes. To report the changes, use the -report_changed_nets true option. For example, to remove dangling net shapes, floating net shapes, and loops from the net named my_net, use the following command: fc_shell> remove_redundant_shapes -nets my_net \\ -remove_loop_shapes true After cleaning up the routed nets, reverify the routing, as described in Performing Design Rule Checking Using Zroute Fusion Compiler User Guide 563 Chapter 6: Routing and Postroute Optimization Analyzing the Routing Results Feedback"}
{"header": "Viewing Multibit Components in the GUI", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Fusion Compiler uses the WordView infrastructure to map multibit components. To view multibit components in the GUI, you must complete the following requirements: Ensure the library contains multibit components in .ndm format. Enable multibit component mapping by setting the compile.flow.enable_multibit application option as follows: fc_shell> set_app_options -name compile.flow.enable_multibit \\ -value true Follow these steps to view multibit components in WordView: 1. Read the RTL by using the analyze and elaborate commands. 2. Run the compile_fusion -to initial_opto command. The tool maps the bused registers to multibit components during compile. 3. (Optional) Check the multibit component mapping information by using the report_cells command. For example, The RTL contains the reg_state bused register. Fusion Compiler User Guide 252 Chapter 3: Physical Synthesis Performing Multibit Optimization Feedback module top (...); output [2:0] reg_state; always @(posedge clk) reg_state <= next_reg_state; endmodule The report shows that the reg_state bus register is mapped to the MB_DFF multibit component. fc_shell> report_cells [get_cells *reg_state_reg* -hierarchical] ... Cell Reference Library Attributes --------------------------------------------------------------- reg_state_reg[2:0] MB_DFF my_mb_lib n"}
{"header": "Preserving Pin Names During Sizing", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, optimization can change the pin names of leaf cells during sizing if the functionality of the resulting circuit is equivalent. The Fusion Compiler tool automatically updates its version of the internal constraints to reflect the new pin name if the pin is part of an exception constraint. If this occurs, it means that the original constraints used to constrain the block in the Fusion Compiler tool cannot be used for signoff purposes; instead, you must write out the constraints from the Fusion Compiler tool and include these constraints with the resulting block. This behavior provides the optimization engine with the most flexibility to select cells and improve the cost functions. You can restrict this sizing capability so that the constraints remain unchanged through optimization by setting the opt.common.preserve_pin_names application option. This application option defaults to the setting of never , and accepts values of either never or always Fusion Compiler User Guide 174 Chapter 2: Preparing the Design Controlling the Optimization of Cells, Nets, Pins, and Ports Feedback To restrict sizing to pin-name equivalent cells, use the following command: fc_shell> set_app_options \\ -name opt.common.preserve_pin_names -value always To restore the default behavior, use the following command: fc_shell> set_app_options \\ -name opt.common.preserve_pin_names -value never"}
{"header": "Placing Group Repeaters Before Routing", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Use the preplace_group_repeaters command to place the group repeaters before the routing. This command places the group repeaters either in an ascending or descending order, default is ascending. The ascending order means that the command places the cells in a group from the lowest or left-most available track to the highest or right-most track. Note: A FAA-Base-Beta license is required to run the preplace_group_repeaters command. You must specify either the cell collections or group IDs of the group repeaters. The following example places group repeaters when the cell collections are specified. fc_shell> preplace_group_repeaters \\ -repeater_group_locations { { $cellGroup1, M2, {720 363.5}, \\ north, descending} {$cellGroup2, M2, {920 363.5}, east, ascending} \\ Fusion Compiler User Guide 984 Chapter 13: ECO Flow Adding a Group of Repeaters Feedback {$cellGroup3, M2, {1230 328.5}, east, ascending} \\ {$cellGroup4, M2, {1430 328.5}}, east} The following example places group repeaters when the group ID is specified. fc_shell> preplace_group_repeaters \\ -repeater_group_locations { { 1,M2, {720 363.5}, south, ascending} \\ {2, M2, {920 363.5},west, ascending} {3, M2, {1230 328.5}, \\ south, ascending} {4, M2, {1430 328.5}, west, descending}}"}
{"header": "Routing Clock Nets", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "To route clock nets before routing the rest of the nets in the block, use the route_group command with the appropriate option to select the nets. To route all clock nets, use the -all_clock_nets option. To route specific clock nets, use the -nets option. For example, to route all clock nets, use the following command: fc_shell> route_group -all_clock_nets The route_group command runs global routing, track assignment, and detail routing on the clock nets. When routing clock nets, the route_group command uses A-tree routing to minimize the distance between each pin and driver. When routing clock mesh nets, by default, the route_group command uses Steiner routing, which minimizes the total wire length. To use comb routing, set the route.common.clock_topology application option to comb before routing the clock mesh nets. By default, if the block contains existing global routes, the route_group command ignores them during global routing. To perform incremental global routing by reusing existing global routes, use the -reuse_existing_global_route true option. If the block contains existing detail routes for the clock nets, the route_group command performs incremental detail routing. By default, the detail router performs a maximum of 40 search and repair iterations. To modify the maximum number of detail routing iterations, use the -max_detail_route_iterations option. Note: Zroute stops before completing the maximum number of iterations if it determines that all violations have been fixed or that it cannot fix the remaining violations. Fusion Compiler User Guide 520 Chapter 6: Routing and Postroute Optimization Routing Critical Nets Feedback"}
{"header": "Allowing Repeater Groups Over Macros", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Use the -allow_insertion_over_block option to allow repeater groups to be added on top of soft or hard macros. Note: If the repeater cell is an inverter, you are responsible for ensuring logical correctness. Fusion Compiler User Guide 986 Chapter 13: ECO Flow Adding a Group of Repeaters Feedback"}
{"header": "Setting Size-Only Settings", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To set a size-only setting on a cell, use the set_size_only command. The following command sets a size-only setting on a cell: fc_shell> set_size_only [get_cells cell_name ] true To report all the size-only settings set on the current block, use the report_size_only command. fc_shell> report_size_only -all"}
{"header": "Basic Zroute Flow", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "Figure 99 shows the basic Zroute flow, which includes clock routing, signal routing, DFM optimizations, and route verification. Figure 99 Basic Zroute Flow Fusion Compiler User Guide 441 Chapter 6: Routing and Postroute Optimization Prerequisites for Routing Feedback"}
{"header": "Finding Invalid Taps", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To find taps that fail the validity checking, use the get_taps command to report the taps that have is_valid_location attribute set to false For example, fc_shell> get_attribute [ get_taps Tap_1437 ] is_valid_location false"}
{"header": "Performing Wire Spreading", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "After you have performed detail routing and redundant via insertion, you can perform wire spreading to increase the average spacing between wires, which reduces the critical area short faults and therefore improves yield. To perform wire spreading, use the spread_zrt_wires comandcomandspread_zrt_wires spread_wires command. By default, the spread_wires command uses the following settings to spread the signal wires on the same layer: To perform wire spreading, use the spread_zrt_wires comandcomandspread_zrt_wires spread_wires command. By default, the spread_wires command uses the following settings to spread the signal wires on the same layer: Spreads the wires by half a pitch in the preferred direction To modify the spread distance, use the -pitch option. You specify the spread distance as a multiplier for the layer pitch. For example, to specify a spread distance of 1.5 times the layer pitch, use the following command: fc_shell> spread_wires -pitch 1.5 Uses twice the layer pitch as the minimum jog length To modify the minimum jog length, use the -min_jog_length option. You specify the minimum jog length as an integer multiple of the layer pitch. Uses the minimum layer spacing plus one half the layer pitch as the minimum jog length To modify the minimum jog spacing, use the -min_jog_spacing_by_layer_name option. You specify the minimum jog spacing in microns for each layer. The tool uses the default jog spacing for any unspecified layers. Figure 126 shows how the jog length and jog spacing values are used in wire spreading. Figure 126 Wire Spreading Results Fusion Compiler User Guide 633 Chapter 7: Chip Finishing and Design for Manufacturing Reducing Critical Areas Feedback In the following example, the minimum jog length is set to three times the layer pitch, the minimum jog spacing for the M1 layer is set to 0.07 microns, and the minimum jog spacing for the M2 layer is 0.08 microns. All other metal layers use the default minimum jog spacing. fc_shell> spread_wires -min_jog_length 3 \\ -min_jog_spacing_by_layer_name {{M1 0.07} {M2 0.08}} After spreading, the spread_wires command performs detail routing iterations to fix any DRC violations caused as a result of spreading. When you change the layout, it can change the timing of your block. Wire spreading has a timing-preservation mode that allows you to perform wire spreading without affecting the block timing. To enable timing-preservation mode for wire spreading, define the timing preservation constraints by using the following options with the spread_wires command: -timing_preserve_setup_slack_threshold threshold -timing_preserve_hold_slack_threshold threshold -timing_preserve_nets nets The threshold values are floating-point numbers in library units. Wire spreading is performed only on nets with slack greater than or equal to the specified values or the nets specified in the -timing_preserve_nets option, as well as adjacent nets on the same layer within two routing pitches."}
{"header": "Controlling the Tiling Within Relative Placement Groups", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To control the tiling of objects within a relative placement group, use the set_rp_group_options -tiling_type command with the settings shown in the following table. Table 58 Controlling Placement With the set_rp_group_options -tiling_type Command To do this Use this setting Tile objects in a bit-slice pattern and preserve both the row and column alignment. The height of a row is determined by the tallest object in the row The width of a column is determined by the widest object in the column bit_slice (Default) Horizontally compress the objects in each row and maintain row alignment. horizontal_compression Vertically compress the objects in each column and preserve the column alignment vertical_compression Fusion Compiler User Guide 800 Chapter 10: Physical Datapath With Relative Placement Specifying Options for Relative Placement Groups Feedback Figure 180 Bit-Slice Placement Versus Horizontal or Vertical Compression Bit-slice placement Vertical compression Horizontal compression The setting of the -tiling_type option is not propagated from a parent group to child groups."}
{"header": "Special Naming and Querying for DFT Wrapper Clock Gates", "size": 20.0, "font": "Arial-BoldMT", "flags": 20, "text": "DFT wrapper clock gates refer to those clock gates that drive only DFT wrapper cells. The clock gating engine prefixes dft_wrapper_ to the names of all DFT wrapper clock gates Fusion Compiler User Guide 334 Chapter 4: Clock Gating Special Naming and Querying for DFT Wrapper Clock Gates Feedback clock gates irrespective of their origin. This helps to identify specific clock gates driving wrapper cells during automatic test pattern generation (ATPG). Table 24 Commands and their expected return values Command Expected Return Value get_clock_gates -gating_wrapper_cells_only (Returns all clock gates that drive wrapper cells only) dft_wrapper_ICG and dft_wrapper_clock_gate_reg get_clock_gates -gating_wrapper_cells_only -origin tool_inserted (Returns only tool inserted clock gates that drive wrapper cells only) dft_wrapper_clock_gate_reg only get_clock_gates -gating_wrapper_cells_only -origin pre_existing (Returns only pre-existing clock gates that drive wrapper cells only) dft_wrapper_ICG only get_clock_gates {ICG clock_gate_reg} -gating_wrapper_cells_only empty string denoting that both the clock gates are not gating the wrapper cells get_clock_gates {ICG dft_wrapper_clock_gate_reg} -gating_wrapper_cells_only (Returns clock gates that only drive wrapper cells from given cells within the { } brackets) dft_wrapper_clock_gate_reg get_clock_gates {*clock_gate_reg} -gating_wrapper_cells_only (Returns clock gates that only drive wrapper cells and match the given pattern within the { } brackets) dft_wrapper_clock_gate_reg This feature works only when you enable clock gate support for DFT wrapper cells. To enable clock gate support for DFT wrapper cells, set the following variable to true compile.clockgate.enable_dft_wrapper_cell_support Fusion Compiler User Guide 335 Chapter 4: Clock Gating Special Naming and Querying for DFT Wrapper Clock Gates Feedback The following figures show how a clock gate can be split so that different clock gates can gate internal cells and wrapper cells separately: Figure 69 Splitting a Clock Gate to Internal Cells and Wrapper Cells Figure 70 Gating Internal Cells and Wrapper Cells Separately Fusion Compiler User Guide 336 Chapter 4: Clock Gating Special Naming and Querying for DFT Wrapper Clock Gates Feedback Note: The clock gates cloned to gate wrapper cells alone, inherit their names from parent clock gates and have dft_wrapper_ appended to their names. This is not applicable to the names of self-gates that drive wrapper cells only. Table 25 shows how different types of clock gates are renamed. Table 25 How different clock gate types are renamed Clock Gate Type Name New Name tool-inserted clock_gate_reg dft_wrapper_clock_gate_reg pre-existing icg_0 dft_wrapper_icg_0 Use the -gating_wrapper_cells_only option with the get_clock_gates command to return all clock gates (except self-gates) that drive wrapper cells only. This option can be used in conjunction with the already existing options. Use the compile.clockgate.substring_list_for_dft_wrapper_dont_rename_icgs application option to restrict the renaming of pre-existing clock gates (driving wrapper cells only). This option accepts a list of strings as values. The clock gates matching any of the substrings provided in the application option are not renamed. Note: The compile.clockgate.substring_list_for_dft_wrapper_dont_rename_icgs application option does not have any effect on the -gating_wrapper_cells_only querying option. Consider the following example: set_app_options -name compile.clockgate.substring_list_for_dft_wrapper_dont_rename_icgs -value {clk_gate_ctl clk_gate_snps} This prevents the renaming of any pre-existing clock gates that have the clk_gate_ctl or clk_gate_snps pattern in their name but can still be queried using the get_clock_gates -gating_wrapper_cells_only command. Fusion Compiler User Guide 337 Feedback"}
{"header": "Protecting Via Ladders", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To prevent via ladders from being edited, set the design.enable_via_ladder_protection application option to true fc_shell> set_app_options -name design.enable_via_ladder_protection \\ -value true When the design.enable_via_ladder_protection application option is true , the following commands process only objects that do not belong to via ladders: remove_shapes remove_vias Fusion Compiler User Guide 459 Chapter 6: Routing and Postroute Optimization Inserting Via Ladders Feedback remove_objects set_attribute set_via_def add_to_edit_group If an object belongs to a via ladder, these commands issue a warning message and do not process the object. The following example sets the design.enable_via_ladder_protection application option to true and attempts to remove a collection of shapes: fc_shell> set_app_options -name design.enable_via_ladder_protection \\ -value true ... fc_shell> sizeof_collection [get_shapes -of net1] 77 fc_shell> remove_shapes [get_shapes -of net1] -verbose Warning: Cannot PATH_32_7403 because it is part of via_ladder. (NDM-160) 76"}
{"header": "Adding Buffers on Routed Nets", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To add buffers or pairs of inverters on a fully routed net, use the add_buffer_on_route command as described in the following topics: Specifying the Net Names, Buffers Types, and Their Locations Controlling How Buffers are Added Specifying Settings for Multivoltage Designs Specifying Settings for the Freeze Silicon ECO Flow"}
{"header": "Clock-Gating Setup Condition", "size": 15.0, "font": "Arial-BoldMT", "flags": 20, "text": "To perform clock gating, the tool requires that the enable signal of the register bank is synchronous with its clock. This is the setup condition. For latch-based or integrated clock gating, the tool can insert clock gating irrespective of the enable signal's and the clock's clock domains. If the enable signal and the register bank reside in different clock domains, you must ensure that the two clock domains are synchronous and that the setup and hold times for the clock-gating cell meet the timing requirements. An exception exists for primary input ports that use a clock specified with the set_input_delay command. In this case, the input port is synchronous with the clock and the setup condition is true."}
{"header": "Handling Fixed Cells During Relative Placement", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To specify how to handle fixed cells in the floorplan during legalization of relative placement groups, use the -place_around_fixed_cells option with the set_rp_group_options command. Table 59 shows the different settings you can specify for the -place_around_fixed_cells option. Table 59 Settings for the -place_around_fixed_cells Option To do this Use this setting Legalize relative placement groups around fixed standard cells and avoid fixed physical-only cells. standard Legalize relative placement groups around fixed physical-only cells and avoid fixed standard cells. physical_only Legalize relative placement groups around both fixed standard cells and fixed physical-only cells. This is the default. all Avoid both fixed standard cells and fixed physical-only cells. none For hierarchical relative placement groups, you can use the set_rp_group_options -place_around_fixed_cells command and specify different settings for the top-level and the lower-level relative placement groups. If you do not specify a setting for the lower- level placement groups, the value of the top-level relative placement group is used for the lower-level relative placement groups. Fusion Compiler User Guide 804 Chapter 10: Physical Datapath With Relative Placement Specifying Options for Relative Placement Groups Feedback Assume a hierarchical relative placement group named top-rp contains three lower-level relative placement groups named rp1, rp2, and rp3. The following example specifies a less restrictive setting for the top level and a more restrictive setting for the lower-level group named rp1. It also specifies that the setting for the rp1 lower-level group overrides the top- level setting when legalizing the cells in the rp1 group. fc_shell> set_rp_group_options top-rp \\ -place_around_fixed_cells physical_only fc_shell> set_rp_group_options rp1 \\ -place_around_fixed_cells none fc_shell> set_app_options -name set_rp_group_options -value true"}
{"header": "in Library Cell Families", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "When a family of cells with the same function is ordered in terms of increasing drive strength, specific cell property values should be monotonically increasing or decreasing. For example, when a family is ordered in terms of increasing drive strength, the area of cells should be monotonically increasing, power should be increasing, and delay (for the same output load and input slew) should be decreasing. Fusion Compiler User Guide 84 Chapter 2: Preparing the Design Analyzing Libraries Feedback The following figure shows a monotonic distribution of cell area versus timing for a family of cells with the same function. Figure 9 Monotonic Distribution in Library Cell Family Fusion Compiler User Guide 85 Chapter 2: Preparing the Design Analyzing Libraries Feedback A cell is considered redundant if all its metrics, such as area, delay, power, and so on, are equal or worse than another cell, as shown in the following plot of cell area versus timing for a family of cells with the same function. Figure 10 Redundant Cell in Library Cell Family Fusion Compiler User Guide 86 Chapter 2: Preparing the Design Analyzing Libraries Feedback A cell is considered an outlier if its metrics has a very large deviation from the expected values, as shown in the following plot of cell area versus timing for a family of cells with the same function. Figure 11 Outlier Cell in Library Cell Family Fusion Compiler User Guide 87 Chapter 2: Preparing the Design Analyzing Libraries Feedback Cells are considered equivalent if all their properties are the same for all process, voltage, and temperature (PVT) values, as shown in the following plot of cell area versus timing for a family of cells with the same function. Figure 12 Equivalent Cells in Library Cell Family Fusion Compiler User Guide 88 Chapter 2: Preparing the Design Analyzing Libraries Feedback A gap is when there is a large difference between two successive drive strengths, as shown in the following plot of cell area versus timing for a family of cells with the same function. Figure 13 Gap in Library Cell Family"}
{"header": "Specifying Tap Assignment Options and Settings", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "Before you can perform automated tap assignment by using the synthesize_multisource_clock_taps command, you must perform the following steps: 1. Remove dont_touch size_only fixed , and locked attributes setting on the clock cells that are not required. These settings prevent the tool from merging or splitting clock cells during tap assignment, if necessary. 2. Specify settings for automated tap assignment by using the set_multisource_clock_tap_options command. You must specify The clock for tap assignment by using the -clock option. All the sinks reachable from the given clock are considered for redistribution. The tap drivers among which the sinks are redistributed by using the -driver_objects option. Fusion Compiler User Guide 427 Chapter 5: Clock Tree Synthesis Implementing Multisource Clock Trees Feedback The number of taps that the sinks are redistributed among by using the -num_taps option. Currently, the number of taps specified with this option must be equal to the number of drivers specified with the -driver_objects option. To prevent the tool from merging specific clock tree cells, specify the instance names using the -dont_merge_cells option. To report the settings you specify for automated tap assignment, use the report_multisource_clock_tap_options command. To remove the settings you specify for automated tap assignment, use the remove_multisource_clock_tap_options command. 3. (Optional) Create multisource sink groups for tap assignment by using the create_multisource_clock_sink_group command. Skew groups defined for the clock can be distributed among different taps. To retain the objects of a skew group under the same tap, create a corresponding multisource sink group. Use the following commands to remove, report, or manipulate multisource sink groups: remove_multisource_clock_sink_groups report_multisource_clock_sink_groups get_multisource_clock_sink_groups add_to_multisource_clock_sink_group remove_from_multisource_clock_sink_group 4. (Optional) Specify name prefixes and suffixes to use when merging and splitting clock cells during tap assignment by using the following application options: cts.multisource.subtree_merge_cell_name_prefix cts.multisource.subtree_merge_cell_name_suffix cts.multisource.subtree_split_cell_name_prefix cts.multisource.subtree_split_cell_name_suffix cts.multisource.subtree_split_net_name_prefix cts.multisource.subtree_split_net_name_suffix Fusion Compiler User Guide 428 Chapter 5: Clock Tree Synthesis Implementing Multisource Clock Trees Feedback"}
{"header": "Specifying the Global Layer Constraints", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To specify the global layer constraints, use the set_ignored_layers command. By default, the global layer constraints are used for RC estimation, congestion analysis, and as soft constraints for routing. Use the following options to set the constraints and change the default behavior. To specify the minimum and maximum routing layers, use the -min_routing_layer and -max_routing_layer options. Specify the routing layers by using the layer names from the technology file. For example, to use layers M2 through M7 for routing, RC estimation, and congestion analysis, use the following command: fc_shell> set_ignored_layers \\ -min_routing_layer M2 -max_routing_layer M7 To allow the use of layers beyond the minimum or maximum routing layer only for pin connections, set the route.common.global_min_layer_mode and route.common.global_max_layer_mode application options to allow_pin_connection Fusion Compiler User Guide 199 Chapter 2: Preparing the Design Specifying the Routing Resources Feedback To change the constraints to hard constraints, set the route.common.global_min_layer_mode and route.common.global_max_layer_mode application options to hard To specify additional layers to be ignored for RC estimation and congestion analysis, use the -rc_congestion_ignored_layers option. The specified layers must be between the minimum and maximum routing layers. For example, to use layers M2 through M7 for routing and layers M3 through M7 for RC estimation and congestion analysis, use the following command: fc_shell> set_ignored_layers \\ -min_routing_layer M2 -max_routing_layer M7 \\ -rc_congestion_ignored_layers {M2} To change an existing layer constraint setting, simply reset that option. When you reset an option, it overrides the existing value of only that option; the other option settings remain unchanged. For example, assume that you used the previous command to set the minimum routing layer to M2 and the maximum routing layer to M7. To change the maximum routing layer from M7 to M8, but keep the other settings, use the following command: fc_shell> set_ignored_layers -max_routing_layer M8"}
{"header": "Inserting Clock Gates in Multivoltage Designs", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "In a multivoltage design, the different hierarchies of the design might have different operating conditions and use different target library subsets. When inserting clock-gating cells in a multivoltage design, the tool chooses the appropriate library cells based on the specified clock-gating style as well as the operating conditions that match the operating conditions of the hierarchical cell of the design. If you do not specify a clock-gating style, the tool uses a default style where the test point is before and the observation output is false If the tool does not find a library cell that suits the clock-gating style and the operating conditions, the tool issues a warning message and does not insert a clock-gating cell. To check whether there are integrated clock-gate cells available for clock-gate insertion, use the check_clock_gate_library_cell_availability command."}
{"header": "Controlling the Placement Density", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can control the placement density of a block as described in the following table. Table 10 Application Options for Controlling Placement Density To do this Use this application option Specify a maximum density that controls how densely the tool can place cells during non-congestion-driven placement place.coarse.auto_density_control (Default is -enhanced , and the tool follows a preset schedule during the flow if place.coarse.auto_density_control is not set to false . Disabling place.coarse.auto_density_control or manually setting place.coarse.max_density to causes uniform spreading of the cells in the core area) Specify a maximum utilization that controls how densely the tool can place cells in less congested areas that surround highly congested areas, so that the cells in the congested areas can be spread out to reduce the congestion place.coarse.congestion_driven_max_util (Default is 0.93 When specifying the maximum density or maximum utilization, choose a value between 1 and the overall utilization of the block. For example, if the utilization of a block is 40 percent, you can choose values between 1 and 0.4, as shown in the following example: fc_shell> set_app_options -name place.coarse.max_density -value 0.6 fc_shell> set_app_options \\ -name place.coarse.congestion_driven_max_util -value 0.8 If you do not specify a value for the maximum density or maximum utilization, the tool automatically derives a value for the maximum density and maximum utilization based on the stage of the design flow, considering the place.coarse.auto_density_control application option is not set to false By default, the place.coarse_auto_density_control application option is enabled and set to enhanced . This improves the total power and wire length for the design. Note: It is not necessary to disable the place.coarse.auto_density_control application option to override the max_density and congestion_driven_max_util values. User settings always take precedence over the tool derived values. Throughout placement, the tool prints PLACE-027 information messages indicating the values it uses for these settings. Fusion Compiler User Guide 155 Chapter 2: Preparing the Design Specifying Placement Settings Feedback Information: Automatic density control has selected the following settings: max_density 0.60, congestion_driven_max_util 0.77. (PLACE-027) The tool applies the maximum density and congestion-driven maximum utilization settings independently to each placeable area such as a voltage area or exclusive move bound, rather than taking an average over the entire block."}
{"header": "Reading Designs Using the VCS Command-line Options", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The analyze command with the VCS command-line options provides compatibility with VCS simulation scripts and makes reading large designs easier. When you use the VCS command-line options, the tool automatically resolves references for instantiated designs by searching the referenced designs in the specified libraries and then loading these referenced designs. To read designs containing many HDL source files and libraries, specify the -vcs option with the analyze command. You must enclose the VCS command-line options in double quotation marks. For example, analyze -vcs \"-verilog -y mylibdir1 +libext+.v -v myfile1 \\ +incdir+myincludedir1 -f mycmdfile2\" top.v elaborate ${DESIGN_NAME} set_top_module ${DESIGN_NAME} To read SystemVerilog files with a specified file extension and Verilog files in one analyze command, use the -vcs \"+systemverilogext+ext\" option. When you do so, the files must not contain any Verilog 2001 styles. For example, the following command analyzes SystemVerilog files with the .sv file extension and Verilog files: analyze -format verilog -vcs \"-f F +systemverilogext+.sv elaborate ${DESIGN_NAME} set_top_module ${DESIGN_NAME}"}
{"header": "Defining Sink Pins", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "To define one or more pins as sink pins, use the following syntax: set_clock_balance_points -clock clock -consider_for_balancing true -balance_points pins [-corners corners The -clock option is not required. If you do not use it, the sink pin applies to all clocks. By default, the insertion delay for the user-specified sink pins is 0. For information about overriding the default insertion delay, see Defining Insertion Delay Requirements When you define sink pins, by default, they apply to all corners. To apply the definition to specific corners, use the -corners option. For example, to specify pin U2/A as a sink pin for the CLK clock in the current corner, use the following command: fc_shell> set_clock_balance_points -clock [get_clocks CLK] \\ -consider_for_balancing true -balance_points [get_pins U2/A] To report the user-defined sink pins, use the remove_clock_tre_exceptions comand-stop_pinscomandsremove_clock_tre_exceptions-stop_pins report_clock_balance_points command. This command reports both the user-defined sink pins and the user-defined ignore pins. To remove the sink pin definition from a pin, use the remove_clock_tre_exceptions comand-stop_pinscomandsremove_clock_tre_exceptions-stop_pins remove_clock_balance_points command. For example, to remove the sink pin definition from the U2/A pin for the CLK clock, use the following command: fc_shell> remove_clock_balance_points -clock [get_clocks CLK] \\ -balance_points [get_pins U2/A]"}
{"header": "Improvement", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The following topics provide information settings you can use to improve performance, power, and area (PPA) of a design: Enabling High-Effort Timing Mode Enabling Enhanced Delay Optimization to Improve Total Negative Slack Enabling High-Effort Area Mode Enabling the Embedded Area Optimization Flow"}
{"header": "Direction", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can use a routing guide to limit the number of occurrences of a specific routing pattern within the routing guide boundary on specific layers. Zroute tries to route the nets within the routing guide to meet this constraint; however, if the number of edges in the nonpreferred direction exceeds the specified threshold, Zroute reports a violation. To create this type of routing guide, use the -max_patterns option with the create_routing_guide command. Use the following syntax to specify the routing pattern and its threshold for each affected layer: { { layer pattern limit } ... } In addition to using the -max_patterns option, you must also use the -layers option when you create this type of routing guide. Specify the same layers in the -layers option as those specified in the -max_patterns option. Fusion Compiler User Guide 476 Chapter 6: Routing and Postroute Optimization Routing Constraints Feedback If you do not specify a pattern threshold for a layer, the routing pattern has no limit for that layer. Currently, the only supported pattern is non_pref_dir_edge , which represents the edges in the nonpreferred direction. For example, to limit the number of edges in the nonpreferred direction to two on M2 and to three on M4, with no limits on other layers, use the following command: fc_shell> create_routing_guide -boundary {{50 50} {200 200}} \\ -max_patterns {{M2 non_pref_dir_edge 2} {M4 non_pref_dir_edge 3}} \\ -layers {M2 M4}"}
{"header": "Defining an Inner Keepout Margin", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "You can define an inner keepout margin on a hierarchical cell, but not on a hard macro or a leaf cell. When you define an inner keepout margin, you must specify the keepout distance explicitly. To explicitly specify an inner keepout margin, use the -inner option to specify the margin distance for each side. You specify the left, bottom, right, and top margins using the following format: lx by rx ty . A value of 0 results in no keepout margin for that side. For example, to create a hard inner keepout margin with a margin of 10 on each side for a hierarchical cell named my_hcell, use the following command: fc_shell> create_keepout_margin -inner {10 10 10 10} my_hcell"}
{"header": "Corner Type", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "The custom.route.bus_corner_type application option specifies how the tool routes the bus trunks at corners. Valid values are: Valid Value Description auto (Default) Automatically determines the optimal corner type for the bit or pin alignment to reduce routing congestion. Fusion Compiler User Guide 766 Chapter 9: Routing Using Custom Router Using Custom Routing Application Options Feedback Valid Value Description cross Routes the bits so that they overlap at the corner. river Routes the bits so that they do not overlap at the corner."}
{"header": "Controlling Sequential Output Inversion", "size": 14.0, "font": "Arial-BoldMT", "flags": 20, "text": "By default, the compile_fusion command can map a register to a sequential library cell with an output that is opposite to that of the register, if it improves QoR. This is known as sequential output inversion. Sequential output inversion is also useful when mapping to a target library with sequential cells that have only one type of asynchronous inputs (either set or reset). In this case, the only way to map a register that uses the missing asynchronous inputs is to use a library cell with the opposite type of asynchronous input and invert the output of that cell, as shown in the following figure. This figure shows an example of sequential output inversion during mapping. ___ SET ___ RST QN ___ RST Fusion Compiler User Guide 235 Chapter 3: Physical Synthesis Controlling Mapping and Optimization Feedback Note: Information about inverted registers is written to the verification guidance (.svf) file. You must include the .svf file in the Formality tool when verifying blocks with sequential output inversion. To control sequential output inversion for The entire block, use the compile.seqmap.enable_output_inversion application option. The default is true Specific hierarchical or leaf cells, use the set_register_output_inversion command. An instance-specific sequential output inversion setting specified with the set_register_output_inversion command overrides a block-specific setting specified with the compile.seqmap.enable_output_inversion application option. The compile_fusion command allows the mapping of sequential elements in the design to sequential library cells whose output phase is inverted. In certain cases, the tool might infer a register that has one type of asynchronous control, but your library has the opposite type of pin. In such cases, the tool maps to the opposite type of register and inverts all the data inputs and outputs."}
